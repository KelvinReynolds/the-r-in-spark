[
["intro.html", "Mastering Apache Spark with R Chapter 1 Introduction 1.1 Overview 1.2 Hadoop 1.3 Spark 1.4 R 1.5 sparklyr 1.6 Recap", " Mastering Apache Spark with R Javier Luraschi, Kevin Kuo, Edgar Ruiz Chapter 1 Introduction “You know nothing, Jon Snow.” — Ygritte With information growing at exponential rates, it’s no surprise that historians are referring to this period of history as the Information Age. The increasing speed at which data is being collected has created new opportunities and is certainly staged to create even more. This chapter presents the tools that have been used to solve large-scale data challenges and introduces Apache Spark as a leading tool that is democratizing our ability to process large datasets. We will then introduce the R computing language, which was specifically designed to simplify data analysis. It is then natural to ask what the outcome would be from combining the ease of use provided by R, with the compute power available through Apache Spark. This will lead us to introduce sparklyr, a project merging R and Spark into a powerful tool that is easily accessible to all. The next chapter, Getting Started, will present the prerequisites, tools and steps you will need to perform to get Spark and R working in your personal computer. You will learn how to install Spark, initialize Spark, get introduced to common operations and help you get your very first data processing and modeling task done. It is the goal of that chapter to help anyone grasp the concepts and tools required to start tackling large-scale data challenges which, until recently, were only accessible to just a few organizations. You will then move on into learning how to analyze large-scale data, followed by building models capable of predicting trends and discover information hidden in vast amounts of information. At which point, you will have the tools required to perform data analysis and modeling at scale. Subsequent chapters will help you move away from your local computer into computing clusters required to solve many real world problems. The last chapters will present additional topics, like real time data processing and graph analysis, which you will need to truly master the art of analyzing data at any scale. The last chapter of this book will give you tools and inspiration to consider contributing back to the Spark and R communities. We hope this is a journey you will enjoy, that will help you solve problems in your professional career to nudge the world into taking better decisions that can benefit us all. 1.1 Overview As humans, we have been storing, retrieving, manipulating, and communicating information since the Sumerians in Mesopotamia developed writing in about 3000 BC. Based on the storage and processing technologies employed, it is possible to distinguish four distinct phases of development: pre-mechanical (3000 BC – 1450 AD), mechanical (1450–1840), electromechanical (1840–1940), and electronic (1940–present). (Laudon, Traver, and Laudon 1996) Mathematician George Stibitz used the word digital to describe fast electric pulses back in 1942 (Ceruzzi 2012) and, to this day, we describe information stored electronically as digital information. In contrast, analog information represents everything we have stored by any non-electronic means such as hand written notes, books, newspapers, and so on. (Webster 2006) The world bank report on digital development provides an estimate of digital and analog information stored over the last decades. (Group 2016) This report noted that digital information surpassed analog information around 2003. At that time, there were about 10 million terabytes of digital information, which is roughly about 10 million storage drives today. However, a more relevant finding from this report was that our footprint of digital information is growing at exponential rates. Figure 1.1 shows the findings of this report, notice that every other year, the world’s information has grown tenfold. FIGURE 1.1: World’s capacity to store information With the ambition to provide tools capable of searching all this new digital information, many companies attempted to provide such functionality with what we know today as search engines, used when searching the web. Given the vast amount of digital information, managing information at this scale was a challenging problem. Search engines were unable to store all the web page information required to support web searches in a single computer. This meant that they had to split information into several files and store them across many machines. This approach became known as the Google File System, a research paper published in 2003 by Google. (Ghemawat, Gobioff, and Leung 2003) 1.2 Hadoop One year later, Google published a new paper describing how to perform operations across the Google File System, this approach came to be known as MapReduce. (Dean and Ghemawat 2004) As you would expect, there are two operations in MapReduce: Map and Reduce. The map operation provides an arbitrary way to transform each file into a new file, while the reduce operation combines two files. Both operations require custom computer code, but the MapReduce framework takes care of automatically executing them across many computers at once. These two operations are sufficient to process all the data available in the web, while also providing enough flexibility to extract meaningful information from it. For example, as illustrated in Figure 1.2, we can use MapReduce to count words in two different text files stored in different machines. The mapping operation splits each word in the original file and outputs a new word-counting file with a mapping of words and counts. The reduce operation can be defined to take two word-counting files and combine them by aggregating the totals for each word, this last file will contain a list of word counts across all the original files. FIGURE 1.2: MapReduce example counting words across files Counting words is often the most basic MapReduce example, but it can be also used for much more sophisticated and interesting applications. For instance, MapReduce can be used to rank web pages in Google’s PageRank algorithm, which assigns ranks to web pages based on the count of hyperlinks linking to a web page and the rank of the page linking to it. After these papers were released by Google, a team in Yahoo worked on implementing the Google File System and MapReduce as a single open source project. This project was released in 2006 as Hadoop with the Google File System implemented as the Hadoop File System, or HDFS for short. The Hadoop project made distributed file-based computing accessible to a wider range of users and organizations, making MapReduce useful beyond web data processing. While Hadoop provided support to perform MapReduce operations over a distributed file system, it still required MapReduce operations to be written with code every time a data analysis was run. To improve over this tedious process, the Hive project released in 2008 by Facebook, brought Structured Query Language (SQL) support to Hadoop. This meant that data analysis could now be performed at large-scale without the need to write code for each MapReduce operation; instead, one could write generic data analysis statements in SQL that are much easier to understand and write. 1.3 Spark In 2009, Apache Spark began as a research project at the UC Berkeley’s AMPLab to improve on MapReduce. Specifically, by providing a richer set of verbs beyond MapReduce that facilitate optimizing code running in multiple machines, and by loading data in-memory making operations much faster than Hadoop’s on-disk storage. One of the earliest results showed that running logistic regression, a data modeling technique that will be introduced under the Modeling chapter, allowed Spark to run 10 times faster than Hadoop by making use of in-memory datasets (Zaharia et al. 2010), a chart similar to Figure 1.3 was presented in the original research publication. FIGURE 1.3: Logistic regression performance in Hadoop and Spark While Spark is well known for its in-memory performance, Spark was designed to be a general execution engine that works both in-memory and on-disk. For instance, Spark has set new records in large-scale sorting (“Sort Benchmark” 2014), where data was not loaded in-memory; but rather, Spark made use of improvements in network serialization, network shuffling and efficient use of the CPU’s cache to dramatically improve performance. If you needed to sort large amounts of data, there was no other system in the world faster than Spark. To give you a sense of how much faster and efficient Spark is, you can sort 100 terabytes of data in 72min and 2100 computers using Hadoop, but only 206 computers in 23 minutes using Spark (“Apache Spark Officially Sets a New Record in Large-Scale Sorting” 2014). In addition, Spark holds the cloud sorting benchmark (“Spark Wins Cloudsort Benchmark as the Most Efficient Engine” 2016), which made Spark the most cost effective solution for sort large-datasets in the cloud. Hadoop Record Spark Record Data Size 102.5 TB 100 TB Elapsed Time 72 mins 23 mins Nodes 2100 206 Cores 50400 6592 Disk 3150 GB/s 618 GB/s Network 10Gbps 10Gbps Sort rate 1.42 TB/min 4.27 TB/min Sort rate / node 0.67 GB/min 20.7 GB/min Spark is also easier to use than Hadoop; for instance, the word-count MapReduce example takes about fifty lines of code in Hadoop, but it only takes two lines of code in Spark – Spark is much faster, efficient and easier to use than Hadoop. In 2010, Spark was released as an open source project and then donated to the Apache Software Foundation in 2013. Spark is licensed under the Apache 2.0, which allows you to freely use, modify, and distribute it. Spark then reached over 1000 contributors, making it one of the most active projects in the Apache Software Foundation. This gives an overview of how Spark came to be, which we can now use to formally introduce Apache Spark as follows: “Apache Spark is a unified analytics engine for large-scale data processing.” — spark.apache.org To help us understand this definition of Apache Spark, we will break it down as follows: Unified Spark supports many libraries, clusters technologies and storage systems. Analytics Analytics is the discovery and interpretation of data to produce and communicate information. Engine Spark is expected to be efficient and generic. Large-Scale One can interpret large-scale as cluster-scale, a set of connected computers working together. Spark is described as an engine since it’s generic and efficient, it optimizes and executes generic code; there are no restrictions as to what type of code one can write in Spark. It is also quite efficient, as we mentioned, Spark is much faster than other technologies by making efficient use of memory, network and CPUs to speed data processing algorithms in computing clusters. This makes Spark ideal in many analytics projects like ranking movies at Netflix (“Netflix at Spark” 2018), aligning protein sequences (“Bioinformatics Applications on Apache Spark” 2018) or analyzing high energy physics at CERN. (“Apache Spark and Cern Open Data Analysis, an Example” 2017) As a unified platform, Spark is expected to support many cluster technologies and multiple data sources, which you will learn about in the Clusters and Data chapters. It is also expected to support many different libraries like Spark SQL, MLlib, GraphX and Spark Streaming; libraries which you can use for analysis, modeling, graph processing and real-time data processing respectively. You can think of Spark as a platform providing access to clusters, data sources and libraries for large-scale computing as illustrated in Figure 1.4. FIGURE 1.4: Spark as a unified analytics engine for large-scale data processing Describing Spark as large scale implies that a good use case for Spark is tackling problems that can be solved with multiple machines. For instance, when data does not fit in a single disk driver or does not fit into memory, Spark is a good candidate to consider. However, it can also be considered for problems that may not be large-scale, but where using multiple computers could speed up computation. For instance, CPU intensive models or scientific simulations also benefit from running in Spark. Therefore, Spark is good at tackling large-scale data processing problems, this usually known as big data (datasets that are more voluminous and complex that traditional ones (“Big Data Wikipedia” 2019)) but also is good at tackling large-scale computation problems, known as big compute (tools and approaches using a large amount of CPU and memory resources in a coordinated way (“Big Compute Nimbix” 2019)). Big data often requires big compute but big compute does not necessarily requires big data. (“Big Compute Vs Big Data” 2013) Big data and big compute problems are usually easy to spot – if the data does not fit into a single machine, you might have a big data problem; if the data fits into a single machine but processing it takes days, weeks or even months to compute, you might have a big compute problem. However, there is also a third problem space where neither data nor compute are necessarily large-scale and yet, there are significant benefits to using cluster computing frameworks like Spark. For this third problem space, there are a few use cases this breaks to: Velocity Suppose you have a dataset of 10 gigabytes in size and a process that takes 30 minutes to run over this data – this is by no means big compute nor big data. However, if you happen to be researching ways to improve the accuracy of your models, reducing the runtime down to 3 minutes is a significant improvement, which can lead to significant advances and productivity gains by increasing the velocity at which you can analyze data. Alternatively, you might need to process data faster, for stock trading for instance, while 3 minutes could seem fast enough; it can be way too slow for real-time data processing, where you might need to process data in a few seconds – or even down to a few milliseconds. Variety You could also have an efficient process to collect data from many sources into a single location, usually a database, this process could be already running efficiently and close to real-time. Such processes are known at ETL (Extract-Transform-Load); data is extracted from multiple sources, transformed to the required format and loaded into a single data store. While this has worked for years, the tradeoff from this approach is that adding a new data source is expensive. Since the system is centralized and tightly controlled, making changes could cause the entire process to halt; therefore, adding new data source usually takes too long to be implemented. Instead, one can store all data its natural format and process it as needed using cluster computing, this architecture is currently known as a data lake. In addition, storing data in its raw format allows you to process a variety of new file formats like images, audio and video; without having to figure out how to fit them into conventional structured storage systems. Veracity When using many data sources, their data quality might vary greatly between them; which requires special analysis methods to improve its accuracy. For instance, suppose you have a table of cities with values like San Francisco, Seattle and Boston, what happens when data contains a misspelled entry like “Bston”? In a relational database, this invalid entry might get dropped; however, dropping values is not necessarily the best approach in all cases, you might want to correct this field by making use of geocodes, cross referencing data sources or attempting a best-effort match. Therefore, understanding and improving the veracity of the original data source can lead to more accurate results. If we include “Volume” as a synonym for big data, you get the mnemonics people refer as the four ’V’s of big data; others have gone as far as expanding this to five or even as the 10 Vs of Big Data. Mnemonics aside, cluster computing is being used today in more innovative ways and and is not uncommon to see organizations experimenting with new workflows and a variety of tasks that were traditionally uncommon for cluster computing. Much of the hype attributed to big data falls into this space where, strictly speaking, one is not handling big data but there are still benefits from using tools designed for big data and big compute. Our hope is that this book will help you understand the opportunities and limitations of cluster computing, and specifically, the opportunities and limitations from using Apache Spark with R. 1.4 R The R computing language has its origins in the S language, created at Bell Laboratories. R was not created at Bell Labs, but its predecessor, the S computing language was. Rick Becker explained in useR 2016 (“The History of R’s Predecessor, S, from Co-Creator Rick Becker” 2016) that at that time in Bell Labs, computing was done by calling subroutines written in the Fortran language which, apparently, were not pleasant to deal with. The S computing language was designed as an interface language to solve particular problems without having to worry about other languages, such as Fortran. The creator of S, John Chambers, describes in Figure 1.5 how S was designed to provide an interface that simplifies data processing, this was presented during useR! 2016 as the original diagram that inspired the creation of S. FIGURE 1.5: Interface language diagram by John Chambers - Rick Becker useR 2016 R is a modern and free implementation of S, specifically: R is a programming language and free software environment for statistical computing and graphics. — The R Project for Statistical Computing While working with data, we believe there are two strong arguments for using R: R Language R was designed by statisticians for statisticians, meaning, this is one of the few successful languages designed for non-programmers; so learning R will probably feel more natural. Additionally, since the R language was designed to be an interface to other tools and languages, R allows you to focus more on understanding data and less on peculiarities of computer science and engineering. R Community The R community provides a rich package archive provided by CRAN (The Comprehensive R Archive Network) which allows you to install ready-to-use packages to perform many tasks; most notably, high-quality data manipulation, visualization and statistical models, many of which are only available in R. In addition, the R community is a welcoming and active group of talented individuals motivated to help you succeed. Many packages provided by the R community make R, by far, the best option for statistical computing. Some of the most downloaded R packages include: dplyr to manipulate data, cluster to analyze clusters and ggplot2 to visualize data. Figure 1.6 quantifies the growth of the R community by plotting daily downloads of R packages in CRAN. FIGURE 1.6: Daily downloads of CRAN packages Aside from statistics, R is also used in many other fields. The following ones are particularly relevant to this book: Data Science Data science is based on knowledge and practices from statistics and computer science that turns raw data into understanding (Wickham and Grolemund 2016) by using data analysis and modeling techniques. Statistical methods provide a solid foundation to understand the world and perform predictions, while the automation provided by computing methods allows us to simplify statistical analysis and make it much more accessible. Some have advocated that statistics should be renamed data science; (Wu 1997) however, data science goes beyond statistics by also incorporating advances in computing. (Cleveland 2001) This book presents analysis and modeling techniques common in statistics, but applied to large datasets which requires incorporating advances in distributed computing. Machine Learning Machine learning uses practices from statistics and computer science; however, it is heavily focused on automation and prediction. For instance, the term “machine learning” was coined by Arthur Samuel while automating a computer program to play checkers. (Samuel 1959) While we could perform data science on particular games, writing a program to play checkers requires us to automate the entire process. Therefore, this falls in the realm of machine learning, not data science. Machine learning makes it possible for many users to take advantage of statistical methods without being aware of the statistical methods that are being used. One of the first important applications of machine learning was to filter spam emails; in this case, it’s just not feasible to perform data analysis and modeling over each email account; therefore, machine learning automates the entire process of finding spam and filtering it out without having to involve users at all. This book will present the methods to transition data science workflows into fully-automated machine learning methods; for instance, by providing support to build and export Spark pipelines that can be easily reused in automated environments. Deep Learning Deep learning builds on knowledge of statistics, data science and machine learning to define models vaguely inspired on biological nervous systems. Deep learning models evolved from neural network models after the vanishing-gradient-problem was resolved by training one layer at a time (Hinton, Osindero, and Teh 2006) and have proven useful in image and speech recognition tasks. For instance, when using voice assistants like Siri, Alexa, Cortana or Google, the model performing the audio to text conversion is most likely to be based on deep learning models. While GPUs (Graphic Processing Units) have been successfully used to train deep learning models; (Krizhevsky, Sutskever, and Hinton 2012) some datasets can not be processed in a single GPU. It is also the case that deep learning models require huge amounts of data, which needs to be preprocessed across many machines before they can be fed into a single GPU for training. This book won’t make any direct references to deep learning models; however, the methods presented in this book can be used to prepare data for deep learning and, in the years to come, using deep learning with large-scale computing will become a common practice. In fact, recent versions of Spark have already introduced execution models optimized for training deep learning in Spark. While working in any of the previous fields, you will be faced with increasingly large datasets or increasingly complex computations that are slow to execute or at times, even impossible to process in a single computer. However, it is important to understand that Spark does not need to be the answer to all our computations problems; instead, when faced with computing challenges in R, the following techniques can be as effective: Sampling A first approach to try is reduce the amount of data being handled, through sampling. However, data must be sampled properly by applying sound statistical principles. For instance, selecting the top results is not sufficient in sorted datasets; with simple random sampling, there might be underrepresented groups, which we could overcome with stratified sampling, which in turn adds complexity to properly select categories. It is out of the scope of this book to teach how to properly perform statistical sampling, but many resources are available on this topic. Profiling One can try to understand why a computation is slow and make the necessary improvements. A profiler, is a tool capable of inspecting code execution to help identify bottlenecks. In R, the R profiler, the profvis R package (“Profvis” 2018) and RStudio profiler feature (“RStudio Profiler” 2018), allow you to easily to retrieve and visualize a profile; however, it’s not always trivial to optimize. Scaling Up Speeding up computation is usually possible by buying faster or more capable hardware, say, increasing your machine memory, hard drive or procuring a machine with many more CPUs, this approach is known as “scaling up”. However, there are usually hard limits as to how much a single computer can scale up and even with significant CPUs, one needs to find frameworks that parallelize computation efficiently. Scaling Out Finally, we can consider spreading computation and storage across multiple machines; this approach provides the highest degree of scalability since one can potentially use an arbitrary number of machines to perform a computation, this approach is commonly known as “scaling out”. However, spreading computation effectively across many machines is a complex endeavour, specially without using specialized tools and frameworks like Apache Spark. This last point brings us closer to the purpose of this book, which is to bring the power of distributed computing systems provided by Apache Spark, to solve meaningful computation problems in Data Science and related fields, using R. 1.5 sparklyr When you think of the computation power that Spark provides and the ease of use of the R language, it is natural to want them to work together – seamlessly. This is also what the R community expected, an R package that would provide an interface to Spark that was: easy to use, compatible with other R packages and, available in CRAN; with this goal, we started developing sparklyr. The first version, sparklyr 0.4, was released during the useR! 2016 conference, this first version included support for dplyr, DBI, modeling with MLlib and an extensible API that enabled extensions like H2O’s rsparkling package. Since then, many new features and improvements have been made available through sparklyr 0.5, 0.6, 0.7, 0.8, 0.9 and 1.0. Officially, sparklyr is an R interface for Apache Spark. It’s available in CRAN and works like any other CRAN package, meaning that: it’s agnostic to Spark versions, it’s easy to install, it serves the R community, it embraces other packages and practices from the R community and so on. It’s hosted in GitHub under github.com/rstudio/sparklyr and licensed under Apache 2.0 which allows you to clone, modify and contribute back to this project. While thinking of who should use sparklyr, the following roles come to mind: New Users: For new users, it is our belief that sparklyr provides the easiest way to get started with Spark. Our hope is that the early chapters of this book will get you up running with ease and set you up for long term success. Data Scientists: For data scientists that already use and love R, sparklyr integrates with many other R practices and packages like dplyr, magrittr, broom, DBI, tibble, rlang and many others that will make you feel at home while working with Spark. For those new to R and Spark, the combination of high-level workflows available in sparklyr and low-level extensibility mechanisms make it a productive environment to match the needs and skills of every data scientist. Expert Users: For those users that are already immersed in Spark and can write code natively in Scala, consider making your Spark libraries available as an R package to the R community, a diverse and skilled community that can put your contributions to good use while moving open science forward. We wrote this book to describe and teach the exciting overlap between Apache Spark and R. sparklyr is the R package that materializes this overlap of communities, expectations, future directions, packages, and package extensions as well. We believe there is an opportunity to use this book to bridge the R and Spark communities, to present to the R community why Spark is exciting and to the Spark community what makes R great. Both communities are solving very similar problems with a set of different skills and backgrounds; therefore, it is our hope that sparklyr can be a fertile ground for innovation, a welcoming place for newcomers, a productive place for experienced data scientists and an open community where cluster computing, data science and machine learning can come together. 1.6 Recap This chapter presented Spark as a modern and powerful computing platform, R as an easy-to-use computing language with solid foundations in statistical methods and, sparklyr, as a project bridging both technologies and communities together. In a world where the total amount of information is growing exponentially, learning how to analyze data at scale will help you tackle the problems and opportunities humanity is facing today. However, before we start analyzing data, the Getting Started chapter will equip you with the tools you will need through the rest of this book. We recommend you follow each step carefully and take the time to install the recommended tools which, we hope will become familiar tools that you use and love. References "],
["starting.html", "Chapter 2 Getting Started 2.1 Overview 2.2 Prerequisites 2.3 Connecting 2.4 Using Spark 2.5 Disconnecting 2.6 Using RStudio 2.7 Resources 2.8 Recap", " Chapter 2 Getting Started “I always wanted to be a wizard.” — Samwell Tarly After reading the Introduction chapter, you should now be familiar with the kind of problems that Spark can help you solve; it should be clear that Spark solves problems by making use of multiple computers when data does not fit in a single machine or when computation is too slow. For those newer to R, it should also be clear that combining Spark with data science tools, like ggplot2 for visualization and dplyr to perform data transformations, brings a promising landscape for doing data science at scale. We also hope you are excited to become proficient in large-scale computing. This chapter, Getting Started, will walk you through the tools you’ll need to become proficient in Spark. We encourage you to walk through the code in this chapter since it will force you to go through the motions of analyzing, modeling, reading and writing data. Read, you will have to do some wax-on, wax-off, repeat; before you get fully immersed in the world of Spark. The next chapter, Analysis, will dive into this topic followed by Modeling; which will present examples using a single-cluster machine, your personal computer. Subsequent chapters will properly introduce cluster computing and the concepts and techniques you’ll need to successfully run code across multiple machines. 2.1 Overview From R, getting started with Spark using sparklyr and a local cluster is as easy as installing and loading the sparklyr package followed by installing Spark using sparklyr; however, we will assume you are starting with a brand new computer running Windows, OS X or Linux and walk you through the prerequisites you’ll need before connecting to a local Spark cluster. While this chapter is designed to help you get ready to use Spark in your personal computer, it’s also likely that some readers will already have a Spark cluster available or might prefer to get started with an online Spark cluster. For instance, Databricks hosts a free community edition (“Databricks Community Edition” 2019) of Spark that can be easily accessed from your web browser. If you end up choosing this path, skip to the prerequisites section of this chapter but make sure you consult the proper resources for your existing or online Spark cluster. Either way, once you are done with the prerequisites, you will first learn how to connect to Spark. We will then present the most important tools and operations that you’ll use through the rest of this book. Less emphasis is placed on teaching concepts or how to use them, we can’t possibly explain modeling or streaming in a single paragraph; however, going through this chapter should give you a brief glimpse of what to expect and confidence that you have the tools correctly configured to tackle harder problems later on. The tools you’ll use are mostly divided into R code and the Spark web interface. All Spark operations are run from R; however, monitoring execution of distributed operations is performed from Sparks web interface; a web interface that you can load from any web browser. We will then disconnect from this local cluster, which is easy to forget to do but highly recommended while working with local clusters – and in shared Spark clusters as well! We will close this chapter by walking you through some of the features that make using Spark with RStudio easier; more specifically, we will present the RStudio extensions that sparklyr implements. However, if you are inclined to use Jupyter notebooks, or if your cluster is already equipped with a different R user interface, rest assured that you can use Spark with R through plain R code. Let’s move along and get your prerequisites properly configured. 2.2 Prerequisites R can run in many platforms and environments; therefore, whether you use Windows, Mac or Linux, the first step is to install R from the r-project.org, detailed instructions are provided in the Installing R appendix. Most people use programming languages with tools to make them more productive; for R, RStudio would be such a tool. Strictly speaking, RStudio is an Integrated Development Environment (or IDE), which also happens to support many platforms and environments. We strongly recommend you get RStudio installed if you haven’t done so already, see details under the Installing RStudio appendix. Tip: When using Windows, we recommend using avoiding directories with spaces in their path. If running getwd() from R returns a path with spaces, consider switching to a path with no spaces using setwd(\"&lt;path&gt;\") or by creating an RStudio project in path with no spaces. Additionally, since Spark is built in the Scala programming language which is run by the Java Virtual Machine, you also need to install Java 8 in your system. It is likely that your system already has Java installed, but you should still check the version and update or downgrade as described in the Installing Java appendix. You can use the following R command to check which version is installed installed: system(&quot;java -version&quot;) java version &quot;1.8.0_201&quot; Java(TM) SE Runtime Environment (build 1.8.0_201-b09) Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode) You can also use the JAVA_HOME environment variable to point to a specific Java version by running Sys.setenv(JAVA_HOME = \"&lt;path-to-java-8&gt;\"); either way, before moving on to installing sparklyr, make sure that Java 8 is the version available for R. 2.2.1 Installing sparklyr As many other R packages, sparkylr is available to be installed from CRAN and can be easily installed as follows: install.packages(&quot;sparklyr&quot;) The examples in this book assume you are using the latest version of sparklyr, you can verify your version is as new as the one we are using by running: packageVersion(&quot;sparklyr&quot;) [1] ‘1.0.2’ 2.2.2 Installing Spark Start by loading sparklyr, library(sparklyr) This makes all sparklyr functions available in R, which is really helpful; otherwise, we would have to run each sparklyr command prefixed with sparklyr::. Spark can be easily installed by running spark_install(); this will download, install and configure the latest version of Spark locally in your computer; however, since we’ve written this book with Spark 2.3, you should also install this version to make sure you can follow all the examples provided without any unexpected surprises. spark_install(&quot;2.3&quot;) All the versions of Spark that are available for installation can be displayed by running: spark_available_versions() ## spark ## 1 1.6 ## 2 2.0 ## 3 2.1 ## 4 2.2 ## 5 2.3 ## 6 2.4 A specific version can be installed using the Spark version and, optionally, by also specifying the Hadoop version. For instance, to install Spark 1.6.3, we would run: spark_install(version = &quot;1.6&quot;) You can also check which versions are installed by running: spark_installed_versions() spark hadoop dir 7 2.3.1 2.7 /spark/spark-2.3.1-bin-hadoop2.7 The path where Spark is installed is referenced as Spark’s home, which is defined in R code and system configuration settings with the SPARK_HOME identifier. When using a local Spark cluster installed with sparklyr, this path is already known and no additional configuration needs to take place. Finally, in order to uninstall a specific version of Spark you can run spark_uninstall() by specifying the Spark and Hadoop versions, for instance: spark_uninstall(version = &quot;1.6.3&quot;, hadoop = &quot;2.6&quot;) Note: The default installation paths are ~/spark for OS X and Linux and, %LOCALAPPDATA%/spark for Windows. To customize the installation path you can run options(spark.install.dir = \"&lt;installation-path&gt;\") before spark_install() and spark_connect(). 2.3 Connecting It’s important to mention that, so far, we’ve only installed a local Spark cluster. A local cluster is really helpful to get started, test code and troubleshoot with ease. Further chapters will explain where to find, install and connect to real Spark clusters with many machines, but for the first few chapters, we will focus on using local clusters. To connect to this local cluster we simply run: library(sparklyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) Note: If you are using your own or online Spark cluster, make sure to connect as specified by your cluster administrator or the online documentation. If you need some pointers, you can take a quick look at the Connections chapter which will explain in detail how to connect to any Spark cluster. The master parameter identifies which is the “main” machine from the Spark cluster; this machine is often called the driver node. While working with real clusters using many machines, most machines will be worker machines and one will be the master. Since we only have a local cluster with only one machine, we will default to use \"local\" for now. After a connection is established, spark_connect() retrieves an active Spark connection which most code usually names sc; you will then make use of sc to execute Spark commands. If connection fails, the Connections chapter contains a troubleshooting section which can help you resolve your connection issue. 2.4 Using Spark Now that you are connected, we can run a few simple commands. For instance, let’s start by copying the mtcars dataset into Apache Spark using copy_to(). cars &lt;- copy_to(sc, mtcars) The data was copied into Spark but we can access it from R using the cars reference. To print its contents we can simply type cars. cars # Source: spark&lt;mtcars&gt; [?? x 11] mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 # … with more rows Congrats! You have successfully connected and loaded your first dataset into Spark. Let’s explain what’s going on in copy_to(). The first parameter, sc, gives the function a reference to the active Spark Connection that was earlier created with spark_connect(). The second parameter specifies a dataset to load into Spark. Now, copy_to() returns a reference to the dataset in Spark which R automatically prints. Whenever a Spark dataset is printed, Spark will collect some of the records and display them for you. In this particular case, that dataset contains only a few rows describing automobile models and some of their specifications like Horsepower and expected Miles per Gallon. 2.4.1 Web Interface Most of the Spark commands are executed from the R console; however, monitoring and analyzing execution is done through Spark’s web interface, see Figure 2.1. This interface is a web application provided by Spark which can be accessed by running: spark_web(sc) FIGURE 2.1: Apache Spark Web Interface Printing the cars dataset collected a few records to be displayed in the R console. You can see in the Spark web interface that a job was started to collect this information back from Spark. You can also select the storage tab to see the “mtcars” dataset cached in-memory in Spark, Figure 2.2. FIGURE 2.2: Apache Spark Web Interface - Storage Tab Notice that this dataset is fully loaded into memory since the fraction cached is 100%, you can know exactly how much memory this dataset is using through the size in memory column. The executors tab, Figure 2.3, provides a view of your cluster resources. For local connections, you will find only one executor active with only 2GB of memory allocated to Spark and 384MB available for computation. In the Tuning chapter you will learn how request more compute instances, resources and learn how memory is allocated. FIGURE 2.3: Apache Spark Web Interface - Executors Tab The last tab to explore is the environment tab, Figure 2.4, this tab lists all the settings for this Spark application which the Tuning chapter will also introduce them in detail. As you will learn, most settings don’t need to be configured explicitly, but in order to properly run at scale, you will have to become familiar with some of them, eventually. FIGURE 2.4: Apache Spark Web Interface - Environment Tab Next, you will make use of a small subset of the practices that the Analysis chapter will cover. 2.4.2 Analysis When using Spark from R to analyze data, you can use SQL (Structured Query Language) or dplyr (a grammar of data manipulation). SQL can be used through the DBI package; for instance, to count how many records are available in our cars dataset we can run: library(DBI) dbGetQuery(sc, &quot;SELECT count(*) FROM mtcars&quot;) count(1) 1 32 When using dplyr, you write less code and it’s often much easier to write than SQL; which is why we won’t make use SQL in this book; however, if you are proficient in SQL, this is a viable option to you. For instance, counting records in dplyr is more compact and easier to understand. library(dplyr) count(cars) # Source: spark&lt;?&gt; [?? x 1] n &lt;dbl&gt; 1 32 In general, we usually start by analysing data in Spark with dplyr, followed by sampling rows and selecting a subset of the available columns. The last step is to collect data from Spark to perform further data processing in R, like data visualization. Let’s perform a very simple data analysis example by selecting, sampling and plotting the cars dataset in Spark: select(cars, hp, mpg) %&gt;% sample_n(100) %&gt;% collect() %&gt;% plot() FIGURE 2.5: Horsepower vs Miles per Gallon The plot in Figure 2.5, shows that as we increase the horsepower in a vehicle, the fuel efficiency measured in miles per gallon gets reduced. While this is insightful, it’s hard to predict numerically how increased horsepower would affect fuel efficiency. Modeling can help us overcome this. 2.4.3 Modeling While data analysis can take you quite far when understanding data, building a mathematical model that describes and generalizes the dataset is quite powerful. In the Introduction chapter you learned that the fields of machine learning and data science make use of mathematical models to perform predictions and find additional insights. For instance, we can use a linear model to approximate the relationship between fuel efficiency and horsepower: model &lt;- ml_linear_regression(cars, mpg ~ hp) model Formula: mpg ~ hp Coefficients: (Intercept) hp 30.09886054 -0.06822828 This model can now be used to predict values that are not in the original dataset. For instance, we can add entries for cars with horsepower beyond 250 and also visualize the predicted values as shown in Figure 2.6. model %&gt;% ml_predict(copy_to(sc, data.frame(hp = 250 + 10 * 1:10))) %&gt;% transmute(hp = hp, mpg = prediction) %&gt;% full_join(select(cars, hp, mpg)) %&gt;% collect() %&gt;% plot() FIGURE 2.6: Horsepower vs miles per gallon with predictions While the previous example lacks many of the appropriate techniques you should use while modeling, it’s also a simple example to briefly introduce the modeling capabilities of Spark. All the Spark models, techniques and best practices will be properly introduced in the Modeling chapter. 2.4.4 Data For simplicity, we copied the mtcars dataset into Spark; however, data is usually not copied into Spark. Instead, data is read from existing data sources in a variety of formats like plain text, CSV, JSON, JDBC and many more which, the Data chapter will introduce in detail. For instance, we can export our cars dataset as a CSV file: spark_write_csv(cars, &quot;cars.csv&quot;) In practice, we would read an existing dataset from a distributed storage system like HDFS, but we can also read back from the local file system: cars &lt;- spark_read_csv(sc, &quot;cars.csv&quot;) 2.4.5 Extensions In the same way that R is known for its vibrant community of package authors, at a smaller scale, many extensions for Spark and R have been written and are available to you. The Extensions chapter will introduce many interesting ones to perform advanced modeling, graph analysis, preprocess datasets for deep learning, etc. For instance, the sparkly.nested extension is an R package that extends sparklyr to help you manage values that contain nested information. A common use case arises when dealing with JSON files which contain nested lists that require preprocessing before doing meaningful data analysis. To use this extension, we have to first install it as follows: install.packages(&quot;sparklyr.nested&quot;) Then we can use this extension to group all the horsepower data points over the number of cylinders: sparklyr.nested::sdf_nest(cars, hp) %&gt;% group_by(cyl) %&gt;% summarise(data = collect_list(data)) # Source: spark&lt;?&gt; [?? x 2] cyl data &lt;int&gt; &lt;list&gt; 1 6 &lt;list [7]&gt; 2 4 &lt;list [11]&gt; 3 8 &lt;list [14]&gt; While nesting data makes it harder to read, it is a requirement when dealing with nested data formats like JSON using the spark_read_json() and spark_write_json() functions. 2.4.6 Distributed R For those few cases where a particular functionality is not available in Spark and no extension has been developed, you can consider distributing your own R code across the Spark cluster. This is a powerful tool but comes with additional complexity that you should only use as a last resort option. Suppose that we need to round all the values across all the columns in our dataset, one approach would be to run custom R code that makes use of R’s round() function: cars %&gt;% spark_apply(~round(.x)) # Source: spark&lt;?&gt; [?? x 11] mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 21 6 160 110 4 3 16 0 1 4 4 2 21 6 160 110 4 3 17 0 1 4 4 3 23 4 108 93 4 2 19 1 1 4 1 4 21 6 258 110 3 3 19 1 0 3 1 5 19 8 360 175 3 3 17 0 0 3 2 6 18 6 225 105 3 3 20 1 0 3 1 7 14 8 360 245 3 4 16 0 0 3 4 8 24 4 147 62 4 3 20 1 0 4 2 9 23 4 141 95 4 3 23 1 0 4 2 10 19 6 168 123 4 3 18 1 0 4 4 # … with more rows If you are a proficient R user, it can be quite tempting to use spark_apply() for everything, but please, don’t! spark_apply() was designed for advanced use cases where Spark falls short; instead, you will learn how to do proper data analysis and modeling without having to distribute custom R code across your cluster. 2.4.7 Streaming While processing large static datasets is the most typical use case for Spark, processing dynamic datasets in real-time is also possible and for some applications, a requirement. You can think of a streaming dataset as a static data source with new data arriving continuously, like stock market quotes. Streaming data is usually read from Kafka (an open-source stream-processing software platform) or from distributed storage that receives new data continuously. To try out streaming, lets first create an input/ folder with some data that we will use as the input for this stream: dir.create(&quot;input&quot;) write.csv(mtcars, &quot;input/cars_1.csv&quot;, row.names = F) Then we will define a stream that processes incoming data from the input/ folder, performs a custom transformation in R and, pushes the output into an output/ folder stream &lt;- stream_read_csv(sc, &quot;input/&quot;) %&gt;% select(mpg, cyl, disp) %&gt;% stream_write_csv(&quot;output/&quot;) As soon as the stream of real-time data starts, the input/ folder is processed and turned into a set of new files under the output/ folder containing the new transformed files. Since the input contained only one file, the output folder will also contain a single file resulting from applying the custom spark_apply() transformation. dir(&quot;output&quot;, pattern = &quot;.csv&quot;) [1] &quot;part-00000-eece04d8-7cfa-4231-b61e-f1aef8edeb97-c000.csv&quot; Up to this point, this resembles static data processing; however, we can keep adding files to the input/ location and Spark will parallelize and process data automatically. Let’s add one more file and validate that it’s automatically processed. # Write more data into the stream source write.csv(mtcars, &quot;input/cars_2.csv&quot;, row.names = F) Wait a few seconds and validate that the data gets processed by the Spark stream, # Check the contents of the stream destination dir(&quot;output&quot;, pattern = &quot;.csv&quot;) [1] &quot;part-00000-2d8e5c07-a2eb-449d-a535-8a19c671477d-c000.csv&quot; [2] &quot;part-00000-eece04d8-7cfa-4231-b61e-f1aef8edeb97-c000.csv&quot; You should then stop the stream, stream_stop(stream) You can use dplyr, SQL, Spark models or distributed R to analyze streams in real-time, we will properly introduce you to all the interesting transformations you can perform to analyze real-time data during the Streaming chapter. 2.4.8 Logs Logging is definitely less interesting than real-time data processing; however, it’s a tool you should be familiar with. A log is just a text file where Spark will append information relevant to the execution of tasks in the cluster. For local clusters, we can retrieve all the recent logs by running: spark_log(sc) 18/10/09 19:41:46 INFO Executor: Finished task 0.0 in stage 5.0 (TID 5)... 18/10/09 19:41:46 INFO TaskSetManager: Finished task 0.0 in stage 5.0... 18/10/09 19:41:46 INFO TaskSchedulerImpl: Removed TaskSet 5.0, whose... 18/10/09 19:41:46 INFO DAGScheduler: ResultStage 5 (collect at utils... 18/10/09 19:41:46 INFO DAGScheduler: Job 3 finished: collect at utils... Or we can retrieve specific log entries containing, say sparklyr, by using the filter parameter as follows: spark_log(sc, filter = &quot;sparklyr&quot;) ## 18/10/09 18:53:23 INFO SparkContext: Submitted application: sparklyr ## 18/10/09 18:53:23 INFO SparkContext: Added JAR... ## 18/10/09 18:53:27 INFO Executor: Fetching spark://localhost:52930/... ## 18/10/09 18:53:27 INFO Utils: Fetching spark://localhost:52930/... ## 18/10/09 18:53:27 INFO Executor: Adding file:/private/var/folders/... Most of the time, you won’t need to worry about Spark logs, except in cases where you need to troubleshoot a failed computation; in those cases, logs are an invaluable resource to be aware of, now you know. 2.5 Disconnecting For local clusters (really, any cluster) once you are done processing data you should disconnect by running: spark_disconnect(sc) This will terminate the connection to the cluster as well as the cluster tasks. If multiple Spark connections are active, or if the connection instance sc is no longer available, you can also disconnect all your Spark connections by running: spark_disconnect_all() Notice that exiting R, RStudio or restarting your R session will also cause the Spark connection to terminate, which in turn terminates the Spark cluster and cached data that is not explicitly persisted. 2.6 Using RStudio Since it’s very common to use RStudio with R, sparklyr provides RStudio extensions to help simplify your workflows and increase your productivity while using Spark in RStudio. If you are not familiar with RStudio, take a quick look at the Using RStudio appendix section. Otherwise, there are a couple extensions worth highlighting. First, instead of starting a new connection using spark_connect() from RStudio’s R console, you can use the new connection action from the connections pane and then, select the Spark connection which will open the dialog shown in Figure 2.7. You can then customize the versions and connect to Spark which will generate the correct spark_connect() command and execute this in the R console for you. FIGURE 2.7: RStudio New Spark Connection Second, once connected to Spark, either by using the R console or through RStudio’s connections pane, RStudio will display your datasets available in the connections pane, see Figure 2.8. This is a useful way to track your existing datasets and provides an easy way to explore each of them. FIGURE 2.8: RStudio Connections Pane Additionally, an active connection provides the following custom actions: Spark Opens the Spark web interface, a shortcut to spark_ui(sc). Log Opens the Spark web logs, a shortcut to spark_log(sc). SQL Opens a new SQL query, see DBI and SQL support in the data Analysis chapter. Help Opens the reference documentation in a new web browser window. Disconnect Disconnects from Spark, a shortcut to spark_disconnect(sc). The rest of this book will use plain R code, it is up to you to execute this code in the R console, RStudio, Jupyter Notebooks or any other tool that support executing R code since the code provided in this book executes in any R environment. 2.7 Resources While we’ve put significant effort into simplifying the onboarding process, there are many additional resources that can help you troubleshoot particular issues while getting started and, in general, introduce you to the broader Spark and R communities to help you get specific answers, discuss topics and get connected with many users actively using Spark with R. Documentation: The documentation site hosted in the RStudio’s Spark website should be your first stop to learn more about Spark when using R. The documentation is kept up to date with examples, reference functions and many more relevant resources. Blog: To keep up to date with major sparklyr announcements, you can follow the RStudio blog. Community: For general sparklyr questions, you can post then in the RStudio Community tagged as sparklyr. Stack Overflow: For general Spark questions, Stack Overflow is a great resource; there are also many topics specifically about sparklyr. Github: If you believe something needs to be fixed, open a GitHub issue or send us a pull request. Gitter: For urgent issues, or to keep in touch, you can chat with us in Gitter. 2.8 Recap In this chapter you learned about the prerequisites required to work with Spark, how to connect to Spark using spark_connect(), install a local cluster using spark_install(), load a simple dataset, launch the web interface and display logs using spark_web(sc) and spark_log(sc) respectively, disconnect from RStudio using spark_disconnect() and we closed this chapter presenting the RStudio extensions sparklyr provides. At this point, we hope that you feel ready to tackle actual data analysis and modeling problems in Spark and R, which will be introduced over the next two chapters. The next chapter, Analysis, will present data analysis as the process of inspecting, cleaning, and transforming data with the goal of discovering useful information. Modeling can be considered part of data analysis; however, it deserves it’s own chapter to truly understand and take advantage of the modeling functionality available in Spark. References "],
["analysis.html", "Chapter 3 Analysis 3.1 Overview 3.2 Import 3.3 Wrangle 3.4 Visualize 3.5 Model 3.6 Communicate 3.7 Recap", " Chapter 3 Analysis “First lesson, stick them with the pointy end.” — Jon Snow Previous chapters focused on introducing Spark with R, they got you up to speed and encouraged you to try basic data analysis workflows. However, they have not properly introduced what such data analysis means, especially while running in Spark. They presented the tools you need throughout this book, to help you spend more time learning and less time troubleshooting. This chapter will introduce tools and concepts to perform data analysis in Spark from R; which, spoiler alert, are the same tools you use when using plain R! This is not an accidental coincidence; but rather, we want data scientist to live in a world where technology is hidden from them, where you can use the R packages you know and love, and where they simply happen to just work in Spark! Now, we are not quite there yet, but we are also not that far. In this chapter you will learn widely used R packages and practices to pereform data analysis like: dplyr, ggplot2, formulas, rmarkdown and so on – which also happen to work in Spark! The next chapter, Modeling, will focus on creating statistical models to predict, estimate and describe datasets; but first, let’s get started with analysis! 3.1 Overview In a data analysis project, the main goal is to understand what the data is trying to “tell us”, hoping that it provides an answer to a specific question. Most data analysis projects follow a set of steps outlined in Figure 3.1. FIGURE 3.1: General steps of a data analysis As the diagram illustrates, we first import data into our analysis stem, then wrangle by trying different data transformations, such as aggregations, and then visualize to help us perceive relationships and trends. In order to get deeper insight, one or multiple statistical models can be fitted against sample data. This will help in finding out if the patterns hold true when new data is applied to them. Lastly, the results are communicated publicly or privately to colleagues and stakeholders. When working with not-large-scale datasets, as in datasets that fit in memory; we can perform all those steps from R, without using Spark. However, when data does not fit in memory or computation is simply too-slow, we can slightly modify this approach by incorporating Spark, but how? For data analysis, the ideal approach is to let Spark do what its good at. Spark is a parallel computation engine that works at a large-scale and provides a SQL engine and modeling libraries. These can be used to perform most of the same operations R performs. Such operations include data selection, transformation, and modeling. Additionally, Spark includes tools for performing specialized computational work like graph analysis, stream processing, and many others. For now, we will skip those non-rectangular datasets and present them in later chapters. Data import, wrangling, and modeling can be performed inside Spark. Visualization can also partly be done by Spark, and we will cover that later in this chapter. The relationship between Spark, R, and your data is an important concept to grasp. The goal is to use R to tell Spark what data operations to run. The only data that should come through R directly are the final results of those Spark operations. As illustrated in Figure 3.2, the ideal method is to push compute to the Spark cluster, and then collect results into R. FIGURE 3.2: Spark computes while R collects results The sparklyr package aids in using the “push compute, collect results” principle. Most of its functions are wrappers on top of Spark API calls. This allows us to take advantage of Spark’s analysis components, instead of R’s. For example, when you need to fit a linear regression model; instead of using R’s familiar lm() function, you would use Spark’s ml_linear_regression(). This R function then calls Spark to create this model, this specific example is illustrated in Figure 3.3. FIGURE 3.3: R functions call Spark functionality For more common data manipulation tasks, sparklyr provides a back-end for dplyr. This means that already familiar dplyr verbs can be used in R, and then sparklyr and dplyr will translate those actions into Spark SQL statements, which are generally more compact and easier to read than SQL statements. So, if you are already familiar with R and dplyr, there is nothing new to learn! This might feel a bit anticlimactic, it is indeed, but it’s also great since you can focus that energy on learning other skills required to do large-scale computing. FIGURE 3.4: dplyr writes SQL In order to practice as you learn, the rest of this chapter’s code will use a single exercise that runs in the local Spark master. This way, the code can be replicated in your personal computer. Please, make sure to already have sparklyr working, this should already be the case if you completed the Getting Started chapter. This chapter will make use of packages that you might not have installed; so first, make sure the following packages are installed by running: install.packages(&quot;ggplot2&quot;) install.packages(&quot;corrr&quot;) install.packages(&quot;dbplot&quot;) install.packages(&quot;rmarkdown&quot;) First, load the sparklyr and dplyr packages, and open a new local connection. library(sparklyr) library(dplyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) The environment is ready to be used, so our next task is to import data that we can later analyze. 3.2 Import Importing data is to be approached differently when using Spark with R. Usually, importing means that R will read files and load them into memory; when using Spark, the data is imported into Spark, not R. Notice how in Figure 3.5 the data source is connected to Spark instead of being connected to R. FIGURE 3.5: Import Data to Spark not R Note: When you are doing analysis over large-scale datasets, the vast majority of the necessary data will be already available in your Spark cluster (which is usually made available to users via Hive tables, or by accessing the file system directly), the Data chapter will cover this extensively. Rather than importing all data into Spark, you can request Spark to access the data source without importing it – this is a decision you should make based on speed and performance. Importing all of the data into the Spark session will incur a up-front cost, once; since Spark needs to wait for the data to be loaded before analyzing it. If the data is not imported, you usually incur a cost with every Spark operation since Spark needs to retrieve a subset from the cluster’s storage, which is usually disk drives that happen to be much slower than reading from Spark’s memory. More will be covered in the Tuning chapter. Let’s prime the session with some data by importing mtcars into Spark using copy_to(); you can also import data from distributed files in many different file formats, which you’ll learn in the Data chapter. cars &lt;- copy_to(sc, mtcars) Note: In an enterprise setting, copy_to() should only be used to transfer small tables from R, large data transfers should be performed with specialized data transfer tools. The data is now accessible to Spark and transformations can now be applied with ease; the next section will cover how to wrangle data by running transformations inside Spark, using dplyr. 3.3 Wrangle Data wrangling uses transformations to understand the data, it is often referred to as the process of transforming data from one “raw” data form into another format with the intent of making it more appropriate for data analysis. Malformed or missing values and columns with multiple attributes are common data problems you might need to fix, since they prevent you from understanding your dataset. For example, a “name” field contains the last and first name of a customer. There are two attributes (first and last name) in a single column. In order to be usable, we need to transform the “name” field, by changing it into “first_name” and “last_name” fields. After the data is cleaned, you still need to understand the basics about its content. Other transformations, such as aggregations, can help with this task. For example, the result of requesting the average balance of all customers will return a single row and column. The value will be the average of all customers. That information will give us context when we see individual, or grouped, customer balances. The main goal is to write the data transformations using R syntax as much as possible. This saves us from the cognitive cost of having to switch between multiple computer technologies to accomplish a single task. In this case, it is better to take advantage of dplyr, instead of writing Spark SQL statements for data exploration. In the R environment, cars can be treated as if it is a local data frame, so dplyr verbs can be used. For instance, we can find out the mean of all columns as with summarise_all(): summarize_all(cars, mean) # Source: spark&lt;?&gt; [?? x 11] mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 20.1 6.19 231. 147. 3.60 3.22 17.8 0.438 0.406 3.69 2.81 While this code is exactly the same as the code you would run when using dplyr without Spark, a lot is happening under the hood! The data is NOT being imported into R; instead,dplyr converts this task into SQL statements that are then sent to Spark. The show_query() command makes it possible to peer into the SQL statement that sparklyr and dplyr created and sent to Spark. We can also use this time to introduce the pipe (%&gt;%) operator, a custom operator from the magrittr package that takes pipes a computation into the first argument of the next function, making your data analysis much easier to read. summarize_all(cars, mean) %&gt;% show_query() &lt;SQL&gt; SELECT AVG(`mpg`) AS `mpg`, AVG(`cyl`) AS `cyl`, AVG(`disp`) AS `disp`, AVG(`hp`) AS `hp`, AVG(`drat`) AS `drat`, AVG(`wt`) AS `wt`, AVG(`qsec`) AS `qsec`, AVG(`vs`) AS `vs`, AVG(`am`) AS `am`, AVG(`gear`) AS `gear`, AVG(`carb`) AS `carb` FROM `mtcars` As it is evident, dplyr is much more concise than SQL; but rest assured, you will not have to see nor understand SQL when using dplyr. Your focus can remain on obtaining insights from the data, as opposed to figuring out how to express a given set of transformations in SQL. Here is another example that groups the cars dataset by “transmission” type. cars %&gt;% mutate(transmission = ifelse(am == 0, &quot;automatic&quot;, &quot;manual&quot;)) %&gt;% group_by(transmission) %&gt;% summarise_all(mean) # Source: spark&lt;?&gt; [?? x 12] transmission mpg cyl disp hp drat wt qsec vs am gear carb &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 automatic 17.1 6.95 290. 160. 3.29 3.77 18.2 0.368 0 3.21 2.74 2 manmual 24.4 5.08 144. 127. 4.05 2.41 17.4 0.538 1 4.38 2.92 Most of the data transformation operations made available by dplyr to work with local data frames are also available to use with a Spark connection. This means that you can focus on learning dplyr first, and then reuse that skill when working with Spark. The Data Transformation chapter from the “R for Data Science” (Wickham and Grolemund 2016) book is a great resource to learn dplyr in-depth. If proficiency with dplyr is not an issue for you, then please take some time to experiment with different dplyr functions against the cars table. Sometimes we may need to perform an operation not yet available through dplyr and sparklyr. Instead of downloading the data into R, there is usually a Hive function within Spark to accomplish what we need. The next section will cover this scenario. 3.3.1 Built-in Functions Spark SQL is based on Hive’s SQL conventions and functions and it is possible to call all these functions using dplyr as well. This means that we can use any Spark SQL functions to accomplish operations that may not be available via dplyr. The functions can be accessed by calling them as if they were R functions. Instead of failing, dplyr passes functions it does not recognize “as-is” to the query engine. This gives us a lot of flexibility on the function we can use! For instance, the percentile function returns the exact percentile of a column in a group. The function expects a column name, and either a single percentile value, or an array of multiple percentile values. We can use this Spark SQL function from dplyr as follows: summarise(cars, mpg_percentile = percentile(mpg, 0.25)) # Source: spark&lt;?&gt; [?? x 1] mpg_percentile &lt;dbl&gt; 1 15.4 There is no percentile() function in R, so dplyr passes the that portion of the code, “as-is”, to the resulting SQL query. summarise(cars, mpg_percentile = percentile(mpg, 0.25)) %&gt;% show_query() &lt;SQL&gt; SELECT percentile(`mpg`, 0.25) AS `mpg_percentile` FROM `mtcars_remote` To pass multiple values to percentile, we can call another Hive function called array. In this case, array would work similarly to R’s list() function. We can pass multiple values separated by commas. The output from Spark is an array variable, which is imported into R as a list variable column. summarise(cars, mpg_percentile = percentile(mpg, array(0.25, 0.5, 0.75))) # Source: spark&lt;?&gt; [?? x 1] mpg_percentile &lt;list&gt; 1 &lt;list [3]&gt; The explode function can be used to separate the Spark’s array value results into their own record. To do this, use explode within a mutate() command, and pass the variable containing the results of the percentile operation. summarise(cars, mpg_percentile = percentile(mpg, array(0.25, 0.5, 0.75))) %&gt;% mutate(mpg_percentile = explode(mpg_percentile)) # Source: spark&lt;?&gt; [?? x 1] mpg_percentile &lt;dbl&gt; 1 15.4 2 19.2 3 22.8 We have included a comprehensive list of all the Hive functions in the Appendix under Hive functions, make sure you glance over them to get a sense of the wide range of operations you can accomplish with them. 3.3.2 Correlations A very common exploration technique is to calculate and visualize correlations, which we often calculate to find out what kind of statistical relationship exists between paired sets of variables. Spark provides functions to calculate correlations across the entire data set and returns the results to R as a data frame object. ml_corr(cars) # A tibble: 11 x 11 mpg cyl disp hp drat wt qsec &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 -0.852 -0.848 -0.776 0.681 -0.868 0.419 2 -0.852 1 0.902 0.832 -0.700 0.782 -0.591 3 -0.848 0.902 1 0.791 -0.710 0.888 -0.434 4 -0.776 0.832 0.791 1 -0.449 0.659 -0.708 5 0.681 -0.700 -0.710 -0.449 1 -0.712 0.0912 6 -0.868 0.782 0.888 0.659 -0.712 1 -0.175 7 0.419 -0.591 -0.434 -0.708 0.0912 -0.175 1 8 0.664 -0.811 -0.710 -0.723 0.440 -0.555 0.745 9 0.600 -0.523 -0.591 -0.243 0.713 -0.692 -0.230 10 0.480 -0.493 -0.556 -0.126 0.700 -0.583 -0.213 11 -0.551 0.527 0.395 0.750 -0.0908 0.428 -0.656 # ... with 4 more variables: vs &lt;dbl&gt;, am &lt;dbl&gt;, # gear &lt;dbl&gt;, carb &lt;dbl&gt; The corrr R package specializes in correlations. It contains friendly functions to prepare and visualize the results. Included inside the package is a back-end for Spark, so when a Spark object is used in corrr the actual computation also happens in Spark. In the background, the correlate() function runs sparklyr::ml_corr(), so there is no need to collect any data into R prior running the command. library(corrr) correlate(cars, use = &quot;pairwise.complete.obs&quot;, method = &quot;pearson&quot;) # A tibble: 11 x 12 rowname mpg cyl disp hp drat wt &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 mpg NA -0.852 -0.848 -0.776 0.681 -0.868 2 cyl -0.852 NA 0.902 0.832 -0.700 0.782 3 disp -0.848 0.902 NA 0.791 -0.710 0.888 4 hp -0.776 0.832 0.791 NA -0.449 0.659 5 drat 0.681 -0.700 -0.710 -0.449 NA -0.712 6 wt -0.868 0.782 0.888 0.659 -0.712 NA 7 qsec 0.419 -0.591 -0.434 -0.708 0.0912 -0.175 8 vs 0.664 -0.811 -0.710 -0.723 0.440 -0.555 9 am 0.600 -0.523 -0.591 -0.243 0.713 -0.692 10 gear 0.480 -0.493 -0.556 -0.126 0.700 -0.583 11 carb -0.551 0.527 0.395 0.750 -0.0908 0.428 # ... with 5 more variables: qsec &lt;dbl&gt;, vs &lt;dbl&gt;, # am &lt;dbl&gt;, gear &lt;dbl&gt;, carb &lt;dbl&gt; We can pipe the results to other corrr functions. For example, the shave() functions turns all of the duplicated results into NA’s. Again, while this feels like standard R code using existing R packages, Spark is being used under the hood to perform the correlation! Additionally, as shown in Figure 3.6, the results can be easily visualized using the rplot() function. correlate(cars, use = &quot;pairwise.complete.obs&quot;, method = &quot;pearson&quot;) %&gt;% shave() %&gt;% rplot() FIGURE 3.6: Using rplot() to visualize correlations It is much easier to see which relationships are positive or negative. Positive relationships are in grey, and negative relationships are black. The size of the circle indicates how significant their relationship is. The power of visualizing data is in how much easier it makes it for us to understand results. The next section will expand on this step of the process. 3.4 Visualize Visualizations are a vital tool to help us find patterns in the data. It is easier for us to identify outliers in a data set of 1,000 observations when plotted in a graph, as opposed to reading them from a list. R is great at data visualizations. Its capabilities for creating plots are extended by the many R packages that focus on this analysis step. Unfortunately, the vast majority of R functions that create plots depend on the data already being in local memory within R, so they fail when using a remote table inside Spark. It is possible to create visualizations in R from data sources that exist in Spark. To understand how to do this, let’s first break down how computer programs build plots: It takes the raw data and performs some sort of transformation. The transformed data is then mapped to a set of coordinates. Finally, the mapped values are drawn in a plot. Figure 3.7 summarizes each of the steps. FIGURE 3.7: Stages of an R plot In essence, the approach for visualizing is the same as in wrangling, push the computation to Spark, then collect the results in R for plotting. As illustrated in Figure 3.8, the heavy lifting of preparing the data, such as aggregating the data by groups or bins, can be done inside Spark, then collected as a much smaller data set into R. Inside R, the plot becomes a more basic operation. For example, to plot a histogram, bins are first calculated in Spark. Once the result is collected to R, we can use a simple column plot, as opposed to a histogram plot, because there is no need for R to re-calculate the bins. FIGURE 3.8: Plotting with Spark and R Using this conceptual model, let’s apply this when using ggplot2. 3.4.1 Using ggplot2 To create a bar plot using ggplot2, we simply call a function: library(ggplot2) ## Warning: package &#39;ggplot2&#39; was built under R version 3.5.2 ggplot(aes(as.factor(cyl), mpg), data = mtcars) + geom_col() FIGURE 3.9: Plotting inside R In this case, the mtcars raw data was automatically transformed into three discrete aggregated numbers, then each result was mapped into an x and y plane, and then the plot was drawn. As R users, all of the stages of building the plot are conveniently abstracted for us. In Spark, there are a couple of key steps when codifying the “push compute, collect results” approach. First, ensure that the transformation operations happen inside Spark. In the example below, group_by() and summarise() will run inside Spark. Second, bring the results back into R after the data has been transformed. Make sure to transform and then collect, in that order; if collect() is run first, then R will try to ingest the entire data set from Spark. Depending on the size of the data, collecting all of the data will slow down or may even bring down your system. car_group &lt;- cars %&gt;% group_by(cyl) %&gt;% summarise(mpg = sum(mpg, na.rm = TRUE)) %&gt;% collect() %&gt;% print() # A tibble: 3 x 2 cyl mpg &lt;dbl&gt; &lt;dbl&gt; 1 6 138. 2 4 293. 3 8 211. In this example, now that the data has been pre-aggregated and collected into R, only three records are passed to the plotting function. Figure 3.10 shows the resulting plot. ggplot(aes(as.factor(cyl), mpg), data = car_group) + geom_col(fill = &quot;#999999&quot;) + coord_flip() FIGURE 3.10: Plot with aggregation in Spark Any other ggplot2 visualization can be made to work using this approach; however, it is beyond the scope of the book to teach this. Instead, we recommend you use “R graphics cookbook: practical recipes for visualizing data” (Chang 2012) to learn additional visualization techniques applicable to Spark. Now, to ease this transformation step before visualizing, the dbplot package provides a few ready-to-use visualizations that automate aggregation in Spark. 3.4.2 Using dbplot The dbplot package provides helper functions for plotting with remote data. The R code dbplot uses to transform the data is written so that it can be translated into Spark. It then uses those results to create a graph using the ggplot2 package where data transformation and plotting are both triggered by a single function. The dbplot_histogram() function makes Spark calculate the bins and the count per bin and outputs a ggplot object which can be further refined by adding more steps to the plot object. dbplot_histogram() also accepts a binwidth argument to control the range used to compute the bins. The resulting plot is in Figure 3.11. library(dbplot) cars %&gt;% dbplot_histogram(mpg, binwidth = 3) + labs(title = &quot;MPG Distribution&quot;, subtitle = &quot;Histogram over miles per gallon&quot;) FIGURE 3.11: Histogram created by dbplot Histograms provide a great way to analyze a single variable. To analyze two variables, a scatter or raster plot is commonly used. Scatter plots are used to compare the relationship between two continuous variables. For example, a scatter plot will display the relationship between the weight of a car and its gas consumption. The plot will show that the higher the weight, the higher the gas consumption because the dots clump together into almost a line that goes from the top left towards the bottom right. See Figure 3.12 for an example of the plot. ggplot(aes(mpg, wt), data = mtcars) + geom_point() FIGURE 3.12: Scatter plot example in Spark However, for scatter plots, no amount of “pushing the computation” to Spark will help with this problem because the data has to be plotted in individual dots. The best alternative is to find a plot type that represents the x/y relationship and concentration in a way that it is easy to perceive and to “physically” plot. The raster plot may be the best answer. It returns a grid of x/y positions and the results of a given aggregation usually represented by the color of the square. You can use dbplot_raster() to create a scatter-like plot in Spark, while only retrieving (collecting) a small subset of the remote dataset: dbplot_raster(cars, mpg, wt, resolution = 16) FIGURE 3.13: A raster plot using Spark As shown in Figure 3.13, the plot returns a grid no bigger than 5x5. This limits the number of records that need to be collected into R to 25. Tip: You can also use dbplot to retrieve the raw data and visualize by other means; to retrieve the aggregates but not the plots, use: db_compute_bins(), db_compute_count(), db_compute_raster() and db_compute_boxplot(). While visualizations are indispensable, you can complement data analysis using statistical models to gain even deeper insights into our data. The next section will present how we can prepare data for modeling with Spark. 3.5 Model The next two chapters will focus entirely on modeling, so rather than introducing modeling with too much detail in this chapter, we want to present how to interact with models while doing data analysis. First, an analysis project goes through as many transformations and models to find the answer. That’s why the first data analysis diagram we introduced in Figure 3.2, illustrates a cycle between: visualizing, wrangling and modeling – we know you don’t end with modeling, not in R and neither when using Spark. Therefore, the ideal data analysis language enables you to quickly adjust over each wrangle-visualize-model iteration. Fortunately, this is the case when using Spark and R. To illustrate how easy it is to iterate over wrangling and modeling in Spark, consider the following example. We will start by performing a linear regression against all features and predict MPG: cars %&gt;% ml_linear_regression(mpg ~ .) %&gt;% summary() Deviance Residuals: Min 1Q Median 3Q Max -3.4506 -1.6044 -0.1196 1.2193 4.6271 Coefficients: (Intercept) cyl disp hp drat wt 12.30337416 -0.11144048 0.01333524 -0.02148212 0.78711097 -3.71530393 qsec vs am gear carb 0.82104075 0.31776281 2.52022689 0.65541302 -0.19941925 R-Squared: 0.869 Root Mean Squared Error: 2.147 At this point it is very easy to experiment with different features, we can simply change the R formula from mpg ~ . to say mpg ~ hp + cyl to only use HP and cylinders as features: cars %&gt;% ml_linear_regression(mpg ~ hp + cyl) %&gt;% summary() Deviance Residuals: Min 1Q Median 3Q Max -4.4948 -2.4901 -0.1828 1.9777 7.2934 Coefficients: (Intercept) hp cyl 36.9083305 -0.0191217 -2.2646936 R-Squared: 0.7407 Root Mean Squared Error: 3.021 Additionally, it is also very easy to iterate with other kinds of models. The following one replaces the linear model with a generalized linear model: cars %&gt;% ml_generalized_linear_regression(mpg ~ hp + cyl) %&gt;% summary() Deviance Residuals: Min 1Q Median 3Q Max -4.4948 -2.4901 -0.1828 1.9777 7.2934 Coefficients: (Intercept) hp cyl 36.9083305 -0.0191217 -2.2646936 (Dispersion parameter for gaussian family taken to be 10.06809) Null deviance: 1126.05 on 31 degress of freedom Residual deviance: 291.975 on 29 degrees of freedom AIC: 169.56 Usually, before fitting a model you would have to use multiple dplyr transformations to get it ready to be consumed by a model. To make sure the model can be fitted as efficiently as possible, you should cache your dataset before fitting it. 3.5.1 Caching The examples in this chapter are built using a very small data set. In real-life scenarios, large amounts of data are used for models. If the data needs to be transformed first, the volume of the data could exact a heavy toll on the Spark session. Before fitting the models, it is a good idea to save the results of all the transformations in a new table inside Spark memory. The compute() command can take the end of a dplyr piped command set and save the results to Spark memory. cached_cars &lt;- cars %&gt;% mutate(cyl = paste0(&quot;cyl_&quot;, cyl)) %&gt;% compute(&quot;cached_cars&quot;) cached_cars %&gt;% ml_linear_regression(mpg ~ .) %&gt;% summary() Deviance Residuals: Min 1Q Median 3Q Max -3.47339 -1.37936 -0.06554 1.05105 4.39057 Coefficients: (Intercept) cyl_cyl_8.0 cyl_cyl_4.0 disp hp drat 16.15953652 3.29774653 1.66030673 0.01391241 -0.04612835 0.02635025 wt qsec vs am gear carb -3.80624757 0.64695710 1.74738689 2.61726546 0.76402917 0.50935118 R-Squared: 0.8816 Root Mean Squared Error: 2.041 As more insights are gained from the data, more questions may be raised. That is why we expect to iterate through data wrangle, visualize, and model multiple times. Each iteration should provide incremental insights of what the data is “telling us”. There will be a point where we reach a satisfactory level of understanding. It is at this point that we will be ready to share the results of the analysis, this is the topic of the next section. 3.6 Communicate It is important to clearly communicate the analysis results – as important as the analysis work itself! The public, colleagues or stakeholders need to understand what you found out and how. To communicate effectively we need to use artifacts, such as reports and presentations; these are common output formats that we can create in R, using R Markdown. R Markdown documents allow us to weave narrative text and code together. Once created, R Markdown documents can be turned into a variety of output formats such as HTML, PDF, PowerPoint, Word, web slides, Websites, books and so on. Most of these outputs are available in the core R packages of R Markdown: knitr and rmarkdown. R Markdown can be extended by other R packages. For example, this book was written using R Markdown thanks to an extension provided by the bookdown package. The best resource to delve deeper into R Markdown is the official book. (Xie 2018) In R Markdown, one singular artifact could potentially be rendered into many different formats. For example, the same report could be rendered in HTML, or as a PDF file by changing a setting within the report itself. Conversely, multiple types of artifacts could be rendered as the same output. For example, a presentation deck and a report could be rendered in HTML. Creating a new R Markdown report which uses Spark as a compute engine is easy! At the top, R Markdown expects a YAML header. The first and last line are three consecutive dashes (---). The content in between the dashes will vary depending on the type of document. The only required attribute is the output value. R Markdown needs to know what kind of output it needs to render your report into. This YAML header is called Front Matter. Following the Front Matter are sections of code, called code chunks. These code chunks can be interlaced with the plain text narratives. There is nothing particularly interesting to note when using Spark with R Markdown, except that it is just business as usual. Since an R Markdown document is self-contained and meant to be reproducible, before rendering documents we should first disconnect from Spark to free resources: spark_disconnect(sc) The following example shows how easy it is to create a fully reproducible report that uses Spark to process large-scale datasets. The narrative, code and, most importantly, the output of the code is recorded inside the resulting HTML file. You can copy and paste the following code into a file. --- title: &quot;mtcars analysis&quot; output: html_document: fig_width: 6 fig_height: 3 --- ```{r, setup, include = FALSE} library(sparklyr) library(dplyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) cars &lt;- copy_to(sc, mtcars) ``` ## Visualize Aggregate data in Spark, visualize in R. ```{r fig.align=&#39;center&#39;, warning=FALSE} library(ggplot2) cars %&gt;% group_by(cyl) %&gt;% summarise(mpg = mean(mpg)) %&gt;% ggplot(aes(cyl, mpg)) + geom_bar(stat=&quot;identity&quot;) ``` ## Model The selected model was a simple linear regression that uses the weight as the predictor of MPG ```{r} cars %&gt;% ml_linear_regression(wt ~ mpg) %&gt;% summary() ``` ```{r, include = FALSE} spark_disconnect(sc) ``` To knit this report, save the file with a .Rmd extension such as: report.Rmd, and run render() from R. The output should look like the one in Figure 3.14. rmarkdown::render(&quot;report.Rmd&quot;) FIGURE 3.14: R Markdown HTML output This report can now be easily shared. Viewers of this report won’t need Spark or R to read and consume its contents; it’s just a self-contained HTML file, trivial to open in any browser. It is also common to distill insights of a report into many other output formats. Switching is quite easy, in the top Front Matter, change the output option to powerpoint_presentation, pdf_document, word_document, etc. You can even produce multiple output formats from the same report: --- title: &quot;mtcars analysis&quot; output: word_document: default pdf_document: default powerpoint_presentation: default --- The result will be a PowerPoint presentation, a Word document and a PDF! All of the same information that was displayed in the original HTML report, computed in Spark and rendered in R. There will be a need to edit the PowerPoint template or the output of the code chunks. This minimal example shows how easy it is to go from one format to another. Of course, it will take some more editing on the R user’s side to make sure the slides contain only the pertinent information. The main point is to highlight that it does not require learning a different markup, or code conventions, to switch from one artifact to another. 3.7 Recap This chapter presented a solid introduction to data analysis with R and Spark. Many of the techniques presented looked quite similar to using just R and no Spark; which while anticlimactic, is the right design to help users already familiar with R, easily transition to Spark. For users unfamiliar with R, this chapter also served as a very brief introduction to some of the most popular (and useful!) packages available in R. It should now be quite obvious that together, R and Spark, are a powerful combination – a large-scale computing platform, along with an incredibly robust ecosystem of R packages, makes up for an ideal analysis platform. While doing analysis in Spark with R, remember to push computation to Spark, and focus on collecting results in R. This paradigm should set up a successful approach to data manipulation, visualization and communication through sharing your results in a variety of outputs. The next chapter, Modeling, will dive deeper into how to build statistical models in Spark using a much more interesting dataset, what’s more interesting than dating datasets? You will also learn many more techniques we did not even mention in the brief modeling section from this chapter. References "],
["modeling.html", "Chapter 4 Modeling 4.1 Overview 4.2 Exploratory Data Analysis 4.3 Feature Engineering 4.4 Supervised Learning 4.5 Unsupervised Learning 4.6 Recap", " Chapter 4 Modeling “I’ve trusted in your visions, in your prophecies for years.” — Stannis Baratheon In the previous chapter, Analysis, you learn how to scale up data analysis to large-datasets using Spark. In this chapter, we will detail the steps required to build prediction models in Spark. We’ll explore MLlib, the component of Spark that allows you to write high level code to perform predictive modeling on distributed data and use data wrangling in the context of feature engineering and exploratory data analysis. We will start this chapter by introducing modeling in the context of Spark and the dataset you will use throughout the chapter. We will then demonstrate a supervised learning workflow that includes exploratory data analysis, feature engineering, and model building. We will then move on to an unsupervised topic modeling example using unstructured text data. Keep in mind that our goal will be to show various techniques of executing data science tasks on large data, rather than conducting a rigorous and coherent analysis. There are also many other models available in Spark that won’t be covered in this chapter, but by the end of the chapter, you will have the right tools to experiment with additional ones on your own. While predicting datasets manually is often a reasonable approach, by manually we mean, someone imports a dataset into Spark and uses the fitted model to enrich or predict values; it does bring up the question – could we automate this process into systems that anyone can use? For instance, how can we build a system that automatically identifies an email as spam without having to manually analyze each email account? The next chapter presents the tools to automate data analysis and modeling with pipelines; but to get there, we need to first understand how to train models, “by-hand”. 4.1 Overview The R interface to Spark provides modeling algorithms that should be familiar to R users, and we’ll go into detail in the chapter. For instance, we’ve already used ml_linear_regression(cars, mpg ~ .), but we could run ml_logistic_regression(cars, am ~ .) just as easily. Take a moment to glance at the long list of MLlib Functions included in the Appendix of this book; a quick glance at this list shows that Spark supports: Decision Trees, Gradient-Boosted Trees, Accelerated Failure Time Survival Regression, Isotonic Regression, K-Means Clustering, Gaussian Mixture Clustering and so on! As you can see, Spark provides a wide range of algorithms and feature transformers, and we will touch on a representative portion of the functionality. A complete treatment of predictive modeling concepts is outside the scope of this book, so we recommend complementing with “R for Data Science” (Wickham and Grolemund 2016) and “Feature Engineering and Selection: A Practical Approach for Predictive Models” (Kuhn and Johnson 2019), from which we adopted (sometimes verbatim) for examples and visualizations in this chapter. Instead, this chapter focuses on predictive modeling, since Spark aims to enable machine learning, as opposed to statistical inference. Machine learning is often more concerned about forecasting the future rather than inferring the process by which our data is generated1 which is then used to create automated systems. Machine learning can be categorized into supervised learning (predictive modeling) and unsupervised learning. In supervised learning, we try to learn a function that will map from “X” to “Y”, from a dataset of “(x, y)” examples. In unsupervised learning, we just have “X” and not the “Y” labels, so instead we try to learn something about the structure of “X”. Some practical use cases for supervised learning include forecasting tomorrow’s weather, determining whether a credit card transaction is fraudulent, and coming up with a price for your car insurance policy. With unsupervised learning, examples include automated grouping of photos of individuals, segmenting customers based on their purchase history, and clustering of documents. The ML interface in sparklyr has been designed to minimize the cognitive effort for moving from a local, in-memory, native R workflow to the cluster, and back. While the Spark ecosystem is very rich, there is still a tremendous number of packages from CRAN, with some implementing functionality that you may require for a project. Also, you may want to leverage your skills and experience working in R to maintain productivity. What we learned in the Analysis section also applies here — it is important to keep track of where you are performing computations, and move between the cluster and your R session as appropriate. The examples in this chapter will utilize the OkCupid dataset (Kim and Escobedo-Land 2015), available at github.com/r-spark/okcupid. The dataset consists of user profile data from an online dating site, and contains a diverse set of features, including biographical characteristics such as gender and profession, and free text fields related to personal interests. There are about 60,000 profiles in the dataset, which fits comfortably into memory on a modern laptop and wouldn’t be considered “big data”, so you can easily follow along running Spark local mode. You can download this dataset as follows: download.file( &quot;https://github.com/r-spark/okcupid/raw/master/profiles.csv.zip&quot;, &quot;okcupid.zip&quot;) unzip(&quot;okcupid.zip&quot;, exdir = &quot;data&quot;) unlink(&quot;okcupid.zip&quot;) We don’t recommend sampling this dataset since the model won’t be nearly as rich; however, if you have limited hardware resources, you are welcome to sample this dataset as follows: profiles &lt;- read.csv(&quot;data/profiles.csv&quot;) write.csv(dplyr::sample_n(profiles, 10^3), &quot;data/profiles.csv&quot;, row.names = FALSE) Note: The examples in this chapter utilize small datasets so readers can easily follow along in local mode. In practice, if your dataset fits comfortably in memory on your local machine, you may be better off using an efficient non-distributed implementation of the modeling algorithm. For example, you may want to use the ranger package instead of ml_random_forest_classifier(). In addition, to follow along, you will need to install a few additional packages: install.packages(&quot;ggmosaic&quot;) install.packages(&quot;forcats&quot;) install.packages(&quot;FactoMineR&quot;) To motivate the examples, we will consider the following problem: Predict whether someone is actively working, i.e. not retired, a student, or unemployed. Next up, we will explore this dataset. 4.2 Exploratory Data Analysis Exploratory data analysis (EDA), in the context of predictive modeling, is the exercise of looking at excerpts and summaries of the data. The specific goals of the EDA stage is informed by the business problem, but here are some common objectives: Check for data quality — confirm meaning and prevalence of missing values and reconcile statistics against existing controls, Understand univariate relationships between variables, and Perform an initial assessment on what variables to include and what transformations need to be done on them. We’ll first connect to Spark, load libraries and read in the data. library(sparklyr) library(ggplot2) library(dbplot) library(dplyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) okc &lt;- spark_read_csv( sc, &quot;data/profiles.csv&quot;, escape = &quot;\\&quot;&quot;, memory = FALSE, options = list(multiline = TRUE) ) %&gt;% mutate( height = as.numeric(height), income = ifelse(income == &quot;-1&quot;, NA, as.numeric(income)) ) %&gt;% mutate(sex = ifelse(is.na(sex), &quot;missing&quot;, sex)) %&gt;% mutate(drinks = ifelse(is.na(drinks), &quot;missing&quot;, drinks)) %&gt;% mutate(drugs = ifelse(is.na(drugs), &quot;missing&quot;, drugs)) %&gt;% mutate(job = ifelse(is.na(job), &quot;missing&quot;, job)) We specify escape = \"\\\"\" and options = list(multiline = TRUE) here to accommodate for embedded quote characters and newlines in the essay fields. We also convert the height and income columns to numeric types, and recode missing values in the string columns. Note that it may very well take a few tries of specifying different parameters to get the initial data ingest correct, and sometimes you may have to revisit this step after you learn more about the data during modeling. We can now take a quick look at our data with glimpse(): glimpse(okc) Observations: ?? Variables: 31 Database: spark_connection $ age &lt;int&gt; 22, 35, 38, 23, 29, 29, 32, 31, 24, 37, 35… $ body_type &lt;chr&gt; &quot;a little extra&quot;, &quot;average&quot;, &quot;thin&quot;, &quot;thin… $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;, &quot;anyt… $ drinks &lt;chr&gt; &quot;socially&quot;, &quot;often&quot;, &quot;socially&quot;, &quot;socially… $ drugs &lt;chr&gt; &quot;never&quot;, &quot;sometimes&quot;, &quot;missing&quot;, &quot;missing&quot;… $ education &lt;chr&gt; &quot;working on college/university&quot;, &quot;working … $ essay0 &lt;chr&gt; &quot;about me:&lt;br /&gt;\\n&lt;br /&gt;\\ni would love to … $ essay1 &lt;chr&gt; &quot;currently working as an international age… $ essay2 &lt;chr&gt; &quot;making people laugh.&lt;br /&gt;\\nranting about… $ essay3 &lt;chr&gt; &quot;the way i look. i am a six foot half asia… $ essay4 &lt;chr&gt; &quot;books:&lt;br /&gt;\\nabsurdistan, the republic, … $ essay5 &lt;chr&gt; &quot;food.&lt;br /&gt;\\nwater.&lt;br /&gt;\\ncell phone.&lt;br… $ essay6 &lt;chr&gt; &quot;duality and humorous things&quot;, &quot;missing&quot;, … $ essay7 &lt;chr&gt; &quot;trying to find someone to hang out with. … $ essay8 &lt;chr&gt; &quot;i am new to california and looking for so… $ essay9 &lt;chr&gt; &quot;you want to be swept off your feet!&lt;br /&gt;… $ ethnicity &lt;chr&gt; &quot;asian, white&quot;, &quot;white&quot;, &quot;missing&quot;, &quot;white… $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 65, 67, 65, 70… $ income &lt;dbl&gt; NaN, 80000, NaN, 20000, NaN, NaN, NaN, NaN… $ job &lt;chr&gt; &quot;transportation&quot;, &quot;hospitality / travel&quot;, … $ last_online &lt;chr&gt; &quot;2012-06-28-20-30&quot;, &quot;2012-06-29-21-41&quot;, &quot;2… $ location &lt;chr&gt; &quot;south san francisco, california&quot;, &quot;oaklan… $ offspring &lt;chr&gt; &quot;doesn&amp;rsquo;t have kids, but might want t… $ orientation &lt;chr&gt; &quot;straight&quot;, &quot;straight&quot;, &quot;straight&quot;, &quot;strai… $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes dogs a… $ religion &lt;chr&gt; &quot;agnosticism and very serious about it&quot;, &quot;… $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f… $ sign &lt;chr&gt; &quot;gemini&quot;, &quot;cancer&quot;, &quot;pisces but it doesn&amp;r… $ smokes &lt;chr&gt; &quot;sometimes&quot;, &quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;no&quot;,… $ speaks &lt;chr&gt; &quot;english&quot;, &quot;english (fluently), spanish (p… $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;single&quot;,… Now we will add our response variable as a column in the dataset and look at its distribution okc &lt;- okc %&gt;% mutate( not_working = ifelse(job %in% c(&quot;student&quot;, &quot;unemployed&quot;, &quot;retired&quot;), 1 , 0) ) okc %&gt;% group_by(not_working) %&gt;% tally() # Source: spark&lt;?&gt; [?? x 2] not_working n &lt;dbl&gt; &lt;dbl&gt; 1 0 54541 2 1 5405 Before we proceed further, let us perform an initial split of our data into a training set and a testing set and put away the latter. In practice, this is a crucial step because we would like to have a holdout set that we set aside at the end of the modeling process to evaluate model performance. If we were to include the entire dataset during EDA, information from the testing set could “leak” into the visualizations and summary statistics, and bias our model building process even though the data is not used directly in a learning algorithm. This would undermine the credibility of our performance metrics. Splitting the data can be done easily by using the sdf_partition() function: data_splits &lt;- sdf_random_split(okc, training = 0.8, testing = 0.2, seed = 42) okc_train &lt;- data_splits$training okc_test &lt;- data_splits$testing We can quickly look at the distribution of our response variable: okc_train %&gt;% group_by(not_working) %&gt;% tally() %&gt;% mutate(frac = n / sum(n)) # Source: spark&lt;?&gt; [?? x 3] not_working n frac &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 0 43785 0.910 2 1 4317 0.0897 Using the sdf_describe() function, we can obtain numerical summaries of specific columns: sdf_describe(okc_train, cols = c(&quot;age&quot;, &quot;income&quot;)) # Source: spark&lt;?&gt; [?? x 3] summary age income &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 count 48102 9193 2 mean 32.336534863415245 104968.99815076689 3 stddev 9.43908920033797 202235.2291773537 4 min 18 20000.0 5 max 110 1000000.0 Like we saw in the Analysis chapter, we can also utilize the dbplot package to plot distributions of these variables. In Figure 4.1 we show a histogram of the distribution of the age variable. dbplot_histogram(okc_train, age) FIGURE 4.1: Distribution of age A common EDA exercise is to look at the relationships between the response and the individual predictors. Often, you may have prior business knowledge on what these relationships should be, so this can serve as a data quality check. Also, unexpected trends can inform variable interactions you might want to include in the model. As an example, we can explore the religion variable: prop_data &lt;- okc_train %&gt;% mutate(religion = regexp_extract(religion, &quot;^\\\\\\\\w+&quot;, 0)) %&gt;% group_by(religion, not_working) %&gt;% tally() %&gt;% group_by(religion) %&gt;% summarize( count = sum(n), prop = sum(not_working * n) / sum(n) ) %&gt;% mutate(se = sqrt(prop * (1 - prop) / count)) %&gt;% collect() prop_data # A tibble: 10 x 4 religion count prop se &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 judaism 2520 0.0794 0.00539 2 atheism 5624 0.118 0.00436 3 christianity 4671 0.120 0.00480 4 hinduism 358 0.101 0.0159 5 islam 115 0.191 0.0367 6 agnosticism 7078 0.0958 0.00346 7 other 6240 0.0841 0.00346 8 missing 16152 0.0719 0.002 9 buddhism 1575 0.0851 0.007 10 catholicism 3769 0.0886 0.00458 Note that prop_data is a small data frame that has been collected into memory in our R session, we can take advantage of ggplot2 to create an informative visualization in Figure 4.2. prop_data %&gt;% ggplot(aes(x = religion, y = prop)) + geom_point(size = 2) + geom_errorbar(aes(ymin = prop - 1.96 * se, ymax = prop + 1.96 * se), width = .1) + geom_hline(yintercept = sum(prop_data$prop * prop_data$count) / sum(prop_data$count)) FIGURE 4.2: Proportion of individuals not currently employed, by religion Next, we take a look at the relationship between a couple of predictors: alcohol use and drug use. We would expect there to be some correlation between them. You can compute a contingency table via sdf_crosstab(): contingency_tbl &lt;- okc_train %&gt;% sdf_crosstab(&quot;drinks&quot;, &quot;drugs&quot;) %&gt;% collect() contingency_tbl # A tibble: 7 x 5 drinks_drugs missing never often sometimes &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 very often 54 144 44 137 2 socially 8221 21066 126 4106 3 not at all 146 2371 15 109 4 desperately 72 89 23 74 5 often 1049 1718 69 1271 6 missing 1121 1226 10 59 7 rarely 613 3689 35 445 We can visualize this contingency table using a mosaic plot, shown in Figure 4.3: library(ggmosaic) library(forcats) library(tidyr) contingency_tbl %&gt;% rename(drinks = drinks_drugs) %&gt;% gather(&quot;drugs&quot;, &quot;count&quot;, missing:sometimes) %&gt;% mutate( drinks = as_factor(drinks) %&gt;% fct_relevel(&quot;missing&quot;, &quot;not at all&quot;, &quot;rarely&quot;, &quot;socially&quot;, &quot;very often&quot;, &quot;desperately&quot;), drugs = as_factor(drugs) %&gt;% fct_relevel(&quot;missing&quot;, &quot;never&quot;, &quot;sometimes&quot;, &quot;often&quot;) ) %&gt;% ggplot() + geom_mosaic(aes(x = product(drinks, drugs), fill = drinks, weight = count)) FIGURE 4.3: Mosaic plot of drug and alcohol use To further explore the relationship between these two variables, we can perform correspondence analysis (Greenacre 2017) using the FactoMineR package. This technique enables us to summarize the relationship between the high dimensional factor levels by mapping each level to a point on the plane. We first obtain the mapping using FactoMineR::CA() as follows: dd_obj &lt;- contingency_tbl %&gt;% tibble::column_to_rownames(var = &quot;drinks_drugs&quot;) %&gt;% FactoMineR::CA(graph = FALSE) We can then plot the results using ggplot: dd_drugs &lt;- dd_obj$row$coord %&gt;% as.data.frame() %&gt;% mutate( label = gsub(&quot;_&quot;, &quot; &quot;, rownames(dd_obj$row$coord)), Variable = &quot;Drugs&quot; ) dd_drinks &lt;- dd_obj$col$coord %&gt;% as.data.frame() %&gt;% mutate( label = gsub(&quot;_&quot;, &quot; &quot;, rownames(dd_obj$col$coord)), Variable = &quot;Alcohol&quot; ) ca_coord &lt;- rbind(dd_drugs, dd_drinks) ggplot(ca_coord, aes(x = `Dim 1`, y = `Dim 2`, col = Variable)) + geom_vline(xintercept = 0) + geom_hline(yintercept = 0) + geom_text(aes(label = label)) + coord_equal() FIGURE 4.4: Correspondence analysis principal coordinates for drugs and alcohol use In Figure 4.4, we see that the correspondence analysis procedure has transformed the factors into variables called principal coordinates, which correspond to the axes in the plot and represent how much information in the contingency table they contain. We can, for example, interpret the proximity of “drinking often” and “using drugs very often” as indicating association. This concludes our discussion on EDA, and we will now proceed to feature engineering. 4.3 Feature Engineering The feature engineering exercise comprises transforming the data to increase the performance of the model. This can include things like centering and scaling numerical values and performing string manipulation to extract meaningful variables. It also often includes variable selection — the process of selecting which predictors are used in the model. In Figure 4.1 we see that the age variable has a range from 18 to over 60. Some algorithms, especially neural networks, train faster if we normalize our inputs so that they are of the same magnitude. Let’s now normalize the age variable by removing the mean and scaling to unit variance, beginning by calculating its mean and standard deviation: scale_values &lt;- okc_train %&gt;% summarize( mean_age = mean(age), sd_age = sd(age) ) %&gt;% collect() scale_values # A tibble: 1 x 2 mean_age sd_age &lt;dbl&gt; &lt;dbl&gt; 1 32.3 9.44 We can then use these to transform the dataset: okc_train &lt;- okc_train %&gt;% mutate(scaled_age = (age - !!scale_values$mean_age) / !!scale_values$sd_age) dbplot_histogram(okc_train, scaled_age) In Figure 4.5, we see that the scaled age variable has values that are closer to zero. We now move on to discussing other types of transformations, but during your feature engineering workflow you may want to perform the normalization to all numeric variables you want to include in the model. FIGURE 4.5: Distribution of scaled age Since some of the profile features are multiple-select, in other words, a person can choose to associate with multiple options for a variable, we need to process them before we can build meaningful models. If we take a look at the ethnicity column, for example, we see that there are many different combinations: okc_train %&gt;% group_by(ethnicity) %&gt;% tally() # Source: spark&lt;?&gt; [?? x 2] ethnicity n &lt;chr&gt; &lt;dbl&gt; 1 hispanic / latin, white 1051 2 black, pacific islander, hispanic / latin 2 3 asian, black, pacific islander 5 4 black, native american, white 91 5 middle eastern, white, other 34 6 asian, other 78 7 asian, black, white 12 8 asian, hispanic / latin, white, other 7 9 middle eastern, pacific islander 1 10 indian, hispanic / latin 5 # … with more rows One way to proceed would be to treat each combination of races as a separate level, but that would lead to a very large number of levels which becomes problematic in many algorithms. To better encode this information, we can create dummy variables for each race, as follows: ethnicities &lt;- c(&quot;asian&quot;, &quot;middle eastern&quot;, &quot;black&quot;, &quot;native american&quot;, &quot;indian&quot;, &quot;pacific islander&quot;, &quot;hispanic / latin&quot;, &quot;white&quot;, &quot;other&quot;) ethnicity_vars &lt;- ethnicities %&gt;% purrr::map(~ expr(ifelse(like(ethnicity, !!.x), 1, 0))) %&gt;% purrr::set_names(paste0(&quot;ethnicity_&quot;, gsub(&quot;\\\\s|/&quot;, &quot;&quot;, ethnicities))) okc_train &lt;- mutate(okc_train, !!!ethnicity_vars) okc_train %&gt;% select(starts_with(&quot;ethnicity_&quot;)) %&gt;% glimpse() Observations: ?? Variables: 9 Database: spark_connection $ ethnicity_asian &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… $ ethnicity_middleeastern &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… $ ethnicity_black &lt;dbl&gt; 0, 1, 0, 0, 0, 0, 0, 0, 0, 0… $ ethnicity_nativeamerican &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… $ ethnicity_indian &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… $ ethnicity_pacificislander &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… $ ethnicity_hispaniclatin &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… $ ethnicity_white &lt;dbl&gt; 1, 0, 1, 0, 1, 1, 1, 0, 1, 0… $ ethnicity_other &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… For the free text fields, a straightforward way to extract features is counting the total number of characters. We will store the train dataset in Spark’s memory with compute() to speed up computation. okc_train &lt;- okc_train %&gt;% mutate( essay_length = char_length(paste(!!!syms(paste0(&quot;essay&quot;, 0:9)))) ) %&gt;% compute() dbplot_histogram(okc_train, essay_length, bins = 100) We can see the distribution of the essay_length variable in Figure 4.6. FIGURE 4.6: Distribution of essay length We will be using this dataset in the Pipelines chapter, so let’s save it first as Parquet – an efficient file format ideal for numeric data. spark_write_parquet(okc_train, &quot;data/okc-train.parquet&quot;) Now that we have a few more features to work with, we can begin running some unsupervised learning algorithms! 4.4 Supervised Learning Once we have a good grasp on our dataset, we can start building some models. Before we do so, however, we need to come up with a plan to tune and validate the “candidate” models – in modeling projects, we often try different types of models and ways to fit them to see which ones perform the best. Since we are dealing with a binary classification problem, the metrics one can use include accuracy, precision, sensitivity, and area under the receiver operating characteristic curve (ROC AUC), among others. The metric you optimize depends on your specific business problem, but for this exercise, we will focus on the ROC AUC. It is important that we don’t peek at the testing holdout set until the very end, because any information we obtain may influence our modeling decisions which would in turn make our estimates of model performance less credible. For tuning and validation, we will perform 10-fold cross validation, which is a standard approach for model tuning. The scheme works as follows: We first divide our dataset into 10 approximately equal sized subsets. We take the 2nd to 10th sets together as the training set for an algorithm, and validate the resulting model on the 1st set. Next, we reserve the 2nd set as the validation set, and train the algorithm on the 1st and 3rd to 10th sets. In total, we train ten models and average the performance. If time and resources allow, you can also perform this procedure multiple times with different random partitions of the data. In our case, we will demonstrate how to perform the cross validation once. Hereinafter, we refer to the training set associated with each split as the analysis data, and the validation set as assessment data. Using the sdf_partition() function, we can create a list of subsets from our okc_train table: vfolds &lt;- sdf_random_split( okc_train, weights = purrr::set_names(rep(0.1, 10), paste0(&quot;fold&quot;, 1:10)), seed = 42 ) We then create our first analysis/assessment split as follows, analysis_set &lt;- do.call(rbind, vfolds[2:10]) assessment_set &lt;- vfolds[[1]] One item we need to carefully treat here is the scaling of variables. We need to make sure we do not leak any information from the assessment set to the analysis set, so we calculate the mean and standard deviation on the analysis set only, and apply the same transformation to both sets. Here is how we would handle this for the age variable: make_scale_age &lt;- function(analysis_data) { scale_values &lt;- analysis_data %&gt;% summarize( mean_age = mean(age), sd_age = sd(age) ) %&gt;% collect() function(data) { data %&gt;% mutate(scaled_age = (age - !!scale_values$mean_age) / !!scale_values$sd_age) } } scale_age &lt;- make_scale_age(analysis_set) train_set &lt;- scale_age(analysis_set) validation_set &lt;- scale_age(assessment_set) For brevity, here we only show how to transform the age variable. In practice, however, you would want to normalize each one of your continuous predictors, such as the essay_length variable we derived in the previous section. Logistic regression is often a reasonable starting point for binary classification problems, so let us give it a try. Suppose also that our domain knowledge provides us with an initial set of predictors. We can then fit a model by using the formula interface: lr &lt;- ml_logistic_regression( analysis_set, not_working ~ scaled_age + sex + drinks + drugs + essay_length ) lr Formula: not_working ~ scaled_age + sex + drinks + drugs + essay_length Coefficients: (Intercept) scaled_age sex_m drinks_socially -2.823517e+00 -1.309498e+00 -1.918137e-01 2.235833e-01 drinks_rarely drinks_often drinks_not at all drinks_missing 6.732361e-01 7.572970e-02 8.214072e-01 -4.456326e-01 drinks_very often drugs_never drugs_missing drugs_sometimes 8.032052e-02 -1.712702e-01 -3.995422e-01 -7.483491e-02 essay_length 3.664964e-05 To obtain a summary of performance metrics on the assessment set, we can use the ml_evaluate() function. validation_summary &lt;- ml_evaluate(lr, assessment_set) You can print validation_summary to see the available metrics validation_summary BinaryLogisticRegressionSummaryImpl Access the following via `$` or `ml_summary()`. - features_col() - label_col() - predictions() - probability_col() - area_under_roc() - f_measure_by_threshold() - pr() - precision_by_threshold() - recall_by_threshold() - roc() - prediction_col() - accuracy() - f_measure_by_label() - false_positive_rate_by_label() - labels() - precision_by_label() - recall_by_label() - true_positive_rate_by_label() - weighted_f_measure() - weighted_false_positive_rate() - weighted_precision() - weighted_recall() - weighted_true_positive_rate() We can plot the ROC curve by collecting the output of validation_summary$roc() and using ggplot2: roc &lt;- validation_summary$roc() %&gt;% collect() ggplot(roc, aes(x = FPR, y = TPR)) + geom_line() + geom_abline(lty = &quot;dashed&quot;) FIGURE 4.7: ROC curve for the logistic regression model The ROC curve plots the true positive rate (sensitivity) against the false positive rate (1 - specificity) for varying values of the classification threshold. In practice, the business problem helps to determine where on the curve one sets the threshold for classification. The AUC is a summary measure for determining the quality of a model, and we can compute it by calling the area_under_roc() function. validation_summary$area_under_roc() [1] 0.7872754 Note: Spark only provides evaluation methods for generalized linear models (including linear models and logistic regression.) For other algorithms, you can use the evaluator functions (e.g. ml_binary_classification_evaluator() on the prediction data frame) or compute your own metrics. Now, we can easily repeat the logic we have above and apply it to each analysis/assessment split: cv_results &lt;- purrr::map_df(1:10, function(v) { analysis_set &lt;- do.call(rbind, vfolds[setdiff(1:10, v)]) %&gt;% compute() assessment_set &lt;- vfolds[[v]] scale_age &lt;- make_scale_age(analysis_set) train_set &lt;- scale_age(analysis_set) validation_set &lt;- scale_age(assessment_set) model &lt;- ml_logistic_regression( analysis_set, not_working ~ scaled_age + sex + drinks + drugs + essay_length ) s &lt;- ml_evaluate(model, assessment_set) roc_df &lt;- s$roc() %&gt;% collect() auc &lt;- s$area_under_roc() tibble( Resample = paste0(&quot;Fold&quot;, stringr::str_pad(v, width = 2, pad = &quot;0&quot;)), roc_df = list(roc_df), auc = auc ) }) This gives us 10 ROC curves: unnest(cv_results, roc_df) %&gt;% ggplot(aes(x = FPR, y = TPR, color = Resample)) + geom_line() + geom_abline(lty = &quot;dashed&quot;) FIGURE 4.8: Cross-validated ROC curves for the logistic regression model and we can obtain the average AUC metric: mean(cv_results$auc) [1] 0.7715102 4.4.1 Generalized Linear Regression If you are interested in generalized linear model (GLM) diagnostics,you can also fit a logistic regression via the generalized linear regression interface by specifying family = \"binomial\". Because the result is a regression model, the ml_predict() method does not give class probabilities. However, it includes confidence intervals for coefficient estimates. glr &lt;- ml_generalized_linear_regression( analysis_set, not_working ~ scaled_age + sex + drinks + drugs, family = &quot;binomial&quot; ) tidy_glr &lt;- tidy(glr) We can extract the coefficient estimates into a tidy data frame, which we can then process further, for example, to create a coefficient plot, as shown in Figure 4.9. tidy_glr %&gt;% ggplot(aes(x = term, y = estimate)) + geom_point() + geom_errorbar( aes(ymin = estimate - 1.96 * std.error, ymax = estimate + 1.96 * std.error, width = .1) ) + coord_flip() + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;) FIGURE 4.9: Coefficient estimates with 95% confidence intervals Note: Both ml_logistic_regression() and ml_linear_regression() support elastic net regularization (Zou and Hastie 2005) through the reg_param and elastic_net_param parameters. reg_param corresponds to \\(\\lambda\\) whereas elastic_net_param correspond to \\(\\alpha\\). ml_generalized_linear_regression() supports only reg_param. 4.4.2 Other Models Spark supports many of the standard modeling algorithms and it’s easy to apply these models and hyperparameters (values that control the model fitting process) for your particular problem. You can find a list of supported ML related functions in the Appendix. The interfaces to access these functionalities are largely identical, so it is easy to experiment with them. For example, to fit a neural network model we can run: nn &lt;- ml_multilayer_perceptron_classifier( analysis_set, not_working ~ scaled_age + sex + drinks + drugs + essay_length, layers = c(12, 64, 64, 2) ) This gives us a feedforward neural network model with two hidden layers of 64 nodes each. Note that you have to specify the correct values for the input and output layers in the layers argument. We can obtain predictions on a validation set using ml_predict() predictions &lt;- ml_predict(nn, assessment_set) then compute the AUC via ml_binary_classification_evaluator() ml_binary_classification_evaluator(predictions) [1] 0.7812709 Up until now, we have not looked into the unstructured text in the essay fields apart from doing simple character counts. In the next section, we will explore the textual data in more depth. 4.5 Unsupervised Learning Along with speech, images, and videos, textual data is one of the components of the “big data” explosion. Prior to modern text mining techniques and the computational resources to support them, companies had little use for freeform text fields. Today, text is considered a rich source of insights, and can be found anywhere from physician’s notes to customer complaints. In this section, we show some basic text analysis capabilities of sparklyr. If you would like more background on text mining techniques, we recommend checking out “Text Mining with R: A Tidy Approach”. (Silge and Robinson 2017) In this section, we show how to perform a basic topic modeling task on the essay data in the OKCupid dataset. Our plan is to concatenate the essay fields (of which there are 10) of each profile, and regard each profile as a document, then attempt to discover topics (we will define these soon) using Latent Dirichlet Allocation (LDA). 4.5.1 Data Preparation As always, before analyzing a dataset (or a subset of one), we want to take a quick look at it to orient ourselves. In this case, we are interested in the freeform text that the users entered into their dating profiles. essay_cols &lt;- paste0(&quot;essay&quot;, 0:9) essays &lt;- okc %&gt;% select(!!essay_cols) essays %&gt;% glimpse() Observations: ?? Variables: 10 Database: spark_connection $ essay0 &lt;chr&gt; &quot;about me:&lt;br /&gt;\\n&lt;br /&gt;\\ni would love to think that… $ essay1 &lt;chr&gt; &quot;currently working as an international agent for a f… $ essay2 &lt;chr&gt; &quot;making people laugh.&lt;br /&gt;\\nranting about a good sa… $ essay3 &lt;chr&gt; &quot;the way i look. i am a six foot half asian, half ca… $ essay4 &lt;chr&gt; &quot;books:&lt;br /&gt;\\nabsurdistan, the republic, of mice an… $ essay5 &lt;chr&gt; &quot;food.&lt;br /&gt;\\nwater.&lt;br /&gt;\\ncell phone.&lt;br /&gt;\\nshelt… $ essay6 &lt;chr&gt; &quot;duality and humorous things&quot;, &quot;missing&quot;, &quot;missing&quot;,… $ essay7 &lt;chr&gt; &quot;trying to find someone to hang out with. i am down … $ essay8 &lt;chr&gt; &quot;i am new to california and looking for someone to w… $ essay9 &lt;chr&gt; &quot;you want to be swept off your feet!&lt;br /&gt;\\nyou are … Just from this output, we see that The text contains HTML tags, The text contains the newline \\n character, and There are missing values in the data. The HTML tags and special characters pollute the data since they are not directly input by the user and do not provide interesting information. Similarly, since we have encoded missing character fields with the \"missing\" string, we will need to remove it. (Note that by doing this we are also removing instances of the word “missing” written by the users, but the information lost from this removal is likely to be small.) As you analyze your own text data, you will quickly come across and become familiar with the peculiarities of the specific dataset. Preprocessing text data, like with tabular numerical data, is an iterative process, and after a few tries we have the following transformations: essays &lt;- essays %&gt;% # Replace `missing` with empty string. mutate_all(list(~ ifelse(. == &quot;missing&quot;, &quot;&quot;, .))) %&gt;% # Concatenate the columns. mutate(essay = paste(!!!syms(essay_cols))) %&gt;% # Remove miscellaneous characters and HTML tags mutate(words = regexp_replace(essay, &quot;\\\\n|&amp;nbsp;|&lt;[^&gt;]*&gt;|[^A-Za-z|&#39;]&quot;, &quot; &quot;)) Note here we are using regex_replace(), which is a Spark SQL function. Next, we will discuss LDA and how to apply it to our cleaned dataset. 4.5.2 Topic Modeling LDA is a type of topic model for identifying abstract “topics” in a set of documents. It is an unsupervised algorithm in that we do not provide any labels, or topics, for the input documents. LDA posits that each document is a mixture of topics, and each topic is a mixture of words. During training, it attempts to estimate both of these simultaneously. A typical use case for topic models involves categorizing many documents, where the large number of documents renders manual approaches infeasible. The application domains range from GitHub issues to legal documents. Once we have a reasonably clean dataset following the workflow in the previous section, we can fit an LDA model with ml_lda(): stop_words &lt;- ml_default_stop_words(sc) %&gt;% c( &quot;like&quot;, &quot;love&quot;, &quot;good&quot;, &quot;music&quot;, &quot;friends&quot;, &quot;people&quot;, &quot;life&quot;, &quot;time&quot;, &quot;things&quot;, &quot;food&quot;, &quot;really&quot;, &quot;also&quot;, &quot;movies&quot; ) lda_model &lt;- ml_lda(essays, ~ words, k = 6, max_iter = 1, min_token_length = 4, stop_words = stop_words, min_df = 5) We are also including a stop_words vector consisting of commonly used English words and common words in our dataset, which tells the algorithm to ignore them. After the model is fit, we can use the tidy() function to extract the associated betas, which are the per-topic-per-word probabilities, from the model. betas &lt;- tidy(lda_model) betas # A tibble: 256,992 x 3 topic term beta &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; 1 0 know 303. 2 0 work 250. 3 0 want 367. 4 0 books 211. 5 0 family 213. 6 0 think 291. 7 0 going 160. 8 0 anything 292. 9 0 enjoy 145. 10 0 much 272. # … with 256,982 more rows We can then visualize this output by looking at word probabilities by topic. In Figure 4.10 and Figure 4.11 we show the results at 1 iteration and 100 iterations. The code that generates Figure 4.10 follows; in order to generate Figure 4.11, you would need to set max_iter = 100 when running ml_lda(), but beware that this can take a really long time in a single machine – this is the kind of big-compute problem that a proper Spark cluster would be able to easily tackle! betas %&gt;% group_by(topic) %&gt;% top_n(10, beta) %&gt;% ungroup() %&gt;% arrange(topic, -beta) %&gt;% mutate(term = reorder(term, beta)) %&gt;% ggplot(aes(term, beta, fill = factor(topic))) + geom_col(show.legend = FALSE) + facet_wrap(~ topic, scales = &quot;free&quot;) + coord_flip() FIGURE 4.10: The most common terms per topic in the first iteration FIGURE 4.11: The most common terms per topic after one hundred iterations We can see that, at one hundred iterations, we can see “topics” starting to emerge. This could be interesting information in its own right if you were digging into a large collection of documents you aren’t familiar with. The learned topics can also serve as features in a downstream supervised learning task; for example, we could consider using the topic number as a predictor in our model to predict employment status in our predictive modeling example. Finally, to conclude this chapter you should disconnect from Spark; the next chapter will also make use the OKCupid dataset, but we will provide instructions to reload it from scratch. spark_disconnect(sc) 4.6 Recap In this chapter, we cover the basics of building predictive models in Spark with R by presenting the topics of EDA, feature engineering and building supervised models, where we explored using logistic regression and neural networks – just to pick a few from dozens of models available models available in Spark through MLlib. We then moved to learn about unsupervised learning to process raw text, where you were able to create a topic model that automatically grouped the profiles into six categories. Interestingly, we found out that building the topic model can take a significant amount of time using a single machine, almost perfect timing to introduce full-size computing clusters! But hold on to that thought, we first need to consider how to automate Data Science workflows. As we mentioned when introducing this chapter, emphasis was placed on predictive modeling – Spark can help with data science at scale, but also in productionizing data science workflows into automated processes, known by many as machine learning. The next chapter, Pipelines, will present the tools we will need to take our predictive models, and even our entire training workflows, into automated environments that can run continuously or be exported and consumed in web applications, mobile applications and so on! References "],
["pipelines.html", "Chapter 5 Pipelines 5.1 Overview 5.2 Creation 5.3 Use Cases 5.4 Operating Modes 5.5 Interoperability 5.6 Deployment 5.7 Recap", " Chapter 5 Pipelines “You will never walk again, but you will fly!” — Three-Eyed Raven In the Modeling chapter, we learned how to build predictive models using the high-level functions Spark provides and well-known R packages that work well together with Spark. You learned about supervised methods first and finished the chapter with an unsupervised method over raw text. In this chapter, we dive into Spark Pipelines, which is the engine that powers the features we demonstrated in the Modeling chapter. So for instance, when you invoke an MLlib function via the formula interface in R; for example ml_logistic_regression(cars, am ~ .), a pipeline gets constructed for you under the hood. Therefore, Pipelines also allow you to make use of advanced data processing and modeling workflows. In addition, a pipeline also facilitates collaboration across data science and engineering teams by allowing you to deploy pipelines into production systems, web applications, mobile applications and so on. This chapter also happens to be the last chapter that encourages using your local computer as a Spark cluster, you are just one chapter away from getting properly introduced to cluster computing, and be able to perform data science or machine learning that can scale to the most demanding computation problems. 5.1 Overview The building blocks of pipelines are objects called transformers and estimators, which are collectively referred to as pipeline stages. A transformer can be used to apply transformations to a data frame and return another data frame; the resulting data frame often comprises the original data frame with new columns appended to it. An estimator, on the other hand, can be used to create a transformer giving some training data. Consider the following example to illustrate this relationship: a “center and scale” estimator can learn the mean and standard deviation of some data and store the statistics in a resulting transformer object; this transformer can then be used to normalize the data it was trained on and also any new, yet unseen, data. Here is an example of how to define an estimator: library(sparklyr) library(dplyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) scaler &lt;- ft_standard_scaler( sc, input_col = &quot;features&quot;, output_col = &quot;features_scaled&quot;, with_mean = TRUE) scaler StandardScaler (Estimator) &lt;standard_scaler_7f6d46f452a1&gt; (Parameters -- Column Names) input_col: features output_col: features_scaled (Parameters) with_mean: TRUE with_std: TRUE We can now create some data (for which we know the mean and standard deviation) then fit our scaling model to it using the ml_fit() function. df &lt;- copy_to(sc, data.frame(value = rnorm(100000))) %&gt;% ft_vector_assembler(input_cols = &quot;value&quot;, output_col = &quot;features&quot;) scaler_model &lt;- ml_fit(scaler, df) scaler_model StandardScalerModel (Transformer) &lt;standard_scaler_7f6d46f452a1&gt; (Parameters -- Column Names) input_col: features output_col: features_scaled (Transformer Info) mean: num 0.00421 std: num 0.999 Note: In Spark ML, many algorithms and feature transformers require that the input be a vector column. The function ft_vector_assembler() performs this task. The function can also be used to initialize a transformer to be used in a pipeline. We see that the mean and standard deviation are very close to 0 and 1, respectively, which is what we expect. We can then use the transformer to transform a data frame, using the ml_transform() function: scaler_model %&gt;% ml_transform(df) %&gt;% glimpse() Observations: ?? Variables: 3 Database: spark_connection $ value &lt;dbl&gt; 0.75373300, -0.84207731, 0.59365113, -… $ features &lt;list&gt; [0.753733, -0.8420773, 0.5936511, -0.… $ features_scaled &lt;list&gt; [0.7502211, -0.8470762, 0.58999, -0.4… Now that we’ve seen basic examples of estimators and transformers, we can move on to pipelines. 5.2 Creation A pipeline is simply a sequence of transformers and estimators, and a pipeline model is a pipeline that has been trained on data so all of its components have been converted to transformers. There are a couple ways to construct a pipeline in sparklyr, both of which uses the ml_pipeline() function. We can initialize an empty pipeline with ml_pipeline(sc) and append stages to it: ml_pipeline(sc) %&gt;% ft_standard_scaler( input_col = &quot;features&quot;, output_col = &quot;features_scaled&quot;, with_mean = TRUE) Pipeline (Estimator) with 1 stage &lt;pipeline_7f6d6a6a38ee&gt; Stages |--1 StandardScaler (Estimator) | &lt;standard_scaler_7f6d63bfc7d6&gt; | (Parameters -- Column Names) | input_col: features | output_col: features_scaled | (Parameters) | with_mean: TRUE | with_std: TRUE Alternatively, we can pass stages directly to ml_pipeline(): pipeline &lt;- ml_pipeline(scaler) We fit a pipeline as we would fit an estimator: pipeline_model &lt;- ml_fit(pipeline, df) pipeline_model PipelineModel (Transformer) with 1 stage &lt;pipeline_7f6d64df6e45&gt; Stages |--1 StandardScalerModel (Transformer) | &lt;standard_scaler_7f6d46f452a1&gt; | (Parameters -- Column Names) | input_col: features | output_col: features_scaled | (Transformer Info) | mean: num 0.00421 | std: num 0.999 pipeline Note: As a result of the design of Spark ML, pipelines are always estimator objects, even if they comprise only of transformers. This means that if you have a pipeline with only transformers, you still need to call ml_fit() on it to obtain a transformer. The “fitting” procedure in this case wouldn’t actually modify any of the transformers. 5.3 Use Cases Now that we have an understanding of the rudimentary concepts for ML Pipelines, let us apply them to the predictive modeling problem from the previous chapter, where we are trying to predict whether people are currently employed by looking at their profiles. Our starting point is the okc_train data frame with the relevant columns. okc_train &lt;- spark_read_parquet(sc, &quot;data/okc-train.parquet&quot;) okc_train &lt;- okc_train %&gt;% select(not_working, age, sex, drinks, drugs, essay1:essay9, essay_length) We first exhibit the pipeline, which includes feature engineering and modeling steps, then walk through it. pipeline &lt;- ml_pipeline(sc) %&gt;% ft_string_indexer(input_col = &quot;sex&quot;, output_col = &quot;sex_indexed&quot;) %&gt;% ft_string_indexer(input_col = &quot;drinks&quot;, output_col = &quot;drinks_indexed&quot;) %&gt;% ft_string_indexer(input_col = &quot;drugs&quot;, output_col = &quot;drugs_indexed&quot;) %&gt;% ft_one_hot_encoder_estimator( input_cols = c(&quot;sex_indexed&quot;, &quot;drinks_indexed&quot;, &quot;drugs_indexed&quot;), output_cols = c(&quot;sex_encoded&quot;, &quot;drinks_encoded&quot;, &quot;drugs_encoded&quot;) ) %&gt;% ft_vector_assembler( input_cols = c(&quot;age&quot;, &quot;sex_encoded&quot;, &quot;drinks_encoded&quot;, &quot;drugs_encoded&quot;, &quot;essay_length&quot;), output_col = &quot;features&quot; ) %&gt;% ft_standard_scaler(input_col = &quot;features&quot;, output_col = &quot;features_scaled&quot;, with_mean = TRUE) %&gt;% ml_logistic_regression(features_col = &quot;features_scaled&quot;, label_col = &quot;not_working&quot;) The first three stages index the sex, drinks, and drugs columns, which are character, into numeric indicies via ft_string_indexer(). This is necessary for the ft_one_hot_encoder_estimator() that comes next which requires numeric column inputs. Once all of our predictor variables are of numeric type (recall that age is numeric already), we can create our features vector using ft_vector_assembler() which concatenates all of its inputs together into one column of vectors. We can then use ft_standard_scaler() to normalize all elements of the features column (including the one-hot encoded 0/1 values of the categorical variables), and finally apply a logistic regression via ml_logistic_regression(). During prototyping, you may want to execute these transformations eagerly on a small subset of the data, by passing the data frame to the ft_ and ml_ functions, and inspecting the transformed data frame. The immediate feedback allows for rapid iteration of ideas; once you have arrived at the desired processing steps, you can roll them up into a pipeline. For example, you can do the following: okc_train %&gt;% ft_string_indexer(&quot;sex&quot;, &quot;sex_indexed&quot;) %&gt;% select(sex_indexed) # Source: spark&lt;?&gt; [?? x 1] sex_indexed &lt;dbl&gt; 1 0 2 0 3 1 4 0 5 1 6 0 7 0 8 1 9 1 10 0 # … with more rows Once you have found the right transformations for your dataset, you can then replace the data frame input with ml_pipeline(sc), and the result will be a pipeline that you can apply to any data frame with the appropriate schema. In the next section, we’ll see how pipelines can make it easier for us to test different model specifications. 5.3.1 Hyperparameter Tuning Going back to the pipeline we have created above, we can use ml_cross_validator() to perform the cross validation workflow we demonstrated in the previous chapter and easily test different hyperparameter combinations. In this example, we test whether centering the variables improve predictions together with various regularization values for the logistic regression. We define the cross validator as follows: cv &lt;- ml_cross_validator( sc, estimator = pipeline, estimator_param_maps = list( standard_scaler = list(with_mean = c(TRUE, FALSE)), logistic_regression = list( elastic_net_param = c(0.25, 0.75), reg_param = c(1e-2, 1e-3) ) ), evaluator = ml_binary_classification_evaluator(sc, label_col = &quot;not_working&quot;), num_folds = 10) The estimator argument is simply the estimator we want to tune, and in this case it is the pipeline that we defined. We provide the hyperparameter values we are interested in via the estimator_param_maps parameter, which takes a nested named list. The names at the first level correspond to UIDs, which are unique identifiers associated with each pipeline stage object, of the stages we want to tune (if a partial UID is provided sparklyr will attempt to match it to a pipeline stage) and the names at the second level correspond to parameters of each stage. In the snippet above, we are specifying that we want to test Standard scaler The values TRUE and FALSE for with_mean, which denotes whether predictor values are centered. Logistic regression The values 0.25 and 0.75 for \\(\\alpha\\), and the values 1e-2 and 1e-3 for \\(\\lambda\\). We expect this to give rise to \\(2 \\times 2 \\times 2 = 8\\) hyperparameter combinations, which we can confirm by printing the cv object: cv CrossValidator (Estimator) &lt;cross_validator_d5676ac6f5&gt; (Parameters -- Tuning) estimator: Pipeline &lt;pipeline_d563b0cba31&gt; evaluator: BinaryClassificationEvaluator &lt;binary_classification_evaluator_d561d90b53d&gt; with metric areaUnderROC num_folds: 10 [Tuned over 8 hyperparameter sets] As with any other estimator, we can fit the cross validator using ml_fit() cv_model &lt;- ml_fit(cv, okc_train) and inspect the results: ml_validation_metrics(cv_model) %&gt;% arrange(-areaUnderROC) areaUnderROC elastic_net_param_1 reg_param_1 with_mean_2 1 0.7722700 0.75 0.001 TRUE 2 0.7718431 0.75 0.010 FALSE 3 0.7718350 0.75 0.010 TRUE 4 0.7717677 0.25 0.001 TRUE 5 0.7716070 0.25 0.010 TRUE 6 0.7715972 0.25 0.010 FALSE 7 0.7713816 0.75 0.001 FALSE 8 0.7703913 0.25 0.001 FALSE Now that we have seen the pipelines API in action, let’s talk more formally about how they behave in various contexts. 5.4 Operating Modes By now, you have likely noticed that the pipeline stage functions, such as ft_string_indexer() and ml_logistic_regression(), return different types of objects depending on the first argument passed to them. The full pattern is: First argument Returns Example Spark connection Estimator or transformer object ft_string_indexer(sc) Pipeline Pipeline ml_pipeline(sc) %&gt;% ft_string_indexer() Data frame, without formula Data frame ft_string_indexer(iris, \"Species\", \"indexed\") Data frame, with formula sparklyr ML model object ml_logistic_regression(iris, Species ~ .) These functions are implemented using S32, which is the most popular object oriented programming paradigm provided by R. For our purposes, it suffices to know that the behavior of an ml_ or ft_ function is dictated by the class of the first argument provided. This allows us to provide a wide range of features without introducing additional function names. We can now summarize the behavior of these functions: If a Spark connection is provided, the function returns a transformer or estimator object, which can be utilized directly using ml_fit() or ml_transform() or be included in a pipeline. If a pipeline is provided, the function returns a pipeline object with the stage appended to it. If a data frame is provided to a feature transformer function (those with prefix ft_), or an ML algorithm without also providing a formula, the function instantiates the pipeline stage object, fit it to the data if necessary (if the stage is an estimator), then transforms the data frame returning a data frame. If a data frame and a formula are provided to an ML algorithm that supports the formula interface, sparklyr builds a pipeline model under the hood and returns an ML model object which contains additional metadata information. The formula interface approach is what we studied in the Modeling section, and is what we recommend new users to Spark start with, since its syntax is similar to existing R modeling packages and abstracts away some Spark ML peculiarities. However, to take advantage of the full power of Spark ML and leverage pipelines for workflow organization and interoperability, it is worthwhile to learn the ML Pipelines API. With the basics of pipelines down, we are now ready to discuss the collaboration and model deployment aspects hinted at in the introduction of this chapter. 5.5 Interoperability One of the most powerful aspects of pipelines is that they can be serialized to disk and are fully interoperable with the other Spark APIs, such as Python and Scala. This means they can be easily shared among users of Spark working in different languages, which may include other data scientists, data engineers, and deployment engineers. To save a pipeline model, call ml_save() and provide a path. model_dir &lt;- file.path(&quot;spark_model&quot;) ml_save(cv_model$best_model, model_dir, overwrite = TRUE) Model successfully saved. Let us take a look at the directory we just wrote to. list.dirs(model_dir,full.names = FALSE) %&gt;% head(10) [1] &quot;&quot; [2] &quot;metadata&quot; [3] &quot;stages&quot; [4] &quot;stages/0_string_indexer_5b42c72817b&quot; [5] &quot;stages/0_string_indexer_5b42c72817b/data&quot; [6] &quot;stages/0_string_indexer_5b42c72817b/metadata&quot; [7] &quot;stages/1_string_indexer_5b423192b89f&quot; [8] &quot;stages/1_string_indexer_5b423192b89f/data&quot; [9] &quot;stages/1_string_indexer_5b423192b89f/metadata&quot; [10] &quot;stages/2_string_indexer_5b421796e826&quot; We can dive into a couple of the files to see what type of data was saved. spark_read_json(sc, file.path( file.path(dir(file.path(model_dir, &quot;stages&quot;), pattern = &quot;1_string_indexer.*&quot;, full.names = TRUE), &quot;metadata&quot;) )) %&gt;% glimpse() Observations: ?? Variables: 5 Database: spark_connection $ class &lt;chr&gt; &quot;org.apache.spark.ml.feature.StringIndexerModel&quot; $ paramMap &lt;list&gt; [[&quot;error&quot;, &quot;drinks&quot;, &quot;drinks_indexed&quot;, &quot;frequencyDesc&quot;]] $ sparkVersion &lt;chr&gt; &quot;2.3.2&quot; $ timestamp &lt;dbl&gt; 1.561763e+12 $ uid &lt;chr&gt; &quot;string_indexer_ce05afa9899&quot; spark_read_parquet(sc, file.path( file.path(dir(file.path(model_dir, &quot;stages&quot;), pattern = &quot;6_logistic_regression.*&quot;, full.names = TRUE), &quot;data&quot;) )) # Source: spark&lt;data&gt; [?? x 5] numClasses numFeatures interceptVector coefficientMatr… isMultinomial &lt;int&gt; &lt;int&gt; &lt;list&gt; &lt;list&gt; &lt;lgl&gt; 1 2 12 &lt;dbl [1]&gt; &lt;-1.27950828662… FALSE We see that quite a bit of information has been exported, from the SQL statement in the dplyr transformer to the fitted coefficient estimates of the logistic regression. We can then (in a new Spark session) reconstruct the model by using ml_load(): model_reload &lt;- ml_load(sc, model_dir) Let us see if we can retrieve the logistic regression stage from this pipeline model: ml_stage(model_reload, &quot;logistic_regression&quot;) LogisticRegressionModel (Transformer) &lt;logistic_regression_5b423b539d0f&gt; (Parameters -- Column Names) features_col: features_scaled label_col: not_working prediction_col: prediction probability_col: probability raw_prediction_col: rawPrediction (Transformer Info) coefficient_matrix: num [1, 1:12] -1.2795 -0.0915 0 0.126 -0.0324 ... coefficients: num [1:12] -1.2795 -0.0915 0 0.126 -0.0324 ... intercept: num -2.79 intercept_vector: num -2.79 num_classes: int 2 num_features: int 12 threshold: num 0.5 thresholds: num [1:2] 0.5 0.5 Note that the exported JSON and parquet files are agnostic of the API that exported them. This means that in a multilingual machine learning engineering team, you can pick up a data preprocessing pipeline from a data engineer working in Python, build a prediction model on top of it, then hand off the final pipeline off to a deployment engineering working in Scala. In the next section, we discuss deployment of models in more detail. Note: When ml_save() is called for sparklyr ML models (created using the formula interface), the associated pipeline model is saved, but any sparklyr specific metadata, such as index labels, are not. In other words, saving a sparklyr ml_model object then loading it will yield a pipeline model object, as if you created it via the ML Pipelines API. This behavior is required to use pipelines with other programming languages. Before we move on to discuss how to run pipelines in production, make sure you disconnect from Spark, spark_disconnect(sc) That way, we will start from a brand new new environment; which is also expected when deploying pipelines to production. 5.6 Deployment What we have just demonstrated bears emphasizing: by collaborating within the framework of ML pipelines, we reduce friction among different personas in a data science team. In particular, we can cut down on the time from modeling to deployment. In many cases, a data science project does not end with just a slide deck with insights and recommendations. Instead, the business problem at hand may require scoring new data points on a schedule or on-demand in real time. For example, a bank might want to evaluate its mortgage portfolio risk nightly, or to provide instant decisions on credit card applications. This process of taking a model and turning it into a service that others can consume is usually referred to as deployment or productionisation. Historically, there was a large gap between the analyst who built the model and the engineer who deployed it: the former might work in R and develop extensive documentation on the scoring mechanism, so the latter can re-implement the model in C++ or Java. This practice, which may easily take months in some organizations, is less prevalent today, but is almost always unnecessary in Spark ML workflows. The nightly portfolio risk and credit application scoring examples we mention above represent two modes of ML deployment known as batch and real-time. Loosely, batch processing implies processing many records at the same time and that execution time is not important as long it is reasonable (often on the scale of minutes to hours.) On the other hand, real-time processing implies scoring one or a few records at a time but the latency is crucial (on the scale of &lt;1 second.) We will now see how we can take our OKCupid pipeline model to “production.” 5.6.1 Batch Scoring For both scoring methods, batch and real-time, we will expose our model as web services, in the form of an API over the Hypertext Transfer Protocol (HTTP). This is the primary medium over which software communicates. By providing an API, other services or end users can utilize our model without any knowledge of R or Spark. The plumber3 R package enables us to do this very easily by annotating our prediction function. You will need make sure that plumber, callr and the httr package are installed by running: install.packages(c(&quot;plumber&quot;, &quot;callr&quot;, &quot;httr&quot;)) The callr package provides support to run R code in separate R sessions, it is not strictly required but we will use it to start a web service in the background. The httr package allows us to use web APIs from R. In the batch scoring use case, we simply initiate a Spark connection and load the saved model. Save the following script as plumber/spark-plumber.R: library(sparklyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) spark_model &lt;- ml_load(sc, &quot;spark_model&quot;) #* @post /predict score_spark &lt;- function(age, sex, drinks, drugs, essay_length) { new_data &lt;- data.frame( age = age, sex = sex, drinks = drinks, drugs = drugs, essay_length = essay_length, stringsAsFactors = FALSE ) new_data_tbl &lt;- copy_to(sc, new_data, overwrite = TRUE) ml_transform(spark_model, new_data_tbl) %&gt;% dplyr::pull(prediction) } We can then initialize the service by executing the following: service &lt;- callr::r_bg(function() { p &lt;- plumber::plumb(&quot;plumber/spark-plumber.R&quot;) p$run(port = 8000) }) This will start the web service locally that we can then query the service with new data to be scored; however, you might need to wait a few seconds for the Spark service to initialize. httr::content(httr::POST( &quot;http://127.0.0.1:8000/predict&quot;, body = &#39;{&quot;age&quot;: 42, &quot;sex&quot;: &quot;m&quot;, &quot;drinks&quot;: &quot;not at all&quot;, &quot;drugs&quot;: &quot;never&quot;, &quot;essay_length&quot;: 99}&#39; )) [[1]] [1] 0 This reply tell us that this particular profile is likely to not be unemployed, that is, employed. We can now terminate the plumber service by stopping the callr service: service$interrupt() If we were to time this operation (e.g. with system.time()), we see that the latency is on the order of hundreds of milliseconds, which may be appropriate for batch applications but insufficient for real-time. The main bottleneck is the serialization of the R data frame to a Spark data frame and back. Also, it also requires an active Spark session which is a heavy runtime requirement. To ameliorate these issues, we discuss next a deployment method more suitable for real time deployment. 5.6.2 Real-Time Scoring For real-time production, we want to keep dependencies as light as possible so we can target more platforms for deployment. We now show how we can use the mleap4 package, which provides an interface to the MLeap5 library, to serialize and serve Spark ML models. MLeap is open source (Apache License 2.0) and supports a wide range, though not all, of Spark ML transformers. At run time, the only prerequisites for the environment are the Java Virtual Machine (JVM) and the MLeap runtime library. This avoids both the Spark binaries and expensive overhead in converting data to and from Spark data frames. Since mleap is a sparklyr extension and an R package, first we need to install it from CRAN: install.packages(&quot;mleap&quot;) It then must be loaded when spark_connect() is called; so let’s restart your R session, establish a new Spark connection6, and load the pipeline model that we previously saved. library(sparklyr) library(mleap) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) spark_model &lt;- ml_load(sc, &quot;spark_model&quot;) The way we save a model to MLeap bundle format is very similar to saving a model using the Spark ML Pipelines API; the only additional argument is sample_input, which is a Spark data frame with schema that we expect new data to be scored to have. sample_input &lt;- data.frame( sex = &quot;m&quot;, drinks = &quot;not at all&quot;, drugs = &quot;never&quot;, essay_length = 99, age = 25, stringsAsFactors = FALSE ) sample_input_tbl &lt;- copy_to(sc, sample_input) ml_write_bundle(spark_model, sample_input_tbl, &quot;mleap_model.zip&quot;, overwrite = TRUE) The artifact we just created, mleap_model.zip, can now be deployed in any device that runs Java and has the open source MLeap runtime dependencies, without needing Spark or R! In fact, we can go ahead and disconnect from Spark already: spark_disconnect(sc) Before we use this MLeap model, make sure the runtime dependencies are installed: mleap::install_maven() mleap::install_mleap() To test this model, we can create a new plumber API to expose it. The script plumber/mleap-plumber.R is very similar to the previous example: library(mleap) mleap_model &lt;- mleap_load_bundle(&quot;mleap_model.zip&quot;) #* @post /predict score_spark &lt;- function(age, sex, drinks, drugs, essay_length) { new_data &lt;- data.frame( age = as.double(age), sex = sex, drinks = drinks, drugs = drugs, essay_length = as.double(essay_length), stringsAsFactors = FALSE ) mleap_transform(mleap_model, new_data)$prediction } And the way we launch the service is exactly the same: service &lt;- callr::r_bg(function() { p &lt;- plumber::plumb(&quot;plumber/mleap-plumber.R&quot;) p$run(port = 8000) }) We can run the exact same code we did previously to test unemployment predictions in this new service: httr::POST( &quot;http://127.0.0.1:8000/predict&quot;, body = &#39;{&quot;age&quot;: 42, &quot;sex&quot;: &quot;m&quot;, &quot;drinks&quot;: &quot;not at all&quot;, &quot;drugs&quot;: &quot;never&quot;, &quot;essay_length&quot;: 99}&#39; ) %&gt;% httr::content() [[1]] [1] 0 If we were to time this operation, we will see that the service now returns predictions in tens of milliseconds! Let’s stop this service and then wrap up this chapter. service$interrupt() 5.7 Recap In this chapter, we discussed Spark Pipelines, which is the engine behind the modeling functions introduced in the previous chapter. We learned how to tidy up our predictive modeling workflows by organizing data processing and modeling algorithms into pipelines. You learned that pipelines also facilitate collaboration among members of a multilingual data science and engineering team by sharing a language agnostic serialization format – you can export a Spark pipeline from R and let others reload your pipeline into Spark using Python or Scala, which allows them to collaborate without changing their language of choice. You also learned how to deploy pipelines using mleap, a Java runtime which provides another path to productionize Spark models – you can export a pipeline and integrate it to Java-enabled environments without requiring the target environment to support Spark nor R. You probably noticed that some algorithms, especially the unsupervised learning kind, where slow even for the OKCupid dataset which can be loaded into memory. If we had access to a proper Spark cluster, we could spend more time modeling and less time waiting! Not only that, but we could use cluster resources to run broader hyperparameter-tuning jobs and process large-datasets. To get there, the next chapter will present what exactly a computing cluster is and explain you various options you can consider; like building your own, or using cloud clusters on-demand. Notice that AutoML uses cross-validation which we did not use in GLM.↩ https://www.rplumber.io/↩ https://github.com/rstudio/mleap↩ https://github.com/combust/mleap↩ Note that, as of the writing of this book, MLeap does not yet support Spark 2.4.↩ "],
["clusters.html", "Chapter 6 Clusters 6.1 Overview 6.2 On-Premise 6.3 Cloud 6.4 Kubernetes 6.5 Tools 6.6 Recap", " Chapter 6 Clusters “I have a very large army and very large dragons.” — Daenerys Targaryen Previous chapters focused on using Spark over a single computing instance, your personal computer. In this chapter we will introduce techniques to run Spark over multiple computing instances, also known as a computing cluster. This chapter and subsequent ones will introduce and make use of concepts applicable to computing clusters; however, it’s not required to use a computing cluster to follow along, you can still use your personal computer. It’s worth mentioning that while previous chapters focused on single computing instances, all the data analysis and modeling techniques we presented, can also be used in a computing cluster without changing any code. For those of you who already have a Spark cluster in your organization, you could consider skipping to the next chapter, Connections, which will teach you how to connect to an existing cluster. Otherwise, if you don’t have a cluster or are considering improvements to your existing infrastructure, this chapter will introduce the cluster trends, managers, and providers available today. 6.1 Overview There are three major trends in cluster computing worth discussing: On-Premise, Cloud computing, and Kubernetes. Framing these trends over time will help us understand how they came to be, what they are, and what their future might be. To illustrate this, Figure 6.1 plots these trends over time using data from Google trends. FIGURE 6.1: Google trends for on-premise (mainframe), cloud computing and Kubernetes For on-premise clusters, yourself or someone in your organization purchased physical computers that were intended to be used for cluster computing. The computers in this cluster are made of off-the-shelf hardware, meaning that someone placed an order to purchase computers usually found in stores shelves or, high-performance hardware, meaning that a computing vendor provided highly customized computing hardware which also comes optimized for high-performance network connectivity, power consumption, etc. When purchasing hundreds or thousands of computing instances, it doesn’t make sense to keep them in the usual computing case that we are all familiar with; instead, it makes sense to stack them as efficiently as possible on top of each other to minimize the space the use. This group of efficiently stacked computing instances is known as a rack. Once a cluster grows to thousands of computers, you will also need to host hundreds of racks of computing devices, at this scale, you would also need significant physical space to hosts those racks. A building that provides racks of computing instances is usually known as a data center. At the scale of a data center, you would also need to find ways to make the building more efficient, specially the cooling system, power supplies, network connectivity, and so on. Since this is time consuming, a few organizations have come together to open source their infrastructure under the Open Compute Project initiative, which provides a set of data center blueprints free for anyone to use. There is nothing preventing you from building our own data center and in fact, many organizations have followed this path. For instance, Amazon started as an online book store, over the years Amazon grew to sell much more than just books and, with its online store growth, their data centers also grew in size. In 2002, Amazon considered renting servers in their data centers to the public, two year later, Amazon Web Services launched as a way to let anyone rent servers in their data centers on-demand, meaning that, one did not have to purchase, configure, maintain nor tear down it’s own clusters but could rather rent them from Amazon directly. This on-demand compute model is what we know today as Cloud Computing. In the cloud, the cluster you use is not owned by you and it’s neither in your physical building, but rather, it’s a data center owned and managed by someone else. Today, there are many cloud providers in this space ranging from Amazon, Databricks, IBM, Google, Microsoft and many others. Most cloud computing platforms provide a user interface either through a web application and command line to request and manage resources. While the benefits of processing data in the cloud were obvious for many years, picking a cloud provider had the unintended side-effect of locking organizations with one particular provider, making it hard to switch between providers or back to on-premise clusters. Kubernetes, announced by Google in 2014, is an open source system for managing containerized applications across multiple hosts. In practice, it makes it easier to deploy across multiple cloud providers and on-premise as well. In summary, we have seen a transition from on-premise to cloud computing and more recently Kubernetes. These technologies are often loosely described as the private cloud, the public cloud and as one of the orchestration services that can enable a hybrid cloud, respectively. This chapter will walk you through each cluster computing trend in the context of Spark and R. 6.2 On-Premise As mentioned in the overview section, on-premise clusters represent a set of computing instances procured and managed by staff members from your organization. These clusters can be highly customized and controlled; however, they can also incur higher initial expenses and maintenance costs. When using On-Premise Spark clusters, there are two concepts you should consider: Cluster Manager: In a similar way as to how an Operating Systems (like Windows os OS X) allows you to run multiple applications in the same computer; a cluster manager allows multiple applications to be run in the same cluster. You will have to choose one yourself when working with On-Premise clusters. Spark Distribution: While you can install Spark from the Apache Spark site, many companies partner with companies that can provide support and enhancements to Apache Spark which we often refer as, Spark distributions. 6.2.1 Managers In order to run Spark within a computing cluster, you will need to run software capable of initializing Spark over each physical machine and register all the available computing nodes, this software is known as a cluster manager. The available cluster managers in Spark are: Spark Standalone, YARN, Mesos and Kubernetes. Note: In distributed systems and clusters literature, we often refer to each physical machine as a compute instance, compute node, instance or node. 6.2.1.1 Standalone In Spark Standalone, Spark uses itself as its own cluster manager, which allows you to use Spark without installing additional software in your cluster. This can be useful if you are planning to use your cluster to only run Spark applications; if this cluster is not dedicated to Spark, a generic cluster manager like YARN, Mesos or Kubernetes would be more suitable. The Spark Standalone documentation is available under spark.apache.org (“Spark Standalone Mode” 2019) and contains detailed information on configuring, launching, monitoring and enabling high-availability, see Figure 6.2. FIGURE 6.2: Spark Standalone Site However, since Spark Standalone is contained within a Spark installation; then, by completing the Getting Started chapter, you have now a Spark installation available that you can use to initialize a local Spark Standalone cluster in your own machine. In practice, you would want to start the worker nodes in different machines but, for simplicity, we will present the code to start a standalone cluster in a single machine. First, retrieve the SPARK_HOME directory by running spark_home_dir() then starting the master node and a worker node as follows: # Retrieve the Spark installation directory spark_home &lt;- spark_home_dir() # Build paths and classes spark_path &lt;- file.path(spark_home, &quot;bin&quot;, &quot;spark-class&quot;) # Start cluster manager master node system2(spark_path, &quot;org.apache.spark.deploy.master.Master&quot;, wait = FALSE) The previous command initialized the master node, the master node interface can be accessed under localhost:8080 as captured in Figure 6.3. Please note the Spark master URL is specified as spark://address:port, you will need this URL to initialize worker nodes. FIGURE 6.3: Spark Standalone Web Interface. We can then initialize a single worker using the master URL; although, a similar approach could be used to initialize multiple workers by running the code multiple times and, potentially, across different machines. # Start worker node, find master URL at http://localhost:8080/ system2(spark_path, c(&quot;org.apache.spark.deploy.worker.Worker&quot;, &quot;spark://address:port&quot;), wait = FALSE) Notice that there is one worker register in Spark standalone, you can follow the link to this worker node to see, Figure 6.4, details for this particular worker like available memory and cores. FIGURE 6.4: Spark Standalone Worker Web Interface Once you are done performing computations in this cluster, you will need to stop the master and worker nodes, you can use jps to list to identify the process numbers to terminate. In this particular example 15330 and 15353 are the process you can terminate to finalize this cluster. To terminate a process, you can use system(\"Taskkill /PID ##### /F\") in Windows or system(\"kill -9 #####\") in OS X and Linux. system(&quot;jps&quot;) 15330 Master 15365 Jps 15353 Worker 1689 QuorumPeerMain A similar approach can be followed to configure a cluster by the initialization code over each machine in the cluster. While it’s possible to initialize a simple standalone cluster, configuring a proper Spark standalone cluster that can recover from computer restarts, failures, supports multiple users, permissions, etc. is usually a much longer process that falls beyond the scope of this book. The following sections will present several alternatives that can be much easier to manage on-premise or through cloud services, we will start by introducing YARN. 6.2.1.2 Yarn YARN for short, or Hadoop YARN, is the resource manager of the Hadoop project. It was originally developed in the Hadoop project but, refactored into its own project in Hadoop 2. As we mentioned in the Introduction chapter, Spark was built to speed up computation over Hadoop and therefore, it’s very common to find Spark installed on Hadoop clusters. One advantage of YARN, is that it is likely to be already installed in many existing clusters that support Hadoop; which means that you can easily use Spark with many existing Hadoop clusters without requesting any major changes to the existing cluster infrastructure. It is also very common to find Spark deployed in YARN clusters since many started out as Hadoop clusters that were eventually upgraded to also support Spark. YARN applications can be submitted in two modes: yarn-client and yarn-cluster. In yarn-cluster mode the driver is running remotely (potentially), while in yarn-client mode, the driver is running locally, both modes are supported and are explained further in the Connections chapter. YARN provides a resource management user interface useful to access logs, monitor available resources, terminate applications, etc. Once connecting to Spark from R, you will be able to manage the running application in YARN, this is shown in Figure 6.5. FIGURE 6.5: YARN’s Resource Manager running sparklyr application Since YARN is the cluster manager from the Hadoop project, YARN’s documentation can be found under the hadoop.apache.org (“Apache Hadoop Yarn” 2019), you can also reference the “Running Spark on YARN” guide from spark.apache.org. (“Running Spark on Yarn” 2018a) 6.2.1.3 Mesos Apache Mesos is an open-source project to manage computer clusters. Mesos began as a research project in the UC Berkeley RAD Lab and makes use of Linux Cgroups to provide isolation for CPU, memory, I/O and file system access. Mesos, like YARN, supports executing many cluster frameworks, including Spark. However, one advantage particular to Mesos is that, it allows cluster framework like Spark to implement custom task schedulers. A scheduler is the component that coordinates in a cluster which applications get execution time and which resources are assigned to them. Spark uses a coarse-grained scheduler (“Spark on Mesos” 2018) which schedules resources for the duration of the application; however, other frameworks might use Mesos’ fine-grained scheduler, which can increase the overall efficiency in the cluster by scheduling tasks in shorter intervals allowing them to share resources between them. Mesos provides a web interface to manage your running applications, resources, and so on. After connecting to Spark from R, your application will be registered like any other application running in Mesos, Figure 6.6 shows a successful connection to Spark from R. FIGURE 6.6: Mesos web interface running Spark from R Mesos is an Apache project with its documentation available under mesos.apache.org. The “Running Spark on Mesos” guide from spark.apache.org is also a great resource if you choose to use Mesos as your cluster manager. 6.2.2 Distributions One can use a cluster manager in on-premise clusters as described in the previous section; however, many organizations choose to partner with companies providing additional management software, services and resources to help manage applications in their cluster; including, but not limited to, Apache Spark. Some of the on-premise cluster providers include: Cloudera, Hortonworks and MapR to mention a few which we will be briefly introduce next. Cloudera, Inc. is a United States-based software company that provides Apache Hadoop and Apache Spark-based software, support and services, and training to business customers. Cloudera’s hybrid open-source Apache Hadoop distribution, CDH (Cloudera Distribution Including Apache Hadoop), targets enterprise-class deployments of that technology. Cloudera donates more than 50% of its engineering output to the various Apache-licensed open source projects (Apache Hive, Apache Avro, Apache HBase, and so on) that combine to form the Apache Hadoop platform. Cloudera is also a sponsor of the Apache Software Foundation. (“Cloudera Wikipedia” 2018) Cloudera clusters make use of parcels, which are binary distributions containing program files and metadata (“Cloudera Documentation” 2018), Spark happens to be installed as a parcel in Cloudera. It’s beyond the scope of this book to present how to configure Cloudera clusters, resources and documentation can be found under cloudera.com, and “Introducing sparklyr, an R Interface for Apache Spark” (“Cloudera Engineering” 2016) under Cloudera’s Engineering Blog. Cloudera provides the Cloudera Manager web interface to manage resources, services, parcels, diagnostics, etc. Figure 6.7 shows a Spark parcel running in Cloduera Manager which you can later use to connect from R. FIGURE 6.7: Cloudera Manager running Spark parcel sparklyr is certified with Cloudera; (“Cloudera Partners” 2017) meaning that, Cloudera’s support is aware of sparklyr and can be effective helping organizations that are using Spark and R, the following table summarizes the versions currently certified. Cloudera Version Product Version Components Kerberos CDH5.9 sparklyr 0.5 HDFS, Spark Yes CDH5.9 sparklyr 0.6 HDFS, Spark Yes CDH5.9 sparklyr 0.7 HDFS, Spark Yes Hortonworks is a big data software company based in Santa Clara, California. The company develops, supports, and provides expertise on an expansive set of entirely open source software designed to manage data and processing for everything from IOT, to advanced analytics and machine learning. Hortonworks believes it is a data management company bridging the cloud and the datacenter. (“Hortonworks Wikipedia” 2018) Hortonworks partnered with Microsoft (“Hortonworks Microsoft” 2018) to improve support in Microsoft Windows for Hadoop and Spark, this used to be a differentiation point; however, comparing Hortonworks and Cloudera is less relevant today since both companies are merging in 2019. (“Hortonworks Cloudera” 2018) While the companies are merging, support for the Cloudera and Hortonworks Spark distributions are still available. Additional resources to configure Spark under Hortonworks are available under hortonworks.com. MapR is a business software company headquartered in Santa Clara, California. MapR provides access to a variety of data sources from a single computer cluster, including big data workloads such as Apache Hadoop and Apache Spark, a distributed file system, a multi-model database management system, and event stream processing, combining analytics in real-time with operational applications. Its technology runs on both commodity hardware and public cloud computing services. (“MapR Wikipedia” 2018) 6.3 Cloud If you don’t have an on-prem cluster nor spare machines to reuse, starting with a cloud cluster can be quite convenient since it will allow you to access a proper cluster in a matter of minutes. This section will briefly mention some of the major cloud infrastructure providers and give you resources to help you get started if you choose to use a cloud provider. In cloud services, the compute instances are billed for as long the Spark cluster runs; you start getting billed when the cluster launches and stops when the cluster stops. This cost needs to be multiplied by the number of instances reserved for your cluster. SO for instance, if a cloud provider charges $1.00USD per compute instance per hour and you start a three node cluster that you use for one hour and 10 minutes; it is likely that you’ll get billed $1.00 * 2 hours * 3 nodes = $6.00. Some cloud providers charge per minute but, at least, you can rely on all of them charging per compute hour. Please be aware that, while computing costs can be quite low for small clusters, accidentally leaving a cluster running can cause significant billing expenses. Therefore, is is worth taking the extra time to check twice that your cluster is terminated when you no longer need it. It’s also a good practice to monitor costs daily while using clusters to make sure your expectations match the daily bill. From past experience, you should also plan to request compute resources in advance while dealing with large-scale projects; various cloud providers will not allow you to start a cluster with hundreds of machines before requesting them explicitly through a support request. While this can be cumbersome, it’s also a way to help you control costs in your organization. Since the cluster size is flexible, it is a good practice to start with small clusters and scale compute resources as needed. Even if you know in advance that a cluster of significant size will be required, starting small provides an opportunity to troubleshoot issues at a lower cost since it’s unlikely that your data analysis will run at scale flawlessly on the first try. As a rule of thumb, grow the instances exponentially; if you need to run a computation over an eight node cluster, start with one node and an eighth of the entire dataset, then two nodes with a fourth, then four nodes with a half the dataset and then, finally, eight nodes and the entire dataset. As you become more experienced, you’ll develop a good sense of how to troubleshoot issues, the size of the required cluster and you’ll be able to skip intermediate steps, but for starters, this is a good practice to follow. One can also use a cloud provider to acquire bare computing resources and then, install the on-premise distributions presented in the previous section yourself; for instance, you can run the Cloudera distribution on Amazon Elastic Compute Cloud (EC2). This model would avoid procuring colocated hardware, but still allow you to closely manage and customize your cluster. This book presents an overview of only the fully-managed Spark services available by cloud providers; however, you can usually find with ease instructions online on how to install on-premise distributions in the cloud. Some of the major providers of cloud computing infrastructure are: Amazon, Databricks, Google, IBM and Microsoft that this section will briefly introduce. 6.3.1 Amazon Amazon provides cloud services through Amazon Web Services(Amazon AWS); more specifically, provides an on-demand Spark cluster through Amazon Elastic MapReduce or EMR for short, Detailed instructions on using R with Amazon EMR was published under Amazon’s Big Data Blog: “Running sparklyr on Amazon EMR” (“AWS Blog” 2016), this post introduced the launch of sparklyr and instructions to configure EMR clusters with sparklyr. For instance, it suggests you can use the Amazon Command Line Interface to launch a cluster with three nodes as follows: aws emr create-cluster --applications Name=Hadoop Name=Spark Name=Hive \\ --release-label emr-5.8.0 --service-role EMR_DefaultRole --instance-groups \\ InstanceGroupType=MASTER,InstanceCount=1,InstanceType=m3.2xlarge \\ InstanceGroupType=CORE,InstanceCount=2,InstanceType=m3.2xlarge \\ --bootstrap-action Path=s3://aws-bigdata-blog/artifacts/aws-blog-emr-\\ rstudio-sparklyr/rstudio_sparklyr_emr5.sh,Args=[&quot;--user-pw&quot;, &quot;&lt;password&gt;&quot;, \\ &quot;--rstudio&quot;, &quot;--arrow&quot;] --ec2-attributes InstanceProfile=EMR_EC2_DefaultRole You can then see the cluster launching, and eventually running under the AWS portal, see Figure 6.8. FIGURE 6.8: Launching an Amazon EMR Cluster You can then navigate to the Master Public DNS and find RStudio under port 8787, for instance: ec2-12-34-567-890.us-west-1.compute.amazonaws.com:8787, and then login with user hadoop and password &lt;password&gt;. It is also possible to launch the EMR cluster using the web interface, the same introductory post contains additional details and walkthroughs specifically designed for EMR. Please remember to turn off your cluster to avoid unnecessary charges and use appropriate security restrictions when starting EMR clusters for sensitive data analysis. Regarding cost, the most up to date information can be found under aws.amazon.com/emr/pricing. As of this writing, these are some of the instance types available in the us-west-1 region, it is meant to provide a glimpse of the resources and costs associated with cloud processing. Notice that the “EMR price is in addition to the Amazon EC2 price (the price for the underlying servers)”. Instance CPUs Memory Storage EC2 Cost EMR Cost c1.medium 2 1.7GB 350GB $0.148 USD/hr $0.030 USD/hr m3.2xlarge 8 30GB 160GB $0.616 USD/hr $0.140 USD/hr i2.8xlarge 32 244GB 6400GB $7.502 USD/hr $0.270 USD/hr Note: We are only presenting a subset of the available compute instances for Amazon and subsequent cloud providers during 2019; however, please note that hardware (CPU speed, hard drive speed, etc.) varies between vendors and locations; therefore, you can’t use these hardware tables as an accurate price comparison, an accurate comparison would require running your particular workloads and considering other aspects beyond compute instance cost. 6.3.2 Databricks Databricks is a company founded by the creators of Apache Spark, that aims to help clients with cloud-based big data processing using Spark. Databricks grew out of the AMPLab project at the University of California, Berkeley. (“Databricks Wikipedia” 2018) Databricks provides enterprise-level cluster computing plans, while also providing a free/community tier to explore functionality and get familiar with their environment. Once a cluster is launched, R and sparklyr can be used from Databricks notebooks following the steps from the Getting Started chapter or, by installing RStudio on Databricks. (“Databricks Rstudio” 2018) Figure 6.9 shows a Databricks notebook using Spark through sparkylr. FIGURE 6.9: Databricks community notebook running sparklyr Additional resources are available under the Databricks Engineering Blog post: “Using sparklyr in Databricks” (“Databricks Blog” 2017) and the “Databricks Documentation for sparklyr”. (“Databricks Documentation” 2018) The latest pricing information can be found under databricks.com/product/pricing, as of this writing, available plans Plan Basic Data Engineering Data Analytics AWS Standard $0.07 USD/DBU $0.20 USD/DBU $0.40 USD/DBU Azure Standard $0.20 USD/DBU $0.40 USD/DBU Azure Premium $0.35 USD/DBU $0.55 USD/DBU Notice that pricing is based on cost of DBU/hr. From Databricks, “A Databricks Unit (DBU) is a unit of Apache Spark processing capability per hour. For a varied set of instances, DBUs are a more transparent way to view usage instead of the node-hour”. (“Databricks Units” 2018) 6.3.3 Google Google provides Google Cloud Dataproc as a cloud-based managed Spark and Hadoop service offered on Google Cloud Platform. Dataproc utilizes many Google Cloud Platform technologies such as Google Compute Engine and Google Cloud Storage to offer fully managed clusters running popular data processing frameworks such as Apache Hadoop and Apache Spark. (“Dataproc Wikipedia” 2018) A cluster can be easily created from the Google Cloud console or the Google Cloud command line interface as illustrated in Figure 6.10. FIGURE 6.10: Launching a Dataproc cluster Once created, ports can be forwarded to allow you to access this cluster from your machine; for instance, by launching Chrome to make use of this proxy and securely connect to the Dataproc cluster. Configuring this connection looks as follows: gcloud compute ssh sparklyr-m --project=&lt;project&gt; --zone=&lt;region&gt; -- -D 1080 \\ -N &quot;&lt;path to chrome&gt;&quot; --proxy-server=&quot;socks5://localhost:1080&quot; \\ --user-data-dir=&quot;/tmp/sparklyr-m&quot; http://sparklyr-m:8088 There are various tutorials available under cloud.google.com/dataproc/docs/tutorials, including, a comprehensive tutorial to configure RStudio and sparklyr. (“Dataproc Sparklyr” 2018) The latest pricing information can be found under cloud.google.com/dataproc/pricing. Notice that the cost is split between Compute Engine and a Dataproc Premium. Instance CPUs Memory Compute Engine Dataproc Premium n1-standard-1 1 3.75GB $0.0475 USD/hr $0.010 USD/hr n1-standard-8 8 30GB $0.3800 USD/hr $0.080 USD/hr n1-standard-64 64 244GB $3.0400 USD/hr $0.640 USD/hr 6.3.4 IBM IBM cloud computing is a set of cloud computing services for business offered by the information technology company IBM. IBM cloud includes infrastructure as a service (IaaS), software as a service (SaaS) and platform as a service (PaaS) offered through public, private and hybrid cloud delivery models, in addition to the components that make up those clouds. (“IBM Cloud Wikipedia” 2018) From within IBM Cloud, open Watson Studio and create a Data Science project, add a Spark cluster under the project settings and launch RStudio from the Launch IDE menu. Please note that, as of this writing, the provided version of sparklyr was not the latest version available in CRAN, since sparklyr was modified to run under the IBM Cloud. In any case, please follow IBMs documentation as an authoritative reference to run R and Spark on the IBM Cloud and particularly, on how to upgrade sparklyr appropriately. Figure 6.11 captures IBM’s Cloud portal launching a Spark cluster. FIGURE 6.11: IBM Watson Studio launching Spark with R support The most up to date pricing information is available under ibm.com/cloud/pricing. In the following table, compute cost was normalized using 31 days from the per-month costs. Instance CPUs Memory Storage Cost C1.1x1x25 1 1GB 25GB $0.033 USD/hr C1.4x4x25 4 4GB 25GB $0.133 USD/hr C1.32x32x25 32 25GB 25GB $0.962 USD/hr 6.3.5 Microsoft Microsoft Azure is a cloud computing service created by Microsoft for building, testing, deploying, and managing applications and services through a global network of Microsoft-managed data centers. It provides software as a service (SaaS), platform as a service (PaaS) and infrastructure as a service (IaaS) and supports many different programming languages, tools and frameworks, including both Microsoft-specific and third-party software and systems. (“Azure Wikipedia” 2018) From the Azure portal, the Azure HDInsight service provides support for on-demand Spark clusters. An HDInsight cluster with support for Spark and RStudio can be easily created by selecting the ML Services cluster type. Please note that the provided version of sparklyr might not be the latest version available in CRAN since the default package repo seems to be initialized using an MRAN (Microsoft R Application Network) snapshot, not directly from CRAN. Figure 6.12 shows the Azure portal launching a Spark cluster with support for R. FIGURE 6.12: Creating an Azure HDInsight Spark Cluster Up to date pricing for HDInsight is available under azure.microsoft.com/en-us/pricing/details/hdinsight. Instance CPUs Memory Total Cost D1 v2 1 3.5 GB $0.074/hour D4 v2 8 28 GB $0.59/hour G5 64 448 GB $9.298/hour 6.3.6 Qubole Qubole is a company founded in 2013 with a mission to close the data accessibility gap. Qubole delivers a Self-Service Platform for Big Data Analytics built on Amazon, Microsoft, Google and Oracle Clouds. In Qubole, you can launch Spark clusters which you can then use from Qubole notebooks or RStudio Server. Figure 6.13 shows a Qubole notebook using Spark through sparkylr. FIGURE 6.13: A Qubole cluster initialized with RStudio and sparklyr The latest pricing information can be found under qubole.com/qubole-pricing/, as of this writing the following plans are described in their pricing page: Test Drive Full-Featured Trial Enterprise Edition $0 USD $0 USD $0.14 USD/QCU Notice that pricing is based on cost of QCU/hr which stands for “Qubole Compute Unit per hour” and the “Enterprise Edition” requires an annual contract as of this writing. 6.4 Kubernetes Kubernetes is an open-source container-orchestration system for automating deployment, scaling and management of containerized applications that was originally designed by Google and now maintained by the Cloud Native Computing Foundation. Kubernetes was originally based on Docker while, like Mesos, it’s also based on Linux Cgroups. Kubernetes can execute many cluster applications and frameworks that can be highly customized by using container images with specific resources and libraries. This allows a single Kubernetes cluster to be used for many different purposes beyond data analysis, which in turn helps organizations manage their compute resources with ease. One trade off from using custom images is that they add additional configuration overhead but make kubernetes clusters extremely flexible. Nevertheless, this flexibility has proven to be instrumental to administrate with ease cluster resources in many organizations and, as shown in the overview section, it’s becoming a very popular cluster framework. Kubernetes is supported across all major cloud providers. They all provide extensive documentation as to how to launch, manage and tear down Kubernetes clusters; Figure 6.14 shows Google Gloud’s console while creating a Kubernetes cluster. Spark can be deployed over any Kubernetes cluster and R used to connect, analyze, model and so on. FIGURE 6.14: Creating a Kubernetes cluster for Spark and R using Google Cloud You can learn more about kubernetes.io, and the “Running Spark on Kubernetes” guide from spark.apache.org. Strictly speaking, Kubernetes is a cluster technology not a specific cluster architecture. However, Kubernetes represents a larger trend often referred to as a hybrid cloud. A hybrid cloud is a computing environment that makes use of on-premises and public cloud services with orchestration between the various platforms. It’s still too early to precisely categorize the leading technologies that will form a hybrid approach to cluster computing; while Kubernetes is the leading one, many more are likely to form to complement or even replace existing technologies. 6.5 Tools While using only R and Spark can be sufficient for some clusters, it is common to install complementary tools in your cluster to improve: monitoring, sql analysis, workflow coordination, etc. with applications like Ganglia, Hue and Oozie respectively. This section is not meant to cover all, but rather mention the ones that are commonly used. 6.5.1 RStudio From reading the Introduction chapter, you are aware that RStudio is a well known, free, desktop development environment for R; therefore, it is likely that you are following the examples in this book using RStudio Desktop; however, you might not be aware that RStudio can also be run as a web service inside a Spark cluster, this version of RStudio is known as RStudio Server. You can see RStudio Server running in Figure 6.15. In the same way that the Spark UI runs in the cluster, RStudio Server can be installed inside the cluster, then you can connect to RStudio Server and use RStudio in exactly the same way you use RStudio Desktop but with the ability to run code against the Spark cluster. As you can see on the following image, RStudio Server is running on a web browser inside a Spark cluster; it looks and feels just like RStudio Desktop, but adds support to run commands efficiently by being located within the cluster. FIGURE 6.15: RStudio Server Pro running inside Apache Spark For those familiar with R, Shiny is a very popular tool for building interactive web applications from R; which it is also recommended you install directly in your Spark cluster. RStudio Server and Shiny Server are a free and open source; however, RStudio also provides professional products, like: RStudio Server, RStudio Server Pro (“RStudio Server Pro” 2019), Shiny Server Pro (“Shiny Server Pro” 2019) and RStudio Connect (“RStudio Connect” 2019) which can be installed within the cluster to support additional R workflows, while sparklyr does not require any additional tools, they provide significant productivity gains worth considering. You can learn more about them at rstudio.com/products/. 6.5.2 Jupyter Project Jupyter exists to develop open-source software, open-standards, and services for interactive computing across dozens of programming languages. A Jupyter notebook, provide support for various programming languages, including R. sparklyr can be used with Jupyter notebooks using the R Kernel. Figure 6.16 shows sparklyr running inside a local Jupyter notebook. FIGURE 6.16: Jupyter notebook running sparklyr 6.5.3 Livy Apache Livy is an incubation project in Apache providing support to use Spark clusters remotely through a web interface. It is ideal to connect directly into the Spark cluster; however, there are times where connecting directly to the cluster is not feasible. When facing those constraints, one can consider installing Livy in their cluster and secure it properly to enable remote use over web protocols. However, there is a significant performance overhead from using Livy in sparklyr. To help test Livy locally, sparklyr provides support to list, install, start and stop a local Livy instance by executing livy_available_versions(): ## livy ## 1 0.2.0 ## 2 0.3.0 ## 3 0.4.0 ## 4 0.5.0 Which lists the versions that you can install, we recommend installing the latest version and verifying the installed version as follows # Install default Livy version livy_install() # List installed Livy services livy_installed_versions() # Start the Livy service livy_service_start() You can then navigate to this local Livy session under http://localhost:8998, the Connections chapter will detail how to connect through Livy; once connected, you can navigate to the Livy web application as captured by Figure 6.17. FIGURE 6.17: Apache Livy running as a local service Make sure you also stop the Livy service when working with local Livy instances, for proper Livy services running in a cluster, you won’t have to. # Stops the Livy service livy_service_stop() 6.6 Recap This chapter explained the history and tradeoffs of on-premise, cloud computing and presented Kubernetes as a promising framework to provide flexibility across on-premise and cloud providers. It also introduced cluster managers (Spark Standalone, YARN, Mesos and Kubernetes) as the software needed to run Spark as a cluster application. This chapter briefly mentioned on-premise cluster providers like Cloudera, Hortonworks and MapR as well as the major cloud providers: Amazon, Google and Microsoft. While this chapter provided a solid foundation to understand current cluster computing trends, tools and providers useful to perform data science at scale; it did not provide a comprehensive framework to decide which cluster technologies to choose. Instead, use this chapter as an overview and a starting point to reach out to additional resources to help you find the cluster stack that best fits your organization needs. The next chapter, connections, will focus on understanding how to connect to existing clusters; therefore, it assumes a Spark cluster like the ones presented in this chapter, is already available to you. References "],
["connections.html", "Chapter 7 Connections 7.1 Overview 7.2 Local 7.3 Standalone 7.4 Yarn 7.5 Livy 7.6 Mesos 7.7 Kubernetes 7.8 Cloud 7.9 Batches 7.10 Tools 7.11 Multiple 7.12 Troubleshooting 7.13 Recap", " Chapter 7 Connections “They don’t get to choose.” — Daenerys Targaryen The previous chapter, Clusters, presented the major cluster computing trends, cluster managers, distributions and cloud service providers to help you choose the Spark cluster that best suits your needs. In contrast, this chapter presents the internal components of a Spark cluster and how to connect to a particular Spark cluster. When reading this chapter, don’t try to execute every line of code; this would be quite hard since you would have to prepare different Spark environments. Instead, if you already have a Spark cluster or if the previous chapter get you motivated enough to sign-up for an on-demand cluster; now is the time to learn how to connect to it. This chapter will help you connect to your cluster, which you should have already chosen by now. Without a cluster, we recommend you learn the concepts and come back to execute code later on. In addition, this chapter provides various troubleshooting connection techniques. While we hope you won’t need to use them, this chapter will prepare you to use them as effective techniques to resolve connectivity issues. While this chapter might feel a bit dry – connecting and troubleshooting connections is definitely not the most exciting part of large-scale computing – it will introduce the components of a Spark cluster and how they interact, often known as the architecture of Apache Spark. This chapter, in addition to the Data and Tuning chapters, will provide a detailed view of how Spark works, which will help you move towards becoming an intermediate Spark user that can truly understand the exciting world of distributed computing, using Apache Spark. 7.1 Overview The overall connection architecture for a Spark cluster is composed of three types of compute instances: the driver node, the worker nodes and the cluster manager. A cluster manager is a service that allows Spark to be executed in the cluster, this was detailed in the previous chapter under the cluster managers section. The worker nodes (also referred to as executors) execute compute tasks over partitioned data and communicate intermediate results to other workers or back to the driver node. The driver node is tasked with delegating work to the worker nodes, but also for aggregating their results and controlling computation flow. For the most part, aggregation happens in the worker nodes; however, even after the nodes aggregate data, it is often the case that the driver node would have to collect the worker’s results. Therefore, the driver node usually has at least, but often much more, compute resources (memory, CPUs, local storage, etc.) than the worker node. Strictly speaking, the driver node and worker nodes are just names assigned to machines with particular roles, while the actual computation in the driver node is performed by the spark context. The Spark context is the main entry point for Spark functionality (“Azure Wikipedia” 2019) since it’s tasked with scheduling tasks, managing storage, tracking execution status, access configuration settings, canceling jobs and so on. In the worker nodes, the actual computation is performed under a spark executor, which is a Spark component tasked with executing subtasks against specific data partition. We can illustrate this concept in Figure 7.1, where the driver node orchestrates worker’s work through the cluster manager. FIGURE 7.1: Apache Spark Architecture If you already have a Spark cluster in your organization, you should request the connection information to this cluster from your cluster administrator, read their usage policies carefully and follow their advice. Since a cluster may be shared among many users, you want to make sure you only request the compute resources you need – we will cover how to request resources in the Tuning chapter. Your system administrator will describe if it’s an on-premise vs cloud cluster, the cluster manager being used, supported connections and supported tools. You can use this information to jump directly to Local, Standalone, YARN, Mesos, Livy or Kubernetes based on the information provided to you. Note: Once connected is performed with spark_connect(), you can use all the techniques described in previous chapters using the sc connection; for instance, you can do data analysis or modeling with the same code previous chapters presented. 7.1.1 Edge Nodes Computing clusters are configured to enable high-bandwidth and fast network connectivity between nodes. To optimize network connectivity, the nodes in the cluster are configured to trust each other and to disable security features. This improves performance but requires the cluster to be secured by closing all external network communication, making the entire cluster secure as a whole. Except for a few cluster machines that are carefully configured to accept connections from outside the cluster; conceptually, these machines are located in the “edge” of the cluster and are known as edge nodes. Therefore, before connecting to Apache Spark, it is likely you will first have to connect to an edge node in your cluster. There are two methods to connect: Terminal Using a computer terminal application, one can use a secure shell to establish a remote connection into the cluster, once you connect into the cluster, you can launch R and then use sparklyr. However, a terminal can be cumbersome for some tasks, like exploratory data analysis, so it’s often only used while configuring the cluster or troubleshooting issues. Web Browser While using sparklyr from a terminal is possible, it is usually more productive to install a web server in an edge node that provides access to run R with sparklyr from a web browser. Most likely, you will want to consider using RStudio or Jupyter rather than connecting from the terminal. Figure 7.2 explains these concepts visually. The left block is usually your web browser, the right block is the edge node, client and edge nodes communicate over HTTP when using a web browser or SSH when using the terminal. FIGURE 7.2: Connecting to Sparks Edge Node 7.1.2 Spark Home After you connect to an edge node, the next step is to find out where Spark is installed, this location is known as the SPARK_HOME. In most cases, your cluster administrator will have already set the SPARK_HOME environment variable to the correct installation path. If not, you will need to find out the correct SPARK_HOME path. The SPARK_HOME path must be specified as an environment variable or explicitly when running spark_connect() using the spark_home parameter. If your cluster provider or cluster administrator already provided SPARK_HOME for you, the following code should return a path instead of an empty string. Sys.getenv(&quot;SPARK_HOME&quot;) If the code above returns an empty string, this would mean the SPARK_HOME environment variable is not set in your cluster, so you will have to specify SPARK_HOME while using spark_connect() as follows: sc &lt;- spark_connect(master = &quot;&lt;master&gt;&quot;, spark_home = &quot;local/path/to/spark&quot;) Where &lt;master&gt; is set to the correct cluster manager master for Spark Standalone, YARN, Mesos, Kubernetes or Livy. 7.2 Local When connecting to Spark in local mode, Spark starts a single process which runs most of the cluster components like the Spark context and a single executor. This is ideal to learn Spark, work offline, troubleshoot issues or to test code before you run it over a large compute cluster. A local connection to Spark is represented in Figure 7.3. FIGURE 7.3: Local Connection Diagram Notice that in the local connections diagram, there is no cluster manager nor worker process since, in local mode, everything runs inside the driver application. It’s also worth noting that sparklyr starts the Spark Context through spark-submit, a script available in every Spark installation to enable users to submit custom application to Spark which, sparklyr makes use of to submit itself to Spark. For the curious reader, the Contributing chapter explains the internal processes that takes place in sparklyr to submit this application and connect properly from R. To perform this local connection, we can connect with the following familiar code used in previous chapters: # Connect to local Spark instance sc &lt;- spark_connect(master = &quot;local&quot;) 7.3 Standalone Connecting to a Spark Standalone cluster requires the location of the cluster manager’s master instance, which can be found in the cluster manager web interface as described in the Standalone Clusters section. You can find this location by looking for a URL starting with spark://. A connection in standalone mode starts from sparklyr, which launches spark-submit, which then submits the sparklyr application, and creates the Spark Context, which requests executors from the Spark Standalone instance running under the given master address. Visually, this is described in Figure 7.4, which is quite similar to the overall connection architecture from Figure 7.1 but, with additional details that are particular to standalone clusters and sparklyr. FIGURE 7.4: Spark Standalone Connection Diagram In order to connect, use master = \"spark://hostname:port\" in spark_connect() as follows: sc &lt;- spark_connect(master = &quot;spark://hostname:port&quot;) 7.4 Yarn Hadoop YARN is the cluster manager from the Hadoop project, it’s the most common cluster manager which you are likely to find in clusters that started out as Hadoop clusters; with Cloudera, Hortonworks and MapR distributions as when using Amazon EMR. YARN supports two connection modes: YARN Client and YARN Cluster. However, YARN Client mode is much more common that YARN Cluster since it’s more efficient and easier to set up. 7.4.1 Yarn Client When connecting in YARN Client mode, the driver instance runs R, sparklyr and the Spark Context which requests worker nodes from YARN to run Spark executors as shown in Figure 7.5. FIGURE 7.5: YARN Client Connection Diagram To connect, one can simply run with master = \"yarn\" as follows: sc &lt;- spark_connect(master = &quot;yarn&quot;) Behind the scenes, when running YARN in client mode, the cluster manager will do what you would expect a cluster manager would do; it will allocate resources from the cluster and assign them to your Spark application, which the Spark Context will manage for you. The important piece to notice in Figure ?? is that, the Spark Context resides in the same machine where you run R code, this is different when running YARN in cluster mode. 7.4.2 Yarn Cluster The main difference between YARN in cluster mode and running YARN in client mode is that, in cluster mode, the driver node is not required to be the node where R and sparklyr were launched; instead, the driver node remains the designated driver node which is usually a different node than the edge node where R is running. It can be helpful to consider using cluster mode when the edge node has too many concurrent users, when is lacking computing resources, or where tools (like RStudio or Jupyter) need to be managed independently of other cluster resources. Figure 7.6 shows how the different components become decoupled when running in cluster mode. Notice there is still a line connecting the client with the cluster manager since, first of all, resources still need to be allocated from the cluster manager; however, once allocated, the client communicates directly with the driver node which will then communicate with the worker nodes. From this diagram, you might think that cluster mode looks much more complicated than the client mode diagram – this would be a correct assessment; therefore, it’s best to avoid cluster mode when possible due to additional configuration overhead that is best to avoid, if possible. FIGURE 7.6: YARN Cluster Connection Diagram To connect in YARN Cluster mode, we can simply run: sc &lt;- spark_connect(master = &quot;yarn-cluster&quot;) Cluster mode assumes that the node running spark_connect() is properly configured, meaning that, yarn-site.xml exists and the YARN_CONF_DIR environment variable is properly set. When using Hadoop as a file system, you will also need the HADOOP_CONF_DIR environment variable properly configured. In addition, you would need to have proper network connectivity between the client and the driver node, not just with sufficient bandwidth but also making sure both machines are reachable and no intermediate. This configuration is usually provided by your system administrator and is not something that you would have to manually configure. 7.5 Livy As opposed to other connection methods which require using an edge node in the cluster, Livy provides a Web API that makes the Spark cluster accessible from outside the cluster and does not require a Spark installation in the client. Once connected through the Web API, the Livy Service starts the Spark context by requesting resources from the cluster manager and distributing work as usual. Figure 7.7 illustrates a Livy connection, notice that the client connects remotely to the driver through a web API. FIGURE 7.7: Livy Connection Diagram Connecting through Livy requires the URL to the Livy service which should be similar to https://hostname:port/livy. Since remote connections are allowed, connections usually requires, at the very least, basic authentication: sc &lt;- spark_connect( master = &quot;https://hostname:port/livy&quot;, method = &quot;livy&quot;, config = livy_config( spark_version = &quot;2.4.0&quot;, username = &quot;&lt;username&gt;&quot;, password = &quot;&lt;password&gt;&quot; )) To try out Livy in your local machine, you can install and run a Livy service as described under the Livy Clusters section and then, connect as follows: sc &lt;- spark_connect( master = &quot;http://localhost:8998&quot;, method = &quot;livy&quot;, version = &quot;2.4.0&quot;) Once connected through Livy, you can make use of any sparklyr feature; however, Livy is not suitable for exploratory data analysis, since executing commands has a significant performance cost. That said, while running long running computations, this overhead could be considered irrelevant. In general, it is preferred to avoid using Livy and work directly within an edge node in the cluster; when this is not feasible, using Livy could be a reasonable approach. Note: Specifying the Spark version through the spark_version parameter is optional; however, when the version is specified, performance is significantly improved by deploying precompiled Java binaries compatible with the given version. Therefore, it is a best practice to specify the Spark version when connecting to Spark using Livy. 7.6 Mesos Similar to YARN, Mesos supports client mode and a cluster mode; however – sparklyr currently only supports client mode under Mesos. Therefore, the diagram from Figure 7.8, is equivalent to YARN Client’s diagram with only the cluster manager changed from YARN to Mesos. FIGURE 7.8: Mesos Connection Diagram Connecting requires the address to the Mesos master node, usually in the form of mesos://host:port or mesos://zk://host1:2181,host2:2181,host3:2181/mesos for Mesos using ZooKeeper. sc &lt;- spark_connect(master = &quot;mesos://host:port&quot;) The MESOS_NATIVE_JAVA_LIBRARY environment variable needs to be set by your system administrator, or manually set when running mesos on your local machine. For instance, in OS X, you can install and initialize Mesos from a terminal, followed by manually setting the mesos library and connecting with spark_connect(): brew install mesos /usr/local/Cellar/mesos/1.6.1/sbin/mesos-master --registry=in_memory --ip=127.0.0.1 MESOS_WORK_DIR=. /usr/local/Cellar/mesos/1.6.1/sbin/mesos-slave --master=127.0.0.1:5050 Sys.setenv(MESOS_NATIVE_JAVA_LIBRARY = &quot;/usr/local/Cellar/mesos/1.6.1/lib/libmesos.dylib&quot;) sc &lt;- spark_connect(master = &quot;mesos://localhost:5050&quot;, spark_home = spark_home_dir()) 7.7 Kubernetes Kubernetes cluster do not support client modes like Mesos or YARN; instead, the connection model is similar to YARN Cluster, where the driver node is assigned by Kubernetes. This is illustrated in Figure 7.9. FIGURE 7.9: Kubernetes Connection Diagram To use Kubernetes, you will need to prepare a virtual machine with Spark installed and properly configured; however, it is beyond the scope of this book to present how to create one. Once created, connecting to Kubernetes works as follows: library(sparklyr) sc &lt;- spark_connect(config = spark_config_kubernetes( &quot;k8s://https://&lt;apiserver-host&gt;:&lt;apiserver-port&gt;&quot;, account = &quot;default&quot;, image = &quot;docker.io/owner/repo:version&quot;, version = &quot;2.3.1&quot;)) If your computer is already configured to use a Kubernetes cluster, you can use the following command to find the apiserver-host and apiserver-port: system2(&quot;kubectl&quot;, &quot;cluster-info&quot;) 7.8 Cloud When working with cloud providers, there are a few connection differences. For instance, connecting from Databricks requires the following connection method: sc &lt;- spark_connect(method = &quot;databricks&quot;) Since Amazon EMR makes use of YARN, you can connect using master = \"yarn\": sc &lt;- spark_connect(master = &quot;yarn&quot;) Connections to Spark when using IBM’s Watson Studio requires you to retrieve a configuration object through a load_spark_kernels() function IBM provides: kernels &lt;- load_spark_kernels() sc &lt;- spark_connect(config = kernels[2]) Under Microsoft Azure HDInsights and when using ML Services (R Server), a Spark connection gets initialized through: library(RevoScaleR) cc &lt;- rxSparkConnect(reset = TRUE, interop = &quot;sparklyr&quot;) sc &lt;- rxGetSparklyrConnection(cc) Connecting from Qubole requires using the qubole connection method: sc &lt;- spark_connect(method = &quot;qubole&quot;) Please reference your cloud provider documentation and their support channels if assistance is needed. 7.9 Batches Most of the time, sparklyr used interactively; as in, you explicitly connect with spark_connect() and then execute commands to analyze and model large-scale data. However, you can also automate processes by scheduling Spark jobs that use sparklyr. Spark does not provide tools to schedule data processing tasks; so instead, you would use other workflow management tools. This can be useful useful to transform data, prepare a model and score data overnight or to make use of Spark by other systems. As an example, you can create a file named batch.R with contents: library(sparklyr) sc &lt;- spark_connect(master = &quot;local&quot;) sdf_len(sc, 10) %&gt;% spark_write_csv(&quot;batch.csv&quot;) spark_disconnect(sc) You can then submit this application to Spark in batch mode using spark_submit(), the master parameter should be set to the appropriately. spark_submit(master = &quot;local&quot;, &quot;batch.R&quot;) You can also invoke spark-submit from the shell directly through: /spark-home-path/spark-submit --class sparklyr.Shell &#39;/spark-jars-path/sparklyr-2.3-2.11.jar&#39; 8880 12345 --batch /path/to/batch.R The last parameters represent the port number 8880 and the session number, 12345, which can be set to any unique numeric identifier. You can use the following R code to get the correct paths: # Retrieve spark-home-path spark_home_dir() # Retrieve spark-jars-path system.file(&quot;java&quot;, package = &quot;sparklyr&quot;) You can customize your script by passing additional command line arguments to spark-submit and then reading them back in R using commandArgs() 7.10 Tools When connecting to a Spark Cluster using tools like Jupyter and RStudio, you can run the same connection parameters presented in this chapter. However, since many cloud providers make use of a web proxy to secure Spark’s web interface, in order to use spark_web() or the RStudio connections pane extension, you will need to properly configure the sparklyr.web.spark setting which you would then pass to spark_config() through the config parameter. For instance, when using Amazon EMR, you can configure sparklyr.web.spark and sparklyr.web.yarn by dynamically retrieving the YARN application and building the EMR proxy URL: domain &lt;- &quot;http://ec2-12-345-678-9.us-west-2.compute.amazonaws.com&quot; config &lt;- spark_config() config$sparklyr.web.spark &lt;- ~paste0( domain, &quot;:20888/proxy/&quot;, invoke(spark_context(sc), &quot;applicationId&quot;)) config$sparklyr.web.yarn &lt;- paste0(domain, &quot;:8088&quot;) sc &lt;- spark_connect(master = &quot;yarn&quot;, config = config) 7.11 Multiple It is common to connect once, and only once, to Spark. However, you can also open multiple connections to Spark by connecting to different clusters or by specifying the app_name parameter. This can be helpful to compare Spark versions or validate your analysis before submitting to the cluster. The following example opens connections to Spark 1.6.3, 2.3.0 and Spark Standalone: # Connect to local Spark 1.6.3 sc_16 &lt;- spark_connect(master = &quot;local&quot;, version = &quot;1.6&quot;) # Connect to local Spark 2.3.0 sc_23 &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;, appName = &quot;Spark23&quot;) # Connect to local Spark Standalone sc_standalone &lt;- spark_connect(master = &quot;spark://host:port&quot;) Finally, we can disconnect from each connection: spark_disconnect(sc_1_6_3) spark_disconnect(sc_2_3_0) spark_disconnect(sc_standalone) Alternatively, you can disconnect from all connections at once: spark_disconnect_all() 7.12 Troubleshooting Last but not least, we will introduce the following troubleshooting techniques: Logging, Spark Submit and Windows. When in doubt of where to start, start with the Windows section when using Windows systems, followed by Logging and closing with Spark Submit. This techniques are useful when running spark_connect() fails with an error message. 7.12.1 Logging The first technique to troubleshoot connections is to print Spark logs directly to the console to help you spot additional error messages: sc &lt;- spark_connect(master = &quot;local&quot;, log = &quot;console&quot;) In addition, you can enable verbose logging by setting the sparklyr.verbose option when connecting: sc &lt;- spark_connect(master = &quot;local&quot;, log = &quot;console&quot;, config = list(sparklyr.verbose = TRUE)) 7.12.2 Spark Submit You can diagnose if a connection issue is specific to R or Spark in general. This can be accomplished by running an example job through spark-submit and validating that no errors are thrown: # Find the spark directory using an environment variable spark_home &lt;- Sys.getenv(&quot;SPARK_HOME&quot;) # Or by getting the local spark installation spark_home &lt;- sparklyr::spark_home_dir() Then execute the sample compute Pi example by replacing \"local\" with the correct master parameter you are troubleshooting: # Launching a sample application to compute Pi system2( file.path(spark_home, &quot;bin&quot;, &quot;spark-submit&quot;), c( &quot;--master&quot;, &quot;local&quot;, &quot;--class&quot;, &quot;org.apache.spark.examples.SparkPi&quot;, dir(file.path(spark_home, &quot;examples&quot;, &quot;jars&quot;), pattern = &quot;spark-examples&quot;, full.names = TRUE), 100), stderr = FALSE ) Pi is roughly 3.1415503141550314 If the above message is not displayed, you will have to investigate why your Spark cluster is not properly configured, which is beyond the scope of this book. As a start, rerun the Pi example but remove stderr = FALSE, this will print errors to the console which you can then use to investigate what the problem might be. When using a cloud provider or a Spark distribution, you can contact their support team to help you troubleshoot this further; otherwise, StackOverflow is a good place to start. If you do see the message above, this means your Spark cluster is properly configured but somehow, R is not being able to use Spark, so you will have to troubleshoot in-detail as we will explain next. 7.12.2.1 Detailed To troubleshoot the connection process in detail, you can manually replicate the two-step connection process, which is often very helpful to diagnose connection issues. Connecting to Spark is performed in two steps; first, spark-submit is triggered from R which submits the application to Spark, second, R connects to the running Spark application. First, identify the Spark installation directory and the path to the correct sparklyr*.jar by running: dir(system.file(&quot;java&quot;, package = &quot;sparklyr&quot;), pattern = &quot;sparklyr&quot;, full.names = T) Make sure you identify the correct version that matches your Spark cluster, for instance sparklyr-2.1-2.11.jar for Spark 2.1. Then, from the terminal, run: $SPARK_HOME/bin/spark-submit --class sparklyr.Shell $PATH_TO_SPARKLYR_JAR 8880 42 18/06/11 12:13:53 INFO sparklyr: Session (42) found port 8880 is available 18/06/11 12:13:53 INFO sparklyr: Gateway (42) is waiting for sparklyr client to connect to port 8880 The parameter 8880 represents the default port to use in sparklyr while 42 the session number, this is a cryptographically secure number generated bysparklyr, but for troubleshooting purposes can be as simple as42`. If this first connection step fails, it means that the cluster can’t accept the application. This usually means that there are not enough resources, there are permission restrictions, etc. The second step is to connect from R as follows – notice that there is a 60 seconds timeout, so you’ll have to run the R command after running the terminal command. If needed, this timeout can be configured as described in the Tuning chapter. library(sparklyr) sc &lt;- spark_connect(master = &quot;sparklyr://localhost:8880/42&quot;, version = &quot;2.3&quot;) If this second connection step fails, it usually means that there is a connectivity problem between R and the driver node. You can try using a different connection port, for instance. 7.12.3 Windows Connecting from Windows is, in most cases, as straightforward as connecting from Linux and OS X. However, there are a few common connection issues you should be aware of: Firewalls and antivirus software might block ports for your connection. The default port used by sparklyr is 8880; double check this port is not being blocked. Long path names can cause issues, especially in older Windows systems like Windows 7. When using these systems, try connecting with Spark installed with all folders using at most eight characters and no spaces in their names. 7.13 Recap This chapter presented an overview of Spark’s architecture, connection concepts and examples to connect in local mode, standalone, YARN, Mesos, Kubernetes and Livy. It also presented edge nodes and their role while connecting to Spark clusters. This should have provided you with enough information to successfully connect to any Apache Spark cluster. To troubleshoot connection problems beyond the techniques described in this chapter, it is recommended to search for the connection problem in StackOverflow, the sparklyr GitHub issues and, if needed, open a new GitHub issue in sparklyr to assist further. In the next chapter, Data, we will cover how to user Spark to read and write from a variety of data sources and formats which allows you to be more agile when adding new data sources for data analysis – what used to take days, weeks or even months, can now be completed in hours by embracing data lakes. References "],
["data.html", "Chapter 8 Data 8.1 Overview 8.2 Read 8.3 Write 8.4 Copy 8.5 File Formats 8.6 File Systems 8.7 Storage Systems 8.8 Recap", " Chapter 8 Data “Has it occurred to you that she might not have been a reliable source of information?” — Jon Snow The previous chapter, Connections, presented how to connect to Spark clusters, either on-premise or in the cloud; with previous knowledge acquired in previous chapters, you are now equipped to start doing analysis and modeling at scale! However, so far we haven’t really explained much about how to read data into Spark, we’ve used copy_to() to upload small datasets or functions like spark_read_csv() or spark_write_csv() without explaining in detail how and why. So, we are about to learn how to read and write data using Spark; while this is important on it’s own, this chapter will also introduce you to data lakes – a repository of data stored in its natural or raw format which provides various benefits over existing storage architectures. For instance, you can easily integrate data from external systems without transforming into a common format and without assuming they are as reliable as your internal data sources. In addition, we will also present how to extend Spark’s capabilities to work with data not accessible out-of-the-box and several recommendations focused on improving performance for reading and writing data. Reading large datasets often requires you to fine-tune your Spark cluster configuration, but this will be the topic of the next chapter, Tuning. 8.1 Overview In the Introduction chapter, you learned that beyond big data and big compute, you can also use Spark to improve velocity, variety and veracity in data tasks. While you can use the learnings of this chapter for any task requiring loading and storing data, it is particularly interesting to present this chapter in the context of dealing with a variety of data sources. To understand why, we should first take a quick detour understanding how data is currently processed in many organizations. For several years, it’s been a common practice to store large datasets in a relational database, a system first proposed in 1970 by Edgar F. Codd. (Codd 1970) You can think of a database as a collection of tables that are related to one another where each table is carefully designed to hold specific data types and relationships to other tables. Most relational database systems use SQL (Structured Query Language) for querying and maintaining the database. Databases are still widely used today, with good reason – Databases store data reliably and consistently, your bank probably stores account balances in a database and that’s a good practice! However, databases have also been used to store information from other applications and systems. For instance, your bank may also store data produced by other banks, say incoming checks. In order to accomplish this, the external data needs to be extracted from the external system, transformed into something that fits the current database and finally load it. This is known as ETL (extract-transform-load), a general procedure of copying data from one or more sources into a destination system which represents the data differently from the source, this process became popular in the 1970s. Aside from databases, data is often also loaded into a data warehouse, a system used for reporting and data analysis; usually stored and indexed in a format that increases data analysis speed, but which is often not suitable for modeling or running custom distributed code. The challenge is that, changing databases and data warehouses is usually a long and delicate process since data needs to be re-indexed and the data from multiple data sources needs to be carefully transformed into single tables that can share across data sources. Instead of trying to transform all data sources into a common format, you can embrace this variety of data sources in a data lake – a system or repository of data stored in its natural format, see Figure ??. Since data lakes make data available in its original format, there is no need to carefully transform it in advance, anyone can use it for analysis which adds significant flexibility over ETL. Spark can then be used to unify data processing from data lakes, databases and data warehouses through a single interface that is scalable across all of them. Some organizations also use Spark to replace their existing ETL process; however, this falls in the realm of data engineering which is well beyond the scope of this book, we illustrate this with dotted lines in Figure ??. In order to support a broad variety of data source, Spark needs to be able to read and write data in several different file formats (CSV, JSON, Parquet, etc), access them while stored in several file systems (HDFS, S3, DBFS, etc) and, potentially, interoperate with other storage systems (databases, data warehouses, etc). We will get to all of that; but first, we will start by presenting how to read, write and copy data using Spark. 8.2 Read If you are new to Spark, it is highly recommended to review this section before you start working with large datasets. We will introduce several techniques that improve the speed and efficiency of reading data. Each subsection will present specific ways to take advantage of how Spark reads files, such as the ability to treat entire folders as datasets, as well as being able to describe them to read datasets faster in Spark. 8.2.1 Paths When analyzing data, loading multiple files into a single data object is a common scenario. In R, we typically use a loop or a functional programming directive to accomplish this. That is because R has to load each file individually into your R session. Let’s create a few CSV files inside a folder and read them with R first, letters &lt;- data.frame(x = letters, y = 1:length(letters)) dir.create(&quot;data-csv&quot;) write.csv(letters[1:3, ], &quot;data-csv/letters1.csv&quot;, row.names = FALSE) write.csv(letters[1:3, ], &quot;data-csv/letters2.csv&quot;, row.names = FALSE) do.call(&quot;rbind&quot;, lapply(dir(&quot;data-csv&quot;, full.names = TRUE), read.csv)) x y 1 a 1 2 b 2 3 c 3 4 a 1 5 b 2 6 c 3 In Spark, there is the notion of a folder as a dataset. Instead of enumerating each file, simply pass the path containing all the files. Spark assumes that every file in that folder is part of the same dataset. This implies that the target folder should only be used for data purposes. This is specially important since storage systems like HDFS, store files across multiple machines but conceptually, they are stored in the same folder; when Spark reads the files from this folder, is actually executing distributed code to read each file inside each machine – no data is transferred between machines when distributed files are read! library(sparklyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) spark_read_csv(sc, &quot;data-csv/&quot;) # Source: spark&lt;datacsv&gt; [?? x 2] x y &lt;chr&gt; &lt;int&gt; 1 a 1 2 b 2 3 c 3 4 d 4 5 e 5 6 a 1 7 b 2 8 c 3 9 d 4 10 e 5 The “folder as a table” idea is found in other open source technologies as well. Under the hood, Hive tables work the same way. When querying a Hive table, the mapping is done over multiple files inside the same folder. The folder’s name usually match the name of the table visible to the user. Next we will present a technique that allows Spark to read file faster, as well as to reduce read failures, by describing the structure of a dataset in advance. 8.2.2 Schema When reading data, Spark is able to determine the data source’s column names and column types, also known as the schema. However, guessing the schema comes at a cost; Spark has to do an initial pass on the data to guess what it is. For large dataset, this may add a significant amount of time to the data ingestion process, which can become costly even for medium size datasets. For files that are read over and over again, the additional read time accumulates over time. To avoid this, Spark allows you to provide a column definition by providing a columns argument to describe your dataset. You can create this schema by sampling a small portion of the original file yourself, spec_with_r &lt;- sapply(read.csv(&quot;data-csv/letters1.csv&quot;, nrows = 10), class) spec_with_r x y &quot;factor&quot; &quot;integer&quot; Or you can set the column specification to a vector containing the column types explicitly. The vector’s values are named to match the field names. spec_explicit &lt;- c(x = &quot;character&quot;, y = &quot;numeric&quot;) spec_explicit x y &quot;character&quot; &quot;numeric&quot; The accepted variable types are: integer, character, logical, double, numeric, factor, Date and POSIXct. Then, when reading using spark_read_csv(), you can pass col_spec_1 to the columns argument to match the names and types of the original file. This helps improve performance since Spark will not have to figure out the column types. spark_read_csv(sc, &quot;data-csv/&quot;, columns = spec_with_r) # Source: spark&lt;datacsv&gt; [?? x 2] x y &lt;chr&gt; &lt;int&gt; 1 a 1 2 b 2 3 c 3 4 a 1 5 b 2 6 c 3 The following example shows how to set the field type to something different. However, the new field type needs to be a compatible type in the original dataset. For example, a character field can not be set to numeric. If an incompatible type is used, the file read will fail with an error. Additionally, the following example also changes the names of the original fields. spec_compatible &lt;- c(my_letter = &quot;character&quot;, my_number = &quot;character&quot;) spark_read_csv(sc, &quot;data-csv/&quot;, columns = spec_compatible) # Source: spark&lt;datacsv&gt; [?? x 2] my_letter my_number &lt;chr&gt; &lt;chr&gt; 1 a 1 2 b 2 3 c 3 4 a 1 5 b 2 6 c 3 In Spark, malformed entries can cause errors during reading, specially for non-character fields. To prevent such errors, we can use a file spec that imports them as character, and then use dplyr to coerce the field into the desired type. This subsection reviewed how we can read files faster and with less failures, which lets us start our analysis quicker. Another way to accelerate our analysis, is by loading less data into Spark memory, the next subsection will cover how to do this. 8.2.3 Memory By default, when using Spark with R, when you read data is copied into Sparks distributed memory – making data analysis and other operations very fast. There are cases, such as when the data is too big, where loading all the data may not be practical, or even necessary. For those cases, Spark can then just “map” the files without copying data into memory. The mapping creates a sort of “virtual” table in Spark. The implication is that when a query runs against that table, Spark has to read the data from the files at that time. Any consecutive reads after that will do the same. In effect, Spark becomes a pass-through for the data. The advantage of this method is that there is almost no up-front time cost to “reading” the file, the mapping is very fast. The downside is that running queries that actually extract data will take longer. This is controlled by the memory argument of the read functions. Setting it to FALSE prevents the data copy. It defaults to TRUE. mapped_csv &lt;- spark_read_csv(sc, &quot;data-csv/&quot;, memory = FALSE) There are good use cases for this method, one of them is when not all columns of a table are needed. For example, take a very large file that contains many columns, assuming this is not the first time you interact with this data, you would know what columns are needed for the analysis. When know which columns you need, the files can be read using memory = FALSE, and then select the needed columns with dplyr. The resulting dplyr variable can then be cached into memory, using the compute() function. This will make Spark query the file(s), pull the selected fields, and copy only that data into memory. The result is a in-memory table that took comparatively less time to ingest. mapped_csv %&gt;% dplyr::select(y) %&gt;% dplyr::compute(&quot;test&quot;) The next subsection covers a short technique to make it easier to carry the original field names of imported data. 8.2.4 Columns Spark 1.6 required that column names be sanitized, so R does that by default. There may be cases when you would like to keep the original names intact, and are also working with Spark version 2.0 or above. To do that set the sparklyr.sanitize.column.names option to FALSE. options(sparklyr.sanitize.column.names = FALSE) copy_to(sc, iris, overwrite = TRUE) # Source: table&lt;iris&gt; [?? x 5] # Database: spark_connection Sepal.Length Sepal.Width Petal.Length Petal.Width Species &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa 7 4.6 3.4 1.4 0.3 setosa 8 5 3.4 1.5 0.2 setosa 9 4.4 2.9 1.4 0.2 setosa 10 4.9 3.1 1.5 0.1 setosa # ... with more rows After reviewing how to read data into Spark in this section, the next section will cover how we can write data from our Spark session. 8.3 Write Some projects require that new data generated in Spark to be written back to a remote source. For example, the data could be new predicted values returned by a Spark model. The job processes the mass generation of predictions, but then the predictions need to be stored. This section will focus on how we should use Spark for moving the data from Spark into an external destination. Many new users start by downloading Spark data into R, to then upload it to a target. Figure 8.1 illustrates this approach. It works for smaller data sets, but it becomes inefficient for larger ones. The data typically grows in size to the point that it is no longer feasible for R to be the middle point. FIGURE 8.1: Incorrect use of Spark when writing large datasets All efforts should be made to have Spark connect to the target location. This way, reading, processing and writing happens within the same Spark session. As Figure 8.2 shows, a better approach is to use Spark to read, process, and write to the target. This approach is able to scale as big as the Spark cluster allows, and prevents using R as a choke point. FIGURE 8.2: Correct use of Spark when writing large datasets Consider the following scenario: A Spark job just processed predictions for a large data set, resulting in a considerably amount of predictions. Choosing a method to write results will depend on the technology infrastructure you are working on. More specifically, it will depend on Spark and the target running, or not, in the same cluster. Back to our scenario, we have a large dataset in Spark that needs to be saved. When Spark and the target are in the same cluster, copying the results is not a problem, the data transfer is between RAM and disk of the same cluster or efficiently shuffled through a high-bandwidth connection. But what to do if the target is not within the Spark cluster? There are two options, choosing one will depend on the size of the data, and network speed: Spark Transfer In this case, Spark connects to the remote target location, and copies the new data. If this is done within the same Data Center, or cloud provider, the data transfer could be fast enough to have Spark write the data directly. External Transfer Otherwise, Spark can write the results to disk, and transfers them via a third-party application. Spark writes the results as files, and then a separate job copies the files over. In the target location, you would use a separate process to transfer the data into the target location. It is best to recognize that Spark, R, and any other technology are tools. No tool can do everything, nor should be expected to. Next we will describe how to copy data into Spark or collect large datasets that don’t fit in-memory, this can be used to transfer data across clusters, or help initialize your distributed datasets. 8.4 Copy Previous chapters used copy_to() as a handy helper to copy data into Spark; however, copy_to() can only be used to transfer in-memory datasets that are already loaded in memory; this dataset tend to be much smaller than the kind of datasets you would want to copy into Spark. For instance, suppose that we have a 3GB dataset generated as follows, dir.create(&quot;largefile.txt&quot;) write.table(matrix(rnorm(10 * 10^6), ncol = 10), &quot;largefile.txt/1&quot;, append = T, col.names = F, row.names = F) for (i in 2:30) file.copy(&quot;largefile.txt/1&quot;, paste(&quot;largefile.txt/&quot;, i)) If we only had 2GB of memory in the driver node, we would not be able to load this 3GB file into memory using copy_to(). Instead, when using the Hadoop file system as storage in your cluster, you can use the hadoop command line tool to copy files from disk into Spark from the terminal as follows. Please notice that the following code will only work in clusters using HDFS, not in local environments. hadoop fs -copyFromLocal largefile.txt largefile.txt You can then read the uploaded file as described in the file formats section; for text files, you would run: spark_read_text(sc, &quot;largefile.txt&quot;, memory = FALSE) # Source: spark&lt;largefile&gt; [?? x 1] line &lt;chr&gt; 1 0.0982531064914565 -0.577567317599452 -1.66433938237253 -0.20095089489… 2 -1.08322304504007 1.05962389624635 1.1852771207729 -0.230934710049462 … 3 -0.398079835552421 0.293643382374479 0.727994248743204 -1.571547990532… 4 0.418899768227183 0.534037617828835 0.921680317620166 -1.6623094393911… 5 -0.204409401553028 -0.0376212693728992 -1.13012269711811 0.56149527218… 6 1.41192628218417 -0.580413572014808 0.727722566256326 0.5746066486689 … 7 -0.313975036262443 -0.0166426329807508 -0.188906975208319 -0.986203251… 8 -0.571574679637623 0.513472254005066 0.139050812059352 -0.822738334753… 9 1.39983023148955 -1.08723592838627 1.02517804413913 -0.412680186313667… 10 0.6318328148434 -1.08741784644221 -0.550575696474202 0.971967251067794… # … with more rows collect() has a similar limitation, it can only collect datasets that fit your driver memory; however, if you had to extract a large dataset from Spark through the driver node, you could use specialized tools provided by the distributed storage, for HDFS you would run, hadoop fs -copyToLocal largefile.txt largefile.txt Alternatively, you can also collect datasets that don’t fit in-memory by providing a callback to collect(). A callback is just an R function that will be called over each Spark partition, you can then write this dataset to disk or push to other clusters over the network. The following code could be use to collect 3GB even if the driver node collecting this dataset had less than 3GB of memory. That said, as explained in the Analysis chapter, you should avoid collecting large datasets into a single machine since this creates a significant performance bottleneck. For conciseness, we will collect only the first million rows; feel free to remove head(10^6) if you havee a few minutes to spare. dir.create(&quot;large&quot;) spark_read_text(sc, &quot;largefile.txt&quot;, memory = FALSE) %&gt;% head(10^6) %&gt;% collect(callback = function(df, idx) { writeLines(df$line, paste0(&quot;large/large-&quot;, idx, &quot;.txt&quot;)) }) Make sure you clean up these large files and empty your recycle bin as well, unlink(&quot;largefile.txt&quot;, recursive = TRUE) unlink(&quot;large&quot;, recursive = TRUE) In most cases, data will already be stored in the cluster, so you should not have to worry about copying large-datasets; instead, you can usually focus on reading and writing different file formats, which we will describe next. 8.5 File Formats Out-of-the-box, Spark is able to interact with several file formats like: CSV, JSON, LIBSVM, ORC and Parquet. The following table maps the file format to the function you should use to read and write data in Spark: Format Read Write Comma separated values (CSV) spark_read_csv() spark_write_csv() JavaScript Object Notation (JSON) spark_read_json() spark_write_json() Library for Support Vector Machines (LIBSVM) spark_read_libsvm() spark_write_libsvm() Optimized Row Columnar (ORC) spark_read_orc() spark_write_orc() Apache Parquet spark_read_parquet() spark_write_parquet() Text spark_read_text() spark_write_text() The following sections will describe special considerations particular to each file format and present some of the strengths and weaknesses of some of the popular file formats, starting with the well-known CSV file format. 8.5.1 CSV The CSV format may be the most common file type in use today, which is defined by a text file separated by a given character, usually a comma. It should be pretty straightforward to read CSV files; however, it’s worth mentioning a couple techniques that can help you process CSVs that are not fully compliant with a well-formed CSV file. Spark offers the following modes for addressing parsing issues: Permissive: NULL values are inserted for missing tokens. Drop Malformed: Drops lines which are malformed. Fail Fast: Aborts if encounters any malformed line. These can be used in sparklyr by passing them inside the options argument. The following example creates a file with a broken entry. It then shows how it can be read into Spark. ## Creates bad test file writeLines(c(&quot;bad&quot;, 1, 2, 3, &quot;broken&quot;), &quot;bad.csv&quot;) spark_read_csv( sc, &quot;bad3&quot;, &quot;bad.csv&quot;, columns = list(foo = &quot;integer&quot;), options = list(mode = &quot;DROPMALFORMED&quot;)) # Source: spark&lt;bad3&gt; [?? x 1] foo &lt;int&gt; 1 1 2 2 3 3 Spark provides an issue tracking column which was hidden by default. To enable it, add _corrupt_record to the columns list. This can be combined with the use of the PERMISSIVE mode. All rows will be imported, invalid entries will receive an NA, and the issue tracked in the _corrupt_record column. spark_read_csv( sc, &quot;bad2&quot;, &quot;bad.csv&quot;, columns = list(foo = &quot;integer&quot;, &quot;_corrupt_record&quot; = &quot;character&quot;), options = list(mode = &quot;PERMISSIVE&quot;) ) # Source: spark&lt;bad2&gt; [?? x 2] foo `_corrupt_record` &lt;int&gt; &lt;chr&gt; 1 1 NA 2 2 NA 3 3 NA 4 NA broken Reading and storing data as CSVs is quite common and supported across most systems; so for tabular datasets, is still a popular option; for datasets containing nested structures and non-tabular data, JSON is usually preferred 8.5.2 JSON JSON is a file format originally derived from JavaScript which has grown to be language-independent and very popular due to its flexibility and ubiquitous support. Reading and writing JSON files is quite straightforward, writeLines(&quot;{&#39;a&#39;:1, &#39;b&#39;: {&#39;f1&#39;: 2, &#39;f3&#39;: 3}}&quot;, &quot;data.json&quot;) simple_json &lt;- spark_read_json(sc, &quot;data.json&quot;) simple_json # Source: spark&lt;data&gt; [?? x 2] a b &lt;dbl&gt; &lt;list&gt; 1 1 &lt;list [2]&gt; However, when you deal with dataset containing nested fields like the one from this example; it is worth pointing out how to extract nested fields. One approach is to use a JSON Path, which is a domain specific syntax commonly used to extract and query JSON files, you can use a combination of get_json_object() and to_json() to specify the JSON path you are interested in, to extract f1 you would run the following transformation: simple_json %&gt;% dplyr::transmute(z = get_json_object(to_json(b), &#39;$.f1&#39;)) # Source: spark&lt;?&gt; [?? x 3] a b z &lt;dbl&gt; &lt;list&gt; &lt;chr&gt; 1 1 &lt;list [2]&gt; 2 Another approach is to install sparkly.nested from CRAN with install.packages(\"sparklyr.nested\") and then unnest nested data with sdf_unnest(): sparklyr.nested::sdf_unnest(simple_json, &quot;b&quot;) # Source: spark&lt;?&gt; [?? x 3] a f1 f3 &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 2 3 While JSON and CSVs are quite simple to use and versatile, they are not optimized for performance; but other formats like ORC, AVRO and Parquet are. 8.5.3 Parquet Apache Parquet, Apache ORC and Apache AVRO are all file formats designed with performance in mind. Parquet and ORC happen to store data in columnar format while AVRO is row-based, all of them are binary file formats which reduces storage space and improve performance. This at the cost of making them a bit harder to read by external systems and libraries; however, this is usually not an issue when used as intermediate data storage within Spark. To illustrate this, Figure 8.3 plots the result of running a one-million-rows write-speed benchmark using the bench package, please use your own benchmarks over meaningful datasets when deciding which formats fits best your needs. numeric &lt;- copy_to(sc, data.frame(nums = runif(10^6))) bench::mark( CSV = spark_write_csv(numeric, &quot;data.csv&quot;, mode = &quot;overwrite&quot;), JSON = spark_write_json(numeric, &quot;data.json&quot;, mode = &quot;overwrite&quot;), Parquet = spark_write_parquet(numeric, &quot;data.parquet&quot;, mode = &quot;overwrite&quot;), ORC = spark_write_parquet(numeric, &quot;data.orc&quot;, mode = &quot;overwrite&quot;), iterations = 20 ) %&gt;% ggplot2::autoplot() FIGURE 8.3: One million rows write benchmark between CSV, JSON, Parquet and ORC From now on, please disconnect from Spark whenever we present a new spark_connect() command. spark_disconnect(sc) This concludes the introduction to some of the out-of-the-box supported file formats, we will present next how to deal with formats that require external packages and customization. 8.5.4 Others Spark is a very flexible computing platform, it can add functionality by using extension programs, called packages. Accessing a new source type or file system can be done by using the appropriate package. Packages need to be loaded into Spark at connection time. To load the package, Spark needs its location, which could be inside the cluster, in a file share or the Internet. In sparklyr, the package location is passed to spark_connect(). All packages should be listed in the sparklyr.connect.packages entry of the connection configuration. It is possible to access data source types not listed above. Loading the appropriate default package for Spark is the first of two steps The second step is to actually read or write the data. The spark_read_source() and spark_write_source() functions do that. They are generic functions that can use the libraries imported by a default package. For instance, we can read XML files as follows: sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;, config = list( sparklyr.connect.packages = &quot;com.databricks:spark-xml_2.11:0.5.0&quot;)) writeLines(&quot;&lt;ROWS&gt;&lt;ROW&gt;&lt;text&gt;Hello World&lt;/text&gt;&lt;/ROW&gt;&quot;, &quot;simple.xml&quot;) spark_read_source(sc, &quot;simple_xml&quot;, &quot;simple.xml&quot;, &quot;xml&quot;) # Source: spark&lt;data&gt; [?? x 1] text &lt;chr&gt; 1 Hello World Which you can also write back to XML with ease as follows, tbl(sc, &quot;simple_xml&quot;) %&gt;% spark_write_source(&quot;xml&quot;, options = list(path = &quot;data.xml&quot;)) In addition, there are a few extensions developed by the R community to load additional file formats, to mention a few: sparklyr.nested to assist with nested data, spark.sas7bdat to read data from SAS, sparkavro to read data in AVRO format and sparkwarc to read WARC files which use extensibility mechanisms introduced in the Extensions chapter. The Distributed R chapter will present techniques to use R packages to load additional file formats and the Contributing chapter presents techniques to use Java libraries to complement this further. But first, let’s explore how to retrieve and store files from several different file systems. 8.6 File Systems Spark will default to the file system that it is currently running on. In a YARN managed cluster, the default file system will be HDFS. An example path of “/home/user/file.csv” will be read from cluster’s HDFS folders, and not the Linux folders. The Operating System’s file system will be accessed for other deployments, such as Stand Alone, and sparklyr’s local. The file system protocol can be changed when reading or writing. It is done via the path argument of the sparklyr function. For example, a full path of “file://home/user/file.csv” will force the use of the local Operating System’s file system. There are many other file system protocols like: dbfs:// for Databricks’ file system, s3a:// for Amazon’s S3 service, wasb:// for Microsoft Azure storage, gs:// for Google storage, etc. Spark does not provide support for all them directly; instead, they are configured as needed. For instance, accessing the “s3a” protocol requires adding a package to the sparklyr.connect.packages configuration setting while connecting and appropriate credentials might need to be specified using the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables. Sys.setenv(AWS_ACCESS_KEY_ID = my_key_id) Sys.setenv(AWS_SECRET_ACCESS_KEY = my_secret_key) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;, config = list( sparklyr.connect.packages = &quot;org.apache.hadoop:hadoop-aws:2.7.7&quot;)) my_file &lt;- spark_read_csv(sc, &quot;my-file&quot;, path = &quot;s3a://my-bucket/my-file.csv&quot;) Accessing other file protocol requires loading different packages; although, in some cases, the vendor providing the Spark environment might loading the package for you. Please refer to your vendor’s documentation to find out if that is the case. The section file systems in the Appendix contains tips on how to read and write data from specific file systems. 8.7 Storage Systems A data lake and Spark usually go hand-in-hand with optional access to storage systems like databases and data warehouses. Presenting all the different storage systems with appropriate examples would be quite time consuming, so instead we will present some of the commonly used storage systems As a start, Apache Hive is a data warehouse software that facilitates reading, writing, and managing large datasets residing in distributed storage using SQL. In fact, Spark has component from Hive built directly into Spark’s sources and is very common to have installations of Spark or Hive side-by-side, so we will start by presenting Hive, followed by Cassandra and closing on JDBC connections. 8.7.1 Hive In YARN managed clusters, Spark provides a deeper integration with Apache Hive. Hive tables are easily accessible after opening a Spark connection. Accessing a Hive table’s data can be done using DBI, by referencing a table in a SQL statement. sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) spark_read_csv(sc, &quot;test&quot;, &quot;data-csv/&quot;, memory = FALSE) DBI::dbGetQuery(sc, &quot;SELECT * FROM test limit 10&quot;) Another way to reference a table is with dplyr using the tbl() function, which retrieves a reference to the table. dplyr::tbl(sc, &quot;test&quot;) It is important to reiterate that no data is imported into R, the tbl() function only creates a reference. You can then pipe more dplyr verbs following the tbl() command. dplyr::tbl(sc, &quot;test&quot;) %&gt;% dplyr::group_by(y) %&gt;% dplyr::summarise(totals = sum(y)) Hive table references assume a default database source. Often, the table needed table is in a different database within the Metastore. To access it using SQL, prefix the database name to the table. Separate them using a period. DBI::dbSendQuery(sc, &quot;SELECT * FROM databasename.table&quot;) In dplyr, the in_schema() function can be used. The function is used inside the tbl() call. tbl(sc, dbplyr::in_schema(&quot;databasename&quot;, &quot;table&quot;)) You can also use the tbl_change_db() function to set the current session’s default database. Any subsequent call via DBI or dplyr will use the selected name as the default database. tbl_change_db(sc, &quot;databasename&quot;) The following examples require additional Spark packages and database which might be hard to follow unless you happen to have a JDBC driver or Cassandra database accessible to you; therefore, lets disconnect from Spark: spark_disconnect(sc) Next we will explore a less structured storage system, often referred to as NoSQL databases. 8.7.2 Cassandra Apache Cassandra is a free and open-source, distributed, wide column store, NoSQL database management system designed to handle large amounts of data across many commodity servers. While there are many other database systems beyond Cassandra, taking a quick look at how Cassandra can be used form Spark will also inform how to make use of other Database and storage systems like Solr, Redshift, Delta Lake, etc. The following example code shows how to use the datastax:spark-cassandra-connector package to read from Cassandra. The key is to use the org.apache.spark.sql.cassandra library as the source argument. It provides the mapping Spark can use to make sense of the data source. Unless you have a Cassandra database, skip executing the following statement. sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;, config = list( sparklyr.connect.packages = &quot;datastax:spark-cassandra-connector:2.3.1-s_2.11&quot;)) spark_read_source( sc, name = &quot;emp&quot;, source = &quot;org.apache.spark.sql.cassandra&quot;, options = list(keyspace = &quot;dev&quot;, table = &quot;emp&quot;), memory = FALSE) One of the most useful features of Spark when dealing with external databases and data warehouses is that, Spark can push down computation to the Database, this is known as pushdown predicates; in a nutshell, it improves performance by asking remote databases smart questions. When you execute a query that contains the filter(age &gt; 20) expression against a remote table referenced through spark_read_source() and not loaded in-memory, rather than bringing the entire table into Spark, it will get passed to the remote database and only a subset of the remote table is retrieved. While is ideal to find Spark packages that support the remote storage system, there will be times when a package is not available and vendor JDBC drivers need to be considered. 8.7.3 JDBC When a Spark package is not available to provide connectivity, a JDBC connection can be considered. JDBC stands for Java Database Connectivity, t’s an interface for the programming language Java, which defines how a client may access a database. It is quite easy to connect to a remote database with spark_read_jdbc() and spark_write_jdbc(); as long as you have access to the appropriate JDBC driver, which at times is trivial and other times quite an adventure. To keep this simple, we can briefly consider how a connection to a remote MySQL database could be accomplished. First, you would need to download the appropriate JDBC driver from the MySQL’s developer portal and specify this additional driver as a sparklyr.shell.driver-class-path connection option. Since JDBC drivers are Java-based, the code is contained inside a JAR (Java ARchive) file. Once connected to Spark with the appropriate driver, you can use the jdbc:// protocol to access particular drivers and databases. Unless you are willing to download and configure MySQL on your own, skip executing the following statement. sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;, config = list( &quot;sparklyr.shell.driver-class-path&quot; = &quot;~/Downloads/mysql-connector-java-5.1.41/mysql-connector-java-5.1.41-bin.jar&quot; )) spark_read_jdbc(sc, &quot;person_jdbc&quot;, options = list( url = &quot;jdbc:mysql://localhost:3306/sparklyr&quot;, user = &quot;root&quot;, password = &quot;&lt;password&gt;&quot;, dbtable = &quot;person&quot;)) If you are a customer of particular database vendors, making use of the vendor-provided resources is usually the best place to start looking for appropriate drivers. 8.8 Recap This chapter expanded on how and why you should use Spark to connect and process a variety of data sources, through a new data storage model known as data lakes – a storage pattern that provides more flexibility than standard ETL processes by enabling you to use raw datasets with, potentially, more information to enrich data analysis and modeling. We then presented best-practices for reading, writing and copying data into and from Spark and came back to exploring the components of a data lake: file formats and file systems; the former representing how data is stored, and the latter where the data is stored. You then learned how to tackle file formats and storage systems that require additional Spark packages, reviewed some of the performance tradeoffs across file formats, and learned the concepts required to make use of storage systems (databases and warehouses) in Spark. While reading and writing dataset should come naturally to you, you might still hit resource restrictions while reading and writing large-datasets. Therefore, in the next chapter you will learn how Spark manages tasks and data across multiple machines, which will in turn allow you to further improve the performance of your analysis and modeling tasks. References "],
["tuning.html", "Chapter 9 Tuning 9.1 Overview 9.2 Configuring 9.3 Partitioning 9.4 Caching 9.5 Shuffling 9.6 Serialization 9.7 Configuration Files 9.8 Recap", " Chapter 9 Tuning “Chaos isn’t a pit. Chaos is a ladder.” — Petyr Baelish In previous chapters we’ve assumed that computation within a Spark cluster works efficiently. While this is true in some cases, it is often necessary to have some knowledge of the operations Spark runs internally to fine tune configuration settings that will make computations run efficiently. This chapter will explain how Spark computes data over large datasets and provide details on how to fine-tune its operations. For instance, you will learn how to request more compute nodes and increase the amount of memory which, if you remember from the Getting Started chapter, defaults to only 2GB in local instances. You will learn how Spark unifies computation through partitioning, shuffling and caching. As mentioned a few chapters back, this is the last chapter describing the internals of Spark; once you complete this chapter, we believe that you will have the intermediate Spark skills necessary to be productive at using Spark. In subsequent chapters, Extensions, Distributed R and Streaming, you will learn exciting techniques to deal with specific modeling, scaling and computation problems. However, we must first understand how spark performs internal computations, what pieces we can control, and why. 9.1 Overview Spark performs distributed computation by configuring, partitioning, executing, shuffling, caching and serializing data, tasks and resources across multiple machines: Configuring requests the cluster manager for resources: total machines, memory, etc. Partitioning splits the data among various machines. Partitions can be either implicit or explicit. Executing means running an arbitrary transformation over each partition. Shuffling redistributes data to the correct machine. Caching preserves data in-memory across different computation cycles. Serializing transforms data to be sent over the network to other workers or back to the driver node. To illustrate each concept, we will create three partitions with unordered integers and then sort them with arrange(): data &lt;- copy_to(sc, data.frame(id = c(4, 9, 1, 8, 2, 3, 5, 7, 6)), repartition = 3) data %&gt;% arrange(id) %&gt;% collect() The diagram in Figure 9.1 shows how this sorting job would conceptually work across a cluster of machines. First, Spark would configure the cluster to use three worker machines. In this example, the numbers 1-9 are partitioned across three storage instances. Since the data is already partitioned, each worker node loads this implicit partition; for instance, 4,9,1 is loaded in the first worker node. Afterwards, a task is distributed to each worker to apply a transformation to each data partition in each worker node, this task is denoted by f(x). In this example, f(x) executes a sorting operation within a partition. Since Spark is general, execution over a partition can be as simple or complex as needed. The result is then shuffled to the correct machine to finish the sorting operation across the entire dataset, this completes a stage. A stage is a set of operations that Spark can execute without shuffling data between machines. Once the data is sorted across the cluster, the sorted results can be optionally cached in memory to avoid rerunning this computation multiple times. Finally, a small subset of the results is serialized, through the network connecting the cluster machines, back to the driver node to print a preview of this sorting example. FIGURE 9.1: Sorting Distributed Data with Apache Spark Notice that while Figure 9.1 describes a sorting operation, a similar approach applies to filtering or joining datasets and analyzing and modeling data at scale. Spark provides support to perform custom partitions, custom shuffling, etc; however, most of these lower level operations are not exposed in sparklyr; instead, sparklyr makes those operations available through higher level commands provided by data analysis tools like dplyr or DBI, modeling, and by using many extensions. For those few cases where you might need to implement low-level operations, you can always use the Spark’s Scala API through an sparklyr extensions or run custom distributed R code. In order to effectively tune Spark, we will start by getting familiar with Spark’s computation graph and Spark’s event timeline. Both are accessible through Spark’s web interface. 9.1.1 Graph Spark describes all computation steps using a Directed Acyclic Graph (DAG), which means that all computations in Spark move computation forward without repeating previous steps, this helps Spark optimize computations effectively. The best way to understand Spark’s computation graph for a given operation, sorting for our example, is to open the last completed query under the SQL tab in Spark’s web interface. Figure 9.2 shows the resulting graph for this sorting operation, this graph contains the following operations: WholeStageCodegen: This block describes that the operations it contains were used to generate computer code that was efficiently translated to byte code. There is usually a small cost associated with translating operations into byte code, but this is a small cost to pay since then the operations can be executed much faster from Spark. In general, you can ignore this blog and focus on the blocks that it contains. InMemoryTableScan: This means that the original dataset data was stored in-memory and traversed row-by-row once. Exchange: Partitions were exchanged, read shuffled, across executors in your cluster. Sort: Once the records arrived at the right executor, they were sorted in this final stage. FIGURE 9.2: Spark Graph for a Sorting Query From the query details, you can then open the last Spark job to arrive to the job details page, you can then expand “DAG Visualization” to visualize a graph similar to Figure 9.3. This graph shows a few additional details and the stages in this job. Notice that there are no arrows pointing back to previous steps, since Spark makes use of acyclic graphs. FIGURE 9.3: Spark Graph for a Sorting Job Next, we will dive into a Spark stage and explore its event timeline. 9.1.2 Timeline The event timeline is a great summary of how Spark is spending computation cycles over each stage. Ideally, you want to see this timeline consisting of mostly CPU usage since other tasks can be considered overhead. You also want to see Spark using all the CPUs across all the cluster nodes available to you. Select the first stage in the current job and expand the “Event Timeline”, you should see a timeline similar to Figure 9.4. Notice that we explicitly requested three partitions, which is represented by three lanes in this visualization. FIGURE 9.4: Spark Event Timeline Since our machine is equipped with four CPUs, we can parallelize this computation even further by explicitly repartition data using sdf_repartition(): data %&gt;% sdf_repartition(4) %&gt;% arrange(id) %&gt;% collect() FIGURE 9.5: Spark Event Timeline with Additional Partitions Figure 9.5 now shows four execution lanes with most time spent under “Executor Computing Time”, which shows us that this particular operation is making better use of our compute resources. When working with clusters, requesting more compute nodes from your cluster should shorten computation time. In contrast, for timelines that show significant time spent shuffling, requesting more compute nodes might not shorten time and might actually makes everything slower. There is no concrete set of rules to follow to optimize a stage; however, as you gain experience understanding this timeline over multiple operations – you will develop insights as to how to properly optimize Spark operations. 9.2 Configuring When tuning a Spark application, the most common resources to configure are memory and cores, specifically: Memory in Driver: The amount of memory required in the driver node. Memory per Worker: The amount of memory required in the worker nodes. Cores per Worker: The number of CPUs to required in the worker nodes. Number of Workers: The number of workers required for this session. Note: It is recommended to request significantly more memory for the driver than the memory available over each worker node. In most cases, you will want to request one core per worker. In local mode there are no workers, but we can still configure memory and cores to use through: # Initialize configuration with defaults config &lt;- spark_config() # Memory config[&quot;sparklyr.shell.driver-memory&quot;] &lt;- &quot;2g&quot; # Cores config[&quot;sparklyr.connect.cores.local&quot;] &lt;- 2 # Connect to local cluster with custom configuration sc &lt;- spark_connect(master = &quot;local&quot;, config = config) When using the Spark Standalone and the Mesos cluster managers, all the available memory and cores are assigned by default; therefore, there are no additional configuration changes required, unless, you want to restrict resources to allow multiple users to share this cluster. In this case you can use total-executor-cores to restrict the total executors requested. The “Spark Standalone” (“Spark Standalone Mode” 2018) and “Spark on Mesos” (“Running Spark on Mesos” 2018) guides provided additional information when sharing clusters. When running under YARN Client, you would configure memory and cores as follows: # Memory in Driver config[&quot;sparklyr.shell.driver-memory&quot;] &lt;- &quot;2g&quot; # Memory per Worker config[&quot;spark.executor.memory&quot;] &lt;- &quot;2G&quot; # Cores per Worker config[&quot;sparklyr.shell.executor-cores&quot;] &lt;- 1 # Number of Workers config[&quot;sparklyr.shell.num-executors&quot;] &lt;- 3 When using YARN in Cluster mode, sparklyr.shell.driver-cores can be used to configure total cores requested in the driver node. The “Spark on YARN” (“Running Spark on Yarn” 2018b) guide provides additional configuration settings worth familiarizing yourself with. There are a few types of configuration settings: Connect settings are set as parameters to spark_connect(), they are common settings used while connecting. Submit settings are set while sparklyr is being submitted to Spark through spark-submit, some dependent on the cluster manager being used. Runtime settings configure Spark when the Spark session is created, these settings are independent to the cluster manager and specific to Spark. sparklyr settings configure sparklyr behaviour, these settings are independent to the cluster manager and particular to R. The following subsections present extensive lists of all the available settings. It is not required to fully understand them all while tuning Spark, but skimming through them could prove useful in the future while troubleshooting issues. You can also consider skipping the following settings subsections and use them instead as reference material as needed. 9.2.1 Connect Settings The following parameters can be used with spark_connect(), they configure high-level settings that define the connection method, Spark’s installation path and the version of Spark to use. name value master Spark cluster url to connect to. Use “local” to connect to a local instance of Spark installed via spark_install(). spark_home The path to a Spark installation. Defaults to the path provided by the SPARK_HOME environment variable. If SPARK_HOME is defined, it will always be used unless the version parameter is specified to force the use of a locally installed version. method The method used to connect to Spark. Default connection method is “shell” to connect using spark-submit, use “livy” to perform remote connections using HTTP, or “databricks” when using a Databricks clusters. app_name The application name to be used while running in the Spark cluster. version The version of Spark to use. Only applicable to “local” Spark connections. config Custom configuration for the generated Spark connection. See spark_config for details. You can configure additional settings by specifying a list in the config parameter, we will now learn what those settings can be. 9.2.2 Submit Settings Some settings must be specified when spark-submit (the terminal application that launches Spark) is run. For instance, since spark-submit launches driver node which runs as a Java instance, choosing how much memory is allocated needs to be specified as a parameter to spark-submit. You can list all the available spark-submit parameters by running: spark_home_dir() %&gt;% file.path(&quot;bin&quot;, &quot;spark-submit&quot;) %&gt;% system2() For readability, we’ve provided the output of this command in table format, replacing the spark-submit parameter with the appropriate spark_config() setting and removing the parameters that are not applicable or already presented in this chapter: name value sparklyr.shell.jars Specified as ‘jars’ parameter in ‘spark_connect()’. sparklyr.shell.packages Comma-separated list of maven coordinates of jars to include on the driver and executor classpaths. Will search the local maven repo, then maven central and any additional remote repositories given by ‘sparklyr.shell.repositories’. The format for the coordinates should be groupId:artifactId:version. sparklyr.shell.exclude-packages Comma-separated list of groupId:artifactId, to exclude while resolving the dependencies provided in ‘sparklyr.shell.packages’ to avoid dependency conflicts. sparklyr.shell.repositories Comma-separated list of additional remote repositories to search for the maven coordinates given with ‘sparklyr.shell.packages’ sparklyr.shell.files Comma-separated list of files to be placed in the working directory of each executor. File paths of these files in executors can be accessed via SparkFiles.get(fileName). sparklyr.shell.conf Arbitrary Spark configuration property set as PROP=VALUE. sparklyr.shell.properties-file Path to a file from which to load extra properties. If not specified, this will look for conf/spark-defaults.conf. sparklyr.shell.driver-java-options Extra Java options to pass to the driver. sparklyr.shell.driver-library-path Extra library path entries to pass to the driver. sparklyr.shell.driver-class-path Extra class path entries to pass to the driver. Note that jars added with ‘sparklyr.shell.jars’ are automatically included in the classpath. sparklyr.shell.proxy-user User to impersonate when submitting the application. This argument does not work with ‘sparklyr.shell.principal’ / ‘sparklyr.shell.keytab’. sparklyr.shell.verbose Print additional debug output. The remaining settings are specific to YARN: name value sparklyr.shell.queue The YARN queue to submit to (Default: “default”). sparklyr.shell.archives Comma separated list of archives to be extracted into the working directory of each executor. sparklyr.shell.principal Principal to be used to login to KDC, while running on secure HDFS. sparklyr.shell.keytab The full path to the file that contains the keytab for the principal specified above. This keytab will be copied to the node running the Application Master via the Secure Distributed Cache, for renewing the login tickets and the delegation tokens periodically. In general, any spark-submit setting is configured through sparklyr.shell.X, where X is the name of the spark-submit parameter without the -- prefix. 9.2.3 Runtime Settings As mentioned, some Spark settings configure the session runtime. The runtime settings are a superset of the submit settings since is usually helpful to retrieve the current configuration even if a setting can’t be changed. To list the Spark settings set in your current Spark session, you can run: spark_session_config(sc) name value spark.master local[4] spark.sql.shuffle.partitions 4 spark.driver.port 62314 spark.submit.deployMode client spark.executor.id driver spark.jars /Library/…/sparklyr/java/sparklyr-2.3-2.11.jar spark.app.id local-1545518234395 spark.env.SPARK_LOCAL_IP 127.0.0.1 spark.sql.catalogImplementation hive spark.spark.port.maxRetries 128 spark.app.name sparklyr spark.home /Users/…/spark/spark-2.3.2-bin-hadoop2.7 spark.driver.host localhost However, there are many more configuration settings available in Spark as described in the “Spark Configuration” (“Spark Configuration” 2018) guide. It is not in the scope of this book to describe them all so, if possible, take some time to identify the ones that might be of interest to your particular use cases. 9.2.4 sparklyr Settings Apart from Spark settings, there are a few settings particular to sparklyr listed below. You usually don’t use these settings while tuning SPark; instead, they are helpful while troubleshooting Spark from R. For instance, you can use sparklyr.log.console = TRUE to output the Spark logs into the R console, this is ideal while troubleshooting but too noisy otherwise. spark_config_settings() name description sparklyr.apply.packages Configures default value for packages parameter in spark_apply(). sparklyr.apply.rlang Experimental feature. Turns on improved serialization for spark_apply(). sparklyr.apply.serializer Configures the version spark_apply() uses to serialize the closure. sparklyr.apply.schema.infer Number of rows collected to infer schema when column types specified in spark_apply(). sparklyr.arrow Use Apache Arrow to serialize data? sparklyr.backend.interval Total seconds sparklyr will check on a backend operation. sparklyr.backend.timeout Total seconds before sparklyr will give up waiting for a backend operation to complete. sparklyr.collect.batch Total rows to collect when using batch collection, defaults to 100,000. sparklyr.cancellable Cancel spark jobs when the R session is interrupted? sparklyr.connect.aftersubmit R function to call after spark-submit executes. sparklyr.connect.app.jar The path to the sparklyr jar used in spark_connect(). sparklyr.connect.cores.local Number of cores to use in spark_connect(master = “local”), defaults to parallel::detectCores(). sparklyr.connect.csv.embedded Regular expression to match against versions of Spark that require package extension to support CSVs. sparklyr.connect.csv.scala11 Use Scala 2.11 jars when using embedded CSV jars in Spark 1.6.X. sparklyr.connect.jars Additional JARs to include while submitting application to Spark. sparklyr.connect.master The cluster master as spark_connect() master parameter, notice that the ‘spark.master’ setting is usually preferred. sparklyr.connect.packages Spark packages to include when connecting to Spark. sparklyr.connect.ondisconnect R function to call after spark_disconnect(). sparklyr.connect.sparksubmit Command executed instead of spark-submit when connecting. sparklyr.connect.timeout Total seconds before giving up connecting to the sparklyr gateway while initializing. sparklyr.dplyr.period.splits Should ‘dplyr’ split column names into database and table? sparklyr.extensions.catalog Catalog PATH where extension JARs are located. Defaults to ‘TRUE’, ‘FALSE’ to disable. sparklyr.gateway.address The address of the driver machine. sparklyr.gateway.config.retries Number of retries to retrieve port and address from config, useful when using functions to query port or address in kubernetes. sparklyr.gateway.interval Total of seconds sparkyr will check on a gateway connection. sparklyr.gateway.port The port the sparklyr gateway uses in the driver machine, defaults to 8880. sparklyr.gateway.remote Should the sparklyr gateway allow remote connections? This is required in yarn cluster, etc. sparklyr.gateway.routing Should the sparklyr gateway service route to other sessions? Consider disabling in kubernetes. sparklyr.gateway.service Should the sparklyr gateway be run as a service without shutting down when the last connection disconnects? sparklyr.gateway.timeout Total seconds before giving up connecting to the sparklyr gateway after initialization. sparklyr.gateway.wait Total seconds to wait before retrying to contact the sparklyr gateway. sparklyr.livy.auth Authentication method for Livy connections. sparklyr.livy.headers Additional HTTP headers for Livy connections. sparklyr.livy.sources Should sparklyr sources be sourced when connecting? If false, manually register sparklyr jars. sparklyr.log.invoke Should every call to invoke() be printed in the console? Can be set to ‘callstack’ to log call stack. sparklyr.log.console Should driver logs be printed in the console? sparklyr.progress Should job progress be reported to RStudio? sparklyr.progress.interval Total of seconds to wait before attempting to retrieve job progress in Spark. sparklyr.sanitize.column.names Should partially unsupported column names be cleaned up? sparklyr.stream.collect.timeout Total seconds before stopping collecting a stream sample in sdf_collect_stream(). sparklyr.stream.validate.timeout Total seconds before stopping to check if stream has errors while being created. sparklyr.verbose Use verbose logging across all sparklyr operations? sparklyr.verbose.na Use verbose logging when dealing with NAs? sparklyr.verbose.sanitize Use verbose logging while sanitizing columns and other objects? sparklyr.web.spark The URL to Spark’s web interface. sparklyr.web.yarn The URL to YARN’s web interface. sparklyr.worker.gateway.address The address of the worker machine, most likely localhost. sparklyr.worker.gateway.port The port the sparklyr gateway uses in the driver machine. sparklyr.yarn.cluster.accepted.timeout Total seconds before giving up waiting for cluster resources in yarn cluster mode. sparklyr.yarn.cluster.hostaddress.timeout Total seconds before giving up waiting for the cluster to assign a host address in yarn cluster mode. sparklyr.yarn.cluster.lookup.byname Should the current user name be used to filter yarn cluster jobs while searching for submitted one? sparklyr.yarn.cluster.lookup.prefix Application name prefix used to filter yarn cluster jobs while searching for submitted one. sparklyr.yarn.cluster.lookup.username The user name used to filter yarn cluster jobs while searching for submitted one. sparklyr.yarn.cluster.start.timeout Total seconds before giving up waiting for yarn cluster application to get registered. 9.3 Partitioning As mentioned in the Introduction chapter, MapReduce and Spark were designed with the purpose of performing computations against data stored across many machines. The subset of the data available for computation over each compute instance is known as a partition. By default, Spark will compute over each existing implicit partition since it’s more effective to run computations were the data is already located. However, there are cases where you will want to set an explicit partition to help Spark use more efficient use of your cluster resources. 9.3.1 Implicit You learned in the Data chapter that Spark can read data stored in many formats and different storage systems; however, since shuffling data is an expensive operations, Spark executes tasks reusing the partitions in the storage system. Therefore, these partitions are implicit to Spark since they are already well defined and expensive to rearrange. There is always an implicit partition for every computation in Spark defined by the distributed storage system, by creating a dataset or by copying datasets into Spark. You can explore the number of partitions a computation will require through sdf_num_partitions(): sdf_len(sc, 10) %&gt;% sdf_num_partitions() [1] 2 While in most cases the default partitions works just fine, there are cases where we you will need to be explicit on the partitions you choose. 9.3.2 Explicit There will be times when you have many more compute instances than data partitions, or much less compute instances than the number of partitions in your data. In both cases, it can help to repartition data to match your cluster resources. Various data functions, like spark_read_csv(), already support a repartition parameter to request Spark to repartition data appropriately. For instance, we can create a sequence of 10 numbers partitioned by 10 as follows: sdf_len(sc, 10, repartition = 10) %&gt;% sdf_num_partitions() [1] 10 For datasets that are already partitioned, we can also use sdf_repartition: sdf_len(sc, 10, repartition = 10) %&gt;% sdf_repartition(4) %&gt;% sdf_num_partitions() [1] 4 The number of partitions usually significantly changes the speed and resources being used; for instance, the following example calculates the mean over 10M rows with different partition sizes. library(microbenchmark) library(ggplot2) microbenchmark( &quot;1 Partition(s)&quot; = sdf_len(sc, 10^7, repartition = 1) %&gt;% summarise(mean(id)) %&gt;% collect(), &quot;2 Partition(s)&quot; = sdf_len(sc, 10^7, repartition = 2) %&gt;% summarise(mean(id)) %&gt;% collect(), times = 10 ) %&gt;% autoplot() + theme_light() FIGURE 9.6: Computation speed when using explicit Spark partitions The results show that sorting data with two partitions is almost twice as fast; this is the case since two CPUs can be used to execute this operation. However, it is not necessarily the case that higher-partitions produce faster computation; instead, partitioning data is particular to your computing cluster and the data analysis operations being performed. 9.4 Caching Recall from the introduction that Spark was designed to be faster than its predecessors by using memory instead of disk to store data. This is formally known as a Spark RDD and stands for resilient distributed dataset. An RDD distributes copies of the same data across many machines, such that, if one machine fails other can complete the task – hence the resilient name. Resiliency is important in distributed systems since, while things will usually work in one machine, when running over thousands of machines the likelihood of something failing is much higher. When a failure happens, it is preferable to be fault tolerant to avoid losing the work of all the other machines. RDDs accomplish this by tracking data lineage information to rebuild lost data automatically on failure. In sparklyr, you can control when an RDD gets loaded or unloaded from memory using tbl_cache() and tbl_uncache(). Most sparklyr operations that retrieve a Spark DataFrame, cache the results in-memory. For instance, running spark_read_parquet() or copy_to() will provide a Spark DataFrame that is already cached in-memory. As a Spark DataFrame, this object can be used in most sparklyr functions, including data analysis with dplyr or machine learning. library(sparklyr) sc &lt;- spark_connect(master = &quot;local&quot;) iris_tbl &lt;- copy_to(sc, iris, overwrite = TRUE) You can inspect which tables are cached by navigating to the Spark UI using spark_web(sc), opening the storage tab, and clicking on a given RDD: FIGURE 9.7: Cached RDD in Spark Web Interface Data loaded in memory will be released when the R session terminates either explicitly or implicitly with a restart or disconnection; however, to free up resources, you can use tbl_uncache(): tbl_uncache(sc, &quot;iris&quot;) 9.4.1 Checkpointing Checkpointing is a slightly different type of caching; while it also persists data it will, additionally, break the graph computation lineage. For example, if a cached partition is lost, it can be computed from the computation graph which is not possible while checkpointing since the source of computation is lost. When performing expensive computation graphs, it can make sense to checkpoint to persist and break the computation lineage in order to help Spark reduce graph computation resources; otherwise, Spark might try to over-optimize a computation graph that is really not useful to optimize. You can checkpoint explicitly by saving to CSV, Parquet, etc. files. Or let Spark checkpoint this for you using sdf_checkpoint() in sparklyr as follows. # set checkpoint path spark_set_checkpoint_dir(sc, getwd()) # checkpoint the iris dataset iris_tbl %&gt;% sdf_checkpoint() Notice that checkpointing truncates the computation lineage graph, which can speed up performance if the same intermediate result is used multiple times. 9.4.2 Memory Memory in Spark is categorized into reserved, user, execution or storage: Reserved: Reserved memory is the memory required by Spark to function and therefore, is overhead that is required and should not be configured. This value defaults to 300MB. User: User memory is the memory used to execute custom code. sparklyr only makes use of this memory indirectly when executing dplyr expressions or modeling a dataset. Execution: Execution memory is used to execute code by Spark, mostly, to process the results from the partition and perform shuffling. Storage: Storage memory is used to cache RDDs, for instance, when using tbl_cache() in sparklyr. As part of tuning execution, you can consider tweaking the amount of memory allocated for user, execution and storage by creating a Spark connection with different values than the defaults provided in Spark: config &lt;- spark_config() # define memory available for storage and execution config$spark.memory.fraction &lt;- 0.75 # define memory available for storage config$spark.memory.storageFraction &lt;- 0.5 For instance, if you want to use Spark to store large amounts of data in-memory with the purpose of filtering and retrieving subsets quickly, you can expect Spark to use little execution or user memory. Therefore, to maximize storage memory, one can tune Spark as follows: config &lt;- spark_config() # define memory available for storage and execution config$spark.memory.fraction &lt;- 0.90 # define memory available for storage config$spark.memory.storageFraction &lt;- 0.90 However, notice that Spark will borrow execution memory from storage and viceversa if needed and if possible; therefore, in practice, there should be little need to tune the memory settings. 9.5 Shuffling Shuffling, is the operation that redistributes data across machines; it is usually an expensive operation and therefore, one we try to minimize. One can easily identify if significant time is being spent shuffling by looking at the event timeline. It is possible to reduce shuffling by reframing data analysis questions or hinting Spark appropriately. This would be relevant, for instance, when joining data frames that differ in size significantly, as in, one set being orders of magnitude smaller than the other one. You can consider using sdf_broadcast() to mark a data frame as small enough for use in broadcast joins, meaning, it pushes one of the smaller data frames to each of the worker nodes to reduce shuffling the bigger dataframe. One example for sdf_broadcast() follows: sdf_len(sc, 10000) %&gt;% sdf_broadcast() %&gt;% left_join(sdf_len(sc, 100)) 9.6 Serialization Serialization is the process of translating data and tasks into a format that can be transmitted between machines and reconstructed on the receiving end. It is not that common to have to adjust serialization when tuning Spark; however, it is worth mentioning there are alternative serialization modules like the Kryo Serializer that can provide performance improvements over the default Java Serializer. The Kryo Serializer can be enabled in sparklyr through: config &lt;- spark_config() config$spark.serializer &lt;- &quot;org.apache.spark.serializer.KryoSerializer&quot; sc &lt;- spark_connect(master = &quot;local&quot;, config = config) 9.7 Configuration Files Configuring the spark_config() settings before connecting is the most common approach while tuning Spark. However, once the desired connection is known, you should consider switching to use a configuration file since it will remove the clutter in your connection code and also allow you to share the configuration settings across projects and coworkers. For instance, instead of connecting to Spark through: config &lt;- spark_config() config[&quot;sparklyr.shell.driver-memory&quot;] &lt;- &quot;2G&quot; sc &lt;- spark_connect(master = &quot;local&quot;, config = config) You can instead define a config.yml with the desired settings. This file should be located in the current working directory or in parent directories. For example, you can create the following config.yml file to modify the default driver memory: default: sparklyr.shell.driver-memory: 2G Then, connecting with the same configuration settings becomes much cleaner by using instead: sc &lt;- spark_connect(master = &quot;local&quot;) You can also specify an alternate config file name or location by setting the file parameter in spark_config(). One additional benefit from using configuration files, is that a system administrator can change the default configuration by changing the value of the R_CONFIG_ACTIVE environment variable, see github.com/rstudio/config for additional information. 9.8 Recap This chapter provided a broad overview of Spark internals and a detailed configuration settings to help you speed up computation and enable high computation loads. It provided the foundations to understand bottlenecks and guidance on common configuration considerations; however, fine-tuning Spark is a broad topic that would require many more chapters to cover extensively. Therefore, while troubleshooting Spark’s performance and scalability, searching the web and consulting online communities it is often necessary to fine-tune your particular environment. The next chapter, Extensions, introduces the ecosystem of Spark extensions available in R. Most extensions are highly-specialized, but they will prove to be extremely useful in specific cases and readers with particular needs. For instance, they can process nested data, perform graph analysis or use different modeling libraries like rsparkling from H20. Not only that, but the next few chapters introduce many advanced data analysis and modeling topics that are required to master large-scale computing in R. References "],
["extensions.html", "Chapter 10 Extensions 10.1 Overview 10.2 H2O 10.3 Graphs 10.4 XGBoost 10.5 Deep Learning 10.6 Genomics 10.7 Spatial 10.8 Troubleshooting 10.9 Recap", " Chapter 10 Extensions “I try to know as many people as I can. You never know which one you’ll need.” — Tyrion Lannister In the previous chapter, Tuning, you learned how Spark processes data at large-scale by allowing users to configure the cluster resources, partition data implicitly or explicitly, execute commands across distributed compute nodes, shuffle data across them when needed, cache data to improve performance and serialize data efficiently over the network. You also learned how to configure the different Spark settings used while connecting, submitting a job, running and application and particular settings applicable only to R and R extensions that we will present in this chapter. The Analysis, Modeling and Data chapters provided a foundation to read and understand most datasets. However, the functionality that was presented was scoped to Spark’s built-in features and tabular datasets. This chapter will go beyond tabular data and explore how to analyze and model networks of interconnected objects through graph processing, analyze genomics datasets, prepare data for deep learning, analyze geographic datasets and use advanced modeling libraries like H2O and XGBoost over large-scale datasets. The combination of all the content presented in all the previous chapters should take care of most of your large-scale computing needs. However, for those few use cases where functionality is still lacking, the following chapters will provide tools to extend Spark yourself; either, through custom R transformation, custom Scala code or through recent new execution mode in Spark that enable analyzing real-time datasets. Although, before reinventing the wheel, we will present some of the extensions available in Spark. 10.1 Overview In the Introduction chapter we presented the R community as a vibrant group of individuals collaborating with each other in many ways, one of them, by moving open science forward by creating R packages that can be installed from CRAN. In a similar way, but in a much smaller scale, the R community has contributed extensions that increase the functionality initially supported in Spark and R. Spark itself also provides support for creating Spark extensions and, in-fact, many R extensions make use of Spark extensions. Extensions are constantly being created so this section will be outdated at any given point in time, in addition, we might not even be aware of many Spark and R extensions; however, at the very least we can track the extensions that are available in CRAN by looking at the “reverse imports” for sparklyr in CRAN. (“CRAN - Package Sparklyr” 2019) Extensions and R packages published in CRAN tend to be the most stable since when a package is published in CRAN, it will go through a review process which increases the overall quality of a contribution. While we wish we could present all the extensions, we’ will’ve scoped this chapter to the extensions that should be the most interesting to most readers. You can find additional ones under the github.com/r-spark organization or by searching repos on GitHub with the sparklyr tag. rsparkling The rsparkling extensions allows you to use H2O and Spark from R. This extension is what we would consider advanced modeling in Spark. While Spark’s built-in modeling library, Spark MLlib, is quite useful in many cases; H2O’s modeling capabilities can compute additional statistical metrics and can provide performance and scalability improvements over Spark MLlib. We, ourselves, have not performed detailed comparisons nor benchmarks between MLlib and H2O; so this is something you will have to research on your own to create a complete picture of when to use H2O’s capabilities. graphframes The graphframes extensions adds support to process graphs in Spark. A graph is a structure that describes a set of objects in which some pairs of the objects are in some sense related. As you learned in the Introduction chapter, ranking web pages was an early motivation to develop precursors to Spark powered by MapReduce; web pages happen to form a graph if you consider a link between pages as the relationship between each pair of pages. Computing operations likes PageRank over graphs can be quite useful in web search and social networks to mention a few applications. sparktf The sparktf extension provides support to write TensorFlow records in Spark. TensorFlow is one of the leading deep learning frameworks and it is often used with large amounts of numerical data represented as TensorFlow records, a file format optimized for TensorFlow. Spark it is often used to process unstructured and large-scale datasets into smaller numerical datasets that can easily fit into a GPU. You can use this extension to save datasets in the TensorFLow record file format. xgboost The xgboost extension brings the well-known XGBoost modeling library to the world of large-scale computing. XGBoost is a scalable, portable and distributed library for gradient boosting. It became well known in the machine learning competition circles after its use in the winning solution of the Higgs Machine Learning Challenge (“Higgs Boson Machine Learning Challenge” 2019) and has remained popular in other Kaggle competitions since then. variantspark The variantspark extension provides an interface to use Variant Spark, a scalable toolkit for genome-wide association studies (GWAS). It currently provides functionality to build random forest models, estimating variable importance and reading Variant Call Format (VCF) files. While there are other random forest implementations in Spark, most of them are not optimized to deal with GWAS datasets, which usually come with thousands of samples and millions of variables. geospark The geospark extensions enables us to load and query large-scale geographic datasets. Usually datasets containing latitude and longitude points or complex areas defined in the Well-known Text (WKT) format, a text markup language for representing vector geometry objects on a map. Before you learn how and when to use each extension, we should first briefly explain how extensions can be used with R and Spark. First, a Spark extension is just and R package that happens to be aware of Spark. As any other R package, you will first have to install the R package. Once installed, it is important to know that you will need to reconnect to Spark before the extension can be used. So, in general, the pattern you should follow goes as follows: library(sparkextension) library(sparklyr) sc &lt;- spark_connect(master = &quot;&lt;master&gt;&quot;) Notice that sparklyr is loaded after the extensions to allow the extension to register properly. If you had to install and load a new extension you would simply have to disconnect first using spark_disconnect(sc), restart your R session, and repeat the steps above with the new extension. It’s not hard to install and use Spark extensions from R; however, each extension can be a world on it’s own so most of the time you will have to spend time understanding what the extension is, when to use it and how to use it properly. The first extension you will learn about is the rsparkling extension which enables you to use H2O in Spark with R. 10.2 H2O H2O is open-source software for large-scale modeling created by H2O.ai, which allows you to fit thousands of potential models as part of discovering patterns in data. You can consider using H2O to complement or replace Spark’s default modeling algorithms. It is common to Spark’s default modeling algorithms and transition to H2O when Spark’s algorithms fall short or when advanced functionality (like additional modeling metrics or automatic model selection) are desired We can’t do justice to H2O’s great modeling capabilities in a single paragraph, explaining H2O properly will require a book in itself. Instead, we would like to recommend reading the “Practical machine learning with H2O” (Cook 2016) book to explore in-depth H2O’s modeling algorithms and features. In the meantime, you can use this section as a brief guide to get started using H2O in Spark with R. In order to use H2O with Spark, it is important to know that there are four components involved: H2O, Sparkling Water, rsparkling and Spark. Sparkling Water allows users to combine the fast, scalable machine learning algorithms of H2O with the capabilities of Spark. You can think of Sparkling Water as a component bridging Spark with H2O and rsparkling as the R front-end for Sparkling Water, this is illustrated in Figure 10.1. FIGURE 10.1: H2O components with Spark and R First, install rsparkling and h2o as specified in the rsparkling documentation site. (“RSparkling — H2o Sparkling Water 2.3.31 Documentation” 2019) install.packages(&quot;h2o&quot;, type = &quot;source&quot;, repos = &quot;http://h2o-release.s3.amazonaws.com/h2o/rel-yates/5/R&quot;) install.packages(&quot;rsparkling&quot;, type = &quot;source&quot;, repos = &quot;http://h2o-release.s3.amazonaws.com/sparkling-water/rel-2.3/31/R&quot;) It is important to notice that you need to use compatible versions of Spark, Sparkling Water and H2O as specified in their docs; we present instructions for Spark 2.3, but using different Spark versions will require you to install different versions. So let’s start by checking the version of H2O by running, packageVersion(&quot;h2o&quot;) ## [1] &#39;3.26.0.2&#39; packageVersion(&quot;rsparkling&quot;) ## [1] &#39;0.2.18&#39; We can then connect with the supported Spark versions as follows, you will have to adjust the master parameter for your particular cluster. library(rsparkling) library(sparklyr) library(h2o) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;, config = list(sparklyr.connect.timeout = 3 * 60)) cars &lt;- copy_to(sc, mtcars) H2O provides a web interface which can help you monitor training and access much of H2O’s functionality. The web interface can be accessed through h2o_flow(sc), it is referred to as H2O Flow and is shown in Figure 10.2. FIGURE 10.2: H2O Flow Interface using Spark with R When using H2O, you will have to convert your Spark DataFrame into and H2O DataFrame through as_h2o_frame: cars_h2o &lt;- as_h2o_frame(sc, cars) cars_h2o mpg cyl disp hp drat wt qsec vs am gear carb 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 [32 rows x 11 columns] Then you can use many of the modeling functions available in the h2o package with ease. For instance, we can fit a generalized linear model with ease: model &lt;- h2o.glm(x = c(&quot;wt&quot;, &quot;cyl&quot;), y = &quot;mpg&quot;, training_frame = cars_h2o, lambda_search = TRUE) H2O provides additional metrics not necessarily available in Spark’s modeling algorithms, the model that we just fit Residual Deviance is provided in the model while this would not be a standard metric when using Spark MLlib. model ... MSE: 6.017684 RMSE: 2.453097 MAE: 1.940985 RMSLE: 0.1114801 Mean Residual Deviance : 6.017684 R^2 : 0.8289895 Null Deviance :1126.047 Null D.o.F. :31 Residual Deviance :192.5659 Residual D.o.F. :29 AIC :156.2425 Then you can run prediction over the generalized linear model, a similar approach would work for many other models available in H2O: predictions &lt;- as_h2o_frame(sc, copy_to(sc, data.frame(wt = 2, cyl = 6))) h2o.predict(model, predictions) predict 1 24.05984 [1 row x 1 column] H2O can also be used to perform automatic training and tuning of many models; meaning that, H2O can choose which model to use for you using AutoML. (“AutoML: Automatic Machine Learning” 2019) automl &lt;- h2o.automl(x = c(&quot;wt&quot;, &quot;cyl&quot;), y = &quot;mpg&quot;, training_frame = cars_h2o, max_models = 20, seed = 1) For this particular dataset, H2O finds out that a Deep Learning model is a better fit than GLM7. Specifically, H2O’s AutoML explored using XGBoost, Deep Learning, GLM and a Stacked Ensemble models. automl@leaderboard model_id mean_residual_dev… rmse mse mae rmsle 1 DeepLearning_… 6.541322 2.557601 6.541322 2.192295 0.1242028 2 XGBoost_grid_1… 6.958945 2.637981 6.958945 2.129421 0.1347795 3 XGBoost_grid_1_… 6.969577 2.639996 6.969577 2.178845 0.1336290 4 XGBoost_grid_1_… 7.266691 2.695680 7.266691 2.167930 0.1331849 5 StackedEnsemble… 7.304556 2.702694 7.304556 1.938982 0.1304792 6 XGBoost_3_… 7.313948 2.704431 7.313948 2.088791 0.1348819 Rather than using the leaderboard, you can focus on the best model through automl@leader; for example, you can glance at the particular parameters from this Deep Learning model as follows: tibble::tibble(parameter = names(automl@leader@parameters), value = as.character(automl@leader@parameters)) # A tibble: 20 x 2 parameter values &lt;chr&gt; &lt;chr&gt; 1 model_id DeepLearning_grid_1_AutoML… 2 training_frame automl_training_frame_rdd… 3 nfolds 5 4 keep_cross_validation_models FALSE 5 keep_cross_validation_predictions TRUE 6 fold_assignment Modulo 7 overwrite_with_best_model FALSE 8 activation RectifierWithDropout 9 hidden 200 10 epochs 10003.6618461538 11 seed 1 12 rho 0.95 13 epsilon 1e-06 14 input_dropout_ratio 0.2 15 hidden_dropout_ratios 0.4 16 stopping_rounds 0 17 stopping_metric deviance 18 stopping_tolerance 0.05 19 x c(&quot;cyl&quot;, &quot;wt&quot;) 20 y mpg You can then predict using the leader as follows, h2o.predict(automl@leader, predictions) predict 1 30.74639 [1 row x 1 column] Many additional examples are available under spark.rstudio.com/guides/h2o, you can also request help from github.com/h2oai/sparkling-water/tree/master/r, the official GitHub repository for the rsparkling package. The next extension, graphframes, will allow you to process large-scale relational datasets; however, before you start using it, make sure to disconnect with spark_disconnect(sc) and restart your R session since using a different extensions requires you to reconnect to Spark and reload sparklyr. 10.3 Graphs The first paper in the history of graph theory was written by Leonhard Euler on the Seven Bridges of Königsberg in 1736. The problem was to devise a walk through the city that would cross each of those bridges once and only, the original diagram is shown in Figure 10.3. FIGURE 10.3: Seven Bridges of Königsberg from the Euler Archive Today, a graph is defined as an ordered pair \\(G=(V,E)\\), with \\(V\\) a set of vertices (nodes or points) and \\(E \\subseteq \\{\\{x, y\\} | (x, y) ∈ \\mathrm{V}^2 \\land x \\ne y\\}\\) a set of edges (links or lines) which are either an unordered pair for undirected graphs or an ordered pair for directed graphs. The former describing links where the direction does not matter and the latter linked where it does. As a simple example, we can use the highschool dataset from the ggraph package which tracks friendship among high school boys. In this dataset, the vertices are the students and the edges describe pairs of students who happen to be friends in a particular year. install.packages(&quot;ggraph&quot;) install.packages(&quot;igraph&quot;) ggraph::highschool # A tibble: 506 x 3 from to year &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 14 1957 2 1 15 1957 3 1 21 1957 4 1 54 1957 5 1 55 1957 6 2 21 1957 7 2 22 1957 8 3 9 1957 9 3 15 1957 10 4 5 1957 # … with 496 more rows While the highschool dataset can be easily processed in R, even medium size graph datasets can be hard to process without distributing this work across a cluster of machines which Spark is suited for. Spark supports processing graphs through the graphframes extension which in turn uses the GraphX Spark component. GraphX is Apache Spark’s API for graphs and graph-parallel computation, it’s comparable in performance to the fastest specialized graph processing systems and provides a growing library of graph algorithms. A graph in Spark is also represented as a dataframe of edges and vertices; however, the format is slightly different since we will need to construct a dataframe for vertices. Lets first install the GraphFrames extension, install.packages(&quot;graphframes&quot;) Followed by connecting, copying the highschool dataset and transforming the graph to the format that this extension expects, we will scope this dataset to the friendships of year 1957. library(graphframes) library(sparklyr) library(dplyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) highschool_tbl &lt;- copy_to(sc, ggraph::highschool, &quot;highschool&quot;) %&gt;% filter(year == 1957) %&gt;% transmute(from = as.character(as.integer(from)), to = as.character(as.integer(to))) from_tbl &lt;- highschool_tbl %&gt;% distinct(from) %&gt;% transmute(id = from) to_tbl &lt;- highschool_tbl %&gt;% distinct(to) %&gt;% transmute(id = to) vertices_tbl &lt;- distinct(sdf_bind_rows(from_tbl, to_tbl)) edges_tbl &lt;- highschool_tbl %&gt;% transmute(src = from, dst = to) The vertices_tbl table is expected to have a single id column: vertices_tbl # Source: spark&lt;?&gt; [?? x 1] id &lt;chr&gt; 1 1 2 34 3 37 4 43 5 44 6 45 7 56 8 57 9 65 10 71 # … with more rows While the edges_tbl is expected to have a src and dst columns: edges_tbl # Source: spark&lt;?&gt; [?? x 2] src dst &lt;chr&gt; &lt;chr&gt; 1 1 14 2 1 15 3 1 21 4 1 54 5 1 55 6 2 21 7 2 22 8 3 9 9 3 15 10 4 5 # … with more rows You can now create a GraphFrame, graph &lt;- gf_graphframe(vertices_tbl, edges_tbl) We can now use this graph to start analyzing this dataset. For instance, by finding out how many friends on average every one has, this is referred as the degree or valency of a vertex: gf_degrees(graph) %&gt;% summarise(friends = mean(degree)) # Source: spark&lt;?&gt; [?? x 1] friends &lt;dbl&gt; 1 6.94 We can then find what the shortest path to some specific vertex (person for this dataset). Since the data is anonymized, we can just pick the person identified as 33 and find how many degrees of separation exist between them: gf_shortest_paths(graph, 33) %&gt;% filter(size(distances) &gt; 0) %&gt;% mutate(distance = explode(map_values(distances))) %&gt;% select(id, distance) # Source: spark&lt;?&gt; [?? x 2] id distance &lt;chr&gt; &lt;int&gt; 1 19 5 2 5 4 3 27 6 4 4 4 5 11 6 6 23 4 7 36 1 8 26 2 9 33 0 10 18 5 # … with more rows Finally, we can also compute PageRank over this graph, which was presented in the Introduction chapter as Google’s web page ranking algorithm: gf_graphframe(vertices_tbl, edges_tbl) %&gt;% gf_pagerank(reset_prob = 0.15, max_iter = 10L) GraphFrame Vertices: Database: spark_connection $ id &lt;dbl&gt; 12, 12, 14, 14, 27, 27, 55, 55, 64, 64, 41, 41, 47, 47, 6… $ pagerank &lt;dbl&gt; 0.3573460, 0.3573460, 0.3893665, 0.3893665, 0.2362396, 0.… Edges: Database: spark_connection $ src &lt;dbl&gt; 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 12, 12,… $ dst &lt;dbl&gt; 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,… $ weight &lt;dbl&gt; 0.25000000, 0.25000000, 0.25000000, 0.25000000, 0.25000000,… To give you some insights into this dataset, Figure 10.4 plots this chart using the ggraph and highlights the highest PageRank scores for this dataset, highschool_tbl %&gt;% igraph::graph_from_data_frame(directed = FALSE) %&gt;% ggraph(layout = &#39;kk&#39;) + geom_edge_link(alpha = 0.2, arrow = arrow(length = unit(2, &#39;mm&#39;)), end_cap = circle(2, &#39;mm&#39;), start_cap = circle(2, &#39;mm&#39;)) + geom_node_point(size = 2, alpha = 0.4) FIGURE 10.4: Highschool ggraph dataset with highest pagerank highlighted There are many more graph algorithms provided in graphframes, to mention some: breadth-first search, connected components, label propagation for detecting communities, strongly connected components and triangle count. For questions on this extension refer to the official GitHub repo, github.com/rstudio/graphframes. We will now present a popular gradient boosting framework, make sure to disconnect, restart before trying the next extension. 10.4 XGBoost A decision tree is a flowchart-like structure in which each internal node represents a test on an attribute, each branch represents the outcome of the test, and each leaf node represents a class label. For example, the diagram in Figure 10.5 shows an a decision tree that could help classify if an employee is likely to leave given a set of factors, like job satisfaction and overtime. When a decision tree is used to predict continuous variables instead of discrete outcomes, say, how likely someone is to leave a company, decision trees are referred to as regression trees. FIGURE 10.5: A Decision tree to predict job attrition based on known factors While a decision tree representation is quite easy to understand and to interpret, finding out the decisions in the tree requires mathematical techniques like gradient descent to find a local minimum. Gradient descent takes steps proportional to the negative of the gradient of the function at the current point. The gradient is represented by \\(\\nabla\\), the learning rate by \\(\\gamma\\) and one simply starts from a given state \\(a_n\\) and compute the next iteration \\(a_{n+1}\\) by simply following the direction of the gradient: \\(a_{n+1} = a_n - \\gamma \\nabla F(a_n)\\) XGBoost is an open-source software library which provides a gradient boosting framework. It aims to provide a scalable, portable and distributed gradient boosting for training gradient-boosted decision trees (GBDT) and gradient-boosted regression trees (GBDT). Gradient-boosted means xgboost uses gradient descent and boosting, which is a technique that chooses each predictor sequentially. sparkxgb is an extension that you can use to train XGBoost models in Spark; however, please beware that currently Windows is unsupported. To use this extension, first install it from CRAN: install.packages(&quot;sparkxgb&quot;) Then you would need to import the sparkxgb extension followed by your usual Spark connection code, adjusting master as needed: library(sparkxgb) library(sparklyr) library(dplyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) For this example, we will use the attrition dataset from the rsample package which you would need to install with install.packages(\"rsample\"). This dataset is a fictional dataset created by IBM data scientists to uncover the factors that lead to employee attrition. attrition &lt;- copy_to(sc, rsample::attrition) attrition # Source: spark&lt;?&gt; [?? x 31] Age Attrition BusinessTravel DailyRate Department DistanceFromHome &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; 1 41 Yes Travel_Rarely 1102 Sales 1 2 49 No Travel_Freque… 279 Research_… 8 3 37 Yes Travel_Rarely 1373 Research_… 2 4 33 No Travel_Freque… 1392 Research_… 3 5 27 No Travel_Rarely 591 Research_… 2 6 32 No Travel_Freque… 1005 Research_… 2 7 59 No Travel_Rarely 1324 Research_… 3 8 30 No Travel_Rarely 1358 Research_… 24 9 38 No Travel_Freque… 216 Research_… 23 10 36 No Travel_Rarely 1299 Research_… 27 # … with more rows, and 25 more variables: Education &lt;chr&gt;, # EducationField &lt;chr&gt;, EnvironmentSatisfaction &lt;chr&gt;, Gender &lt;chr&gt;, # HourlyRate &lt;int&gt;, JobInvolvement &lt;chr&gt;, JobLevel &lt;int&gt;, JobRole &lt;chr&gt;, # JobSatisfaction &lt;chr&gt;, MaritalStatus &lt;chr&gt;, MonthlyIncome &lt;int&gt;, # MonthlyRate &lt;int&gt;, NumCompaniesWorked &lt;int&gt;, OverTime &lt;chr&gt;, # PercentSalaryHike &lt;int&gt;, PerformanceRating &lt;chr&gt;, # RelationshipSatisfaction &lt;chr&gt;, StockOptionLevel &lt;int&gt;, # TotalWorkingYears &lt;int&gt;, TrainingTimesLastYear &lt;int&gt;, # WorkLifeBalance &lt;chr&gt;, YearsAtCompany &lt;int&gt;, YearsInCurrentRole &lt;int&gt;, # YearsSinceLastPromotion &lt;int&gt;, YearsWithCurrManager &lt;int&gt; To build an XGBoost model in Spark use xgboost_classifier(), we will compute attrition against all other features by using the Attrition ~ . formula and specify two for the number of classes since the attrition attribute tracks only whether an employee leaves or not. Then you can use ml_predict() to predict over large-scale datasets: xgb_model &lt;- xgboost_classifier(attrition, Attrition ~ ., num_class = 2, num_round = 50, max_depth = 4) xgb_model %&gt;% ml_predict(attrition) %&gt;% select(Attrition, predicted_label, starts_with(&quot;probability_&quot;)) %&gt;% glimpse() Observations: ?? Variables: 4 Database: spark_connection $ Attrition &lt;chr&gt; &quot;Yes&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, … $ predicted_label &lt;chr&gt; &quot;No&quot;, &quot;Yes&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;Y… $ probability_No &lt;dbl&gt; 0.753938094, 0.024780750, 0.915146366, 0.143568754, 0.07… $ probability_Yes &lt;dbl&gt; 0.24606191, 0.97521925, 0.08485363, 0.85643125, 0.927375… XGBoost became well known in the competition circles after its use in the winning solution of the Higgs Machine Learning Challenge which uses the ATLAS experiment to identify the Higgs boson. Since then, it has become a popular model and used for a large number of Kaggle competitions. However, decision trees could prove limiting especially in datasets with non tabular data like images, audio and text which you can tackle with deep learning models, should we remind you to disconnect and restart? 10.5 Deep Learning A perceptron is a mathematical model introduced by Rosenblatt (Rosenblatt 1958) who developed it as a theory for a hypothetical nervous system. The perceptron maps stimuli to numeric inputs that are weighted into a threshold function that activates only when enough stimuli is present, mathematically: \\(f(x) = \\begin{cases} 1 &amp; \\sum_{i=1}^m w_i x_i + b &gt; 0\\\\ 0 &amp; \\text{otherwise} \\end{cases}\\) Minsky found out that a single perceptron can only classify datasets that are linearly separable; however, he also presented in his perceptrons book (Minsky and Papert 2017) that layering perceptrons would bring additional classification capabilities, the original diagram showcasing a multi-layered perceptron is presented in Figure 10.6. FIGURE 10.6: Layered perceptrons as illustrated in the perceptrons book Before we start, let’s first install all the packages we are about to use, install.packages(&quot;sparktf&quot;) install.packages(&quot;tfdatasets&quot;) Using Spark we can create a multi-layer perceptron classifier with ml_multilayer_perceptron_classifier() and gradient descent to classify and predict over large datasets. Gradient descent was introduced to layered perceptrons by Geoff Hinton (Ackley, Hinton, and Sejnowski 1985) and like XGBoost, it also makes use of gradient descent. library(sparktf) library(sparklyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) attrition &lt;- copy_to(sc, rsample::attrition) nn_model &lt;- ml_multilayer_perceptron_classifier( attrition, Attrition ~ Age + DailyRate + DistanceFromHome + MonthlyIncome, layers = c(4, 3, 2), solver = &quot;gd&quot;) nn_model %&gt;% ml_predict(attrition) %&gt;% select(Attrition, predicted_label, starts_with(&quot;probability_&quot;)) %&gt;% glimpse() Observations: ?? Variables: 4 Database: spark_connection $ Attrition &lt;chr&gt; &quot;Yes&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;… $ predicted_label &lt;chr&gt; &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, … $ probability_No &lt;dbl&gt; 0.8439275, 0.8439275, 0.8439275, 0.8439275, 0.8439275,… $ probability_Yes &lt;dbl&gt; 0.1560725, 0.1560725, 0.1560725, 0.1560725, 0.1560725,… Notice that the columns must be numeric so you will have to manually convert them with feature transforming techniques presented in the Modeling chapter. It is natural to try to add more layers to classify more complex datasets; however, adding too many layers will cause the gradient to vanish and other techniques will have to use these deep layered networks also known as, deep learning models. Deep learning models solve the vanishing gradient problem by making use of special activation functions, dropout, data augmentation and graphic processing units (GPUs). You can use Spark to retrieve and preprocess large datasets into numerical-only datasets that can fit in a GPU for deep learning training. Tensorflow is one of the most popular deep learning frameworks and supports a binary format known as TensorFlow Records. You can write TensorFlow records using the sparktf in Spark which you can prepare to process in GPU instances with libraries like Keras or TensorFlow. You can then preprocess large datasets in Spark and write it as TensorFlow records using spark_write_tf(): copy_to(sc, iris) %&gt;% ft_string_indexer_model( &quot;Species&quot;, &quot;label&quot;, labels = c(&quot;setosa&quot;, &quot;versicolor&quot;, &quot;virginica&quot;) ) %&gt;% spark_write_tfrecord(path = &quot;tfrecord&quot;) Once trained, you can use the tfdatasets package to load the dataset followed by training with keras or tensorflow. You will also need to install the TensorFlow runtime with install_tensorflow() and install Python on your own. To learn more about training deep learning models with Keras we recommend reading “Deep Learning with R”. (Chollet and Allaire 2018) tensorflow::install_tensorflow() tfdatasets::tfrecord_dataset(&quot;tfrecord/part-r-00000&quot;) &lt;DatasetV1Adapter shapes: (), types: tf.string&gt; Training deep learning models in a single local node with one or more GPUs is often enough for most applications; however, recent state-of-the-art deep learning models train using distributed computing frameworks like Apache Spark. Distributed computing frameworks are used to achieve higher petaflops each day the systems spends training these models. OpenAI analyzed trends in the field of Artificial Intelligence and cluster computing (“AI and Compute” 2019) and illustrated in Figure 10.7. It should be obvious from the figure that there is a trend in recent years to use distributed computing frameworks. FIGURE 10.7: Training using distributed systems based on OpenAI analysis Training large-scale deep learning models is possible in Spark and TensorFlow through frameworks like Horovod. Today, it’s possible to use Horovod with Spark from R using the reticulate package since Horovod requires Python and Open MPI which goes beyond the scope of this book. Instead, we will introduce a different Spark extension in the domain of genomics. 10.6 Genomics The human genome consists of two copies of about three billion base pairs of DNA within the 23 chromosome pairs, Figure 10.8 shows the organization of the genome into chromosomes. DNA strands are composed of nucleotides, each composed of one of four nitrogen-containing nucleobases: cytosine (C), guanine (G), adenine (A) or thymine (T). (“Human Genome” 2019) Since the DNA of all humans is nearly identical, we only need to store the differences from the reference genome in the form of a Variant Call Format (VCF) file. FIGURE 10.8: The idealized human diploid karyotype showing the organization of the genome into chromosomes VariantSpark is a framework based on scala and spark to analyze genome datasets. It is being developed by CSIRO Bioinformatics team in Australia. VariantSpark was tested on datasets with 3000 samples each one containing 80 million features in either unsupervised clustering approaches and supervised applications, like classification and regression. VariantSpark can read VCF files and run analyses while using familiar Spark DataFrames. To get started, install variantspark from CRAN, connect to Spark and retrieve a vsc connection to VariantSpark: library(variantspark) library(sparklyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;, config = list(sparklyr.connect.timeout = 3 * 60)) vsc &lt;- vs_connect(sc) We can start by loading a VCF file, vsc_data &lt;- system.file(&quot;extdata/&quot;, package = &quot;variantspark&quot;) hipster_vcf &lt;- vs_read_vcf(vsc, file.path(vsc_data, &quot;hipster.vcf.bz2&quot;)) hipster_labels &lt;- vs_read_csv(vsc, file.path(vsc_data, &quot;hipster_labels.txt&quot;)) labels &lt;- vs_read_labels(vsc, file.path(vsc_data, &quot;hipster_labels.txt&quot;)) VariantSpark uses Random Forest to assign an Importance score to each tested variant reflecting its association to the interest phenotype. A variant with higher Importance score implies it is more strongly associated with the phenotype of interest. You can compute the Importance and transform it into a Spark table as follows, importance_tbl &lt;- vs_importance_analysis(vsc, hipster_vcf, labels, n_trees = 100) %&gt;% importance_tbl() importance_tbl # Source: spark&lt;?&gt; [?? x 2] variable importance &lt;chr&gt; &lt;dbl&gt; 1 2_109511398 0 2 2_109511454 0 3 2_109511463 0.00000164 4 2_109511467 0.00000309 5 2_109511478 0 6 2_109511497 0 7 2_109511525 0 8 2_109511527 0 9 2_109511532 0 10 2_109511579 0 # … with more rows You can then use dplyr and ggplot2 to transform the output and visualize it, library(dplyr) library(ggplot2) importance_df &lt;- importance_tbl %&gt;% arrange(-importance) %&gt;% head(20) %&gt;% collect() ggplot(importance_df) + aes(x = variable, y = importance) + geom_bar(stat = &#39;identity&#39;) + scale_x_discrete(limits = importance_df[order(importance_df$importance), 1]$variable) + coord_flip() FIGURE 10.9: Genomic importance analysis using variantspark This concludes a brief introduction to genomic analysis in Spark using the variantspark extensions. Next, we will move away from microscopic genes, to macroscopic datasets that contain geographic locations across the world. 10.7 Spatial geospark enables distributed geospatial computing using a grammar compatible with dplyr and sf package which provides a set of tools for working with geospatial vectors. You can install geospark from CRAN as follows: install.packages(&quot;geospark&quot;) Then we will initialize the geospark extension and connect to Spark: library(geospark) library(sparklyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) Next we will load a spatial dataset containing polygons and points. polygons &lt;- system.file(&quot;examples/polygons.txt&quot;, package=&quot;geospark&quot;) %&gt;% read.table(sep=&quot;|&quot;, col.names = c(&quot;area&quot;, &quot;geom&quot;)) points &lt;- system.file(&quot;examples/points.txt&quot;, package=&quot;geospark&quot;) %&gt;% read.table(sep = &quot;|&quot;, col.names = c(&quot;city&quot;, &quot;state&quot;, &quot;geom&quot;)) polygons_wkt &lt;- copy_to(sc, polygons) points_wkt &lt;- copy_to(sc, points) There are various spatial operations defined in geospark, which Figure 10.10 describes. These operations allow you to control how geospatial data should be queried based on overlap, intersection, disjoint sets, etc. FIGURE 10.10: Spatial operations available in geospark. For instance, we can use these operations to find the polygons that contain a given set of points using st_contains(), library(dplyr) polygons_wkt &lt;- mutate(polygons_wkt, y = st_geomfromwkt(geom)) points_wkt &lt;- mutate(points_wkt, x = st_geomfromwkt(geom)) inner_join(polygons_wkt, points_wkt, sql_on = sql(&quot;st_contains(y,x)&quot;)) %&gt;% group_by(area, state) %&gt;% summarise(cnt = n()) # Source: spark&lt;?&gt; [?? x 3] # Groups: area area state cnt &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 california area CA 10 2 new york area NY 9 3 dakota area ND 10 4 texas area TX 10 5 dakota area SD 1 You can also plot these datasets by collecting a subset of the entire dataset or aggregating the geometries in spark before collecting them, one package you should look into is the sf package. We will now start closing this chapter by presenting a couple troubleshooting techniques applicable to all extensions. 10.8 Troubleshooting When using a new extension for the first time, we recommend increasing the connection timeout since Spark will usually have to download extension dependencies and changing logging to verbose to help troubleshoot when the download process does not complete: config &lt;- spark_config() config$sparklyr.connect.timeout &lt;- 3 * 60 config$sparklyr.log.console = TRUE sc &lt;- spark_connect(master = &quot;local&quot;, config = config) In addition, you should know that Apache IVY is a popular dependency manager focusing on flexibility, simplicity, and is used by Apache Spark while installing extensions. When the connection fails while using an extension, consider clearing your IVY Cache by running: unlink(&quot;~/.ivy2&quot;, recursive = TRUE) In addition, you can also consider opening GitHub issues from the following extensions repos to get help from the extension authors: rsparkling: github.com/h2oai/sparkling-water. sparkxgb: github.com/rstudio/sparkxgb. sparktf: github.com/rstudio/sparktf. variantspark: github.com/r-spark/variantspark. geospark: github.com/r-spark/geospark. 10.9 Recap This chapter provided a brief overview on using some of the Spark extensions available in R, which happens to be as easy as installing a package. You then learned how to use the rsparkling extension which provides access to H2O in Spark to which provides additional modeling functionality like enhanced metrics and ability to automatically select models. We then jumped to graphframes, an extension to help you process relational datasets which are formally referred as graphs; you learned how to compute simple connection metrics or run complex algorithms like pagerank. THe XGBoost and Deep Learning sections provided alternate modeling techniques that use gradient descent, the former over decision trees and the latter over deep multi-layered perceptrons where Spark can be used to preprocess datasets into records that can then be later consument by TensorFlow and Keras using the sparktf extension. The last two sections introduced extensions to process genomic and spatial datasets through the variantspark and geospark extensions. These extensions and many more, provide a comprehensive library of advanced functionality that in combination with analysis and modeling techniques presented, should cover most tasks required to run in computing clusters. However, when functionality is lacking, you can consider writing your own extension as we will present in the Contributing chapter or you can apply custom transformations over each partition using R code as we will describe in the next chapter, Distributed R. References "],
["distributed.html", "Chapter 11 Distributed R 11.1 Overview 11.2 Use Cases 11.3 Partitions 11.4 Grouping 11.5 Columns 11.6 Context 11.7 Functions 11.8 Packages 11.9 Cluster Requirements 11.10 Troubleshooting 11.11 Recap", " Chapter 11 Distributed R “Not like this. Not like this. Not like this.” — Cersei Lannister In previous chapters you learned how to perform data analysis and modeling in local Spark instances and proper Spark clusters and the previous Extensions chapter described how to make use of additional functionality provided by the Spark and R communities at large. In most cases, the combination of Spark functionality and extensions is more than enough to perform almost any computation. However, for those cases where functionality is lacking in Spark and their extensions, you can consider distributing R computations to worker nodes yourself. You can run arbitrary R code in each worker node to run any computation – you can run simulations, crawl content from the web, transform data and so on. In addition, you can also make use of any package available in CRAN and private packages available in your organization, this reduces the amount of code you need to write to help you keep productive. If you are already familiar with R, you might be tempted to use this approach for all Spark operations; however, this is not the recommended use of spark_apply(). Previous chapters provided more efficient techniques and tools to solve well known problems – in contrast, spark_apply() introduces additional cognitive overhead, additional troubleshooting steps, performance trade-offs and, in general, additional complexity that should be avoided. Not to say that spark_apply() should never be used; but instead, spark_apply() is reserved to support use cases where previous tools and techniques fell short. 11.1 Overview The Introduction chapter introduced MapReduce as a technique capable of processing large-scale datasets; it also described how Apache Spark provided a superset of operations to perform MapReduce computations with ease and more efficiently. The Tuning chapter presented insights into how Spark works by applying custom transformation over each partition of the distributed datasets. For instance, if we were to multiply by ten each element of a distributed numeric dataset, Spark would apply a mapping operation over each partition through multiple workers, conceptually, this is illustrated in Figure 11.1. FIGURE 11.1: Map Operation when Multiplying by Ten This chapter presents how to define a custom f(x) mapping operation using spark_apply(); for the previous example, spark_apply() provides support to define 10 * x as follows: sdf_len(sc, 3) %&gt;% spark_apply(~ 10 * .x) # Source: spark&lt;?&gt; [?? x 1] id * &lt;dbl&gt; 1 10 2 20 3 30 Notice that ~ 10 * .x is plain R code executed across all worker nodes; the ~ operator is defined in the rlang package and provides a compact definition of a function equivalent to function(.x) 10 * .x – this compact form is also known as an anonymous function or lambda expression. The f(x) function must take an R data frame as input and must also produce an R data frame as output, conceptually illustrated in Figure 11.2. FIGURE 11.2: Expected Function Signature in spark_apply() Mappings We can refer back to the original MapReduce example from the Introduction chapter, where the map operation was defined to split sentences into words and then, the total unique words were counted as the reduce operation. In R, we could make use of the unnest_tokens() function from the tidytext R package, which you would need to install from CRAN before conneceting to Spark. You can then use tidytext with spark_apply() to tokenize those sentences into a table of words: sentences &lt;- copy_to(sc, data_frame(text = c(&quot;I like apples&quot;, &quot;I like bananas&quot;))) sentences %&gt;% spark_apply(~tidytext::unnest_tokens(.x, word, text)) # Source: spark&lt;?&gt; [?? x 1] word * &lt;chr&gt; 1 i 2 like 3 apples 4 i 5 like 6 bananas Finally, we can reduce this dataset using dplyr to compute this original MapReduce word-count example using dplyr as follows: sentences %&gt;% spark_apply(~tidytext::unnest_tokens(., word, text)) %&gt;% group_by(word) %&gt;% summarise(count = count()) # Source: spark&lt;?&gt; [?? x 2] word count * &lt;chr&gt; &lt;dbl&gt; 1 i 2 2 apples 1 3 like 2 4 bananas 1 The rest of this chapter will explain in detail use cases, features, caveats, considerations and troubleshooting techniques required when defining custom mappings through spark_apply() Note: The previous sentence tokenizer example can be more efficiently implemented using concepts from previous chapters, specifically through sentences %&gt;% ft_tokenizer(\"text\", \"words\") %&gt;% transmute(word = explode(words)). 11.2 Use Cases In the overview section we presented an example to help you understand how spark_apply() works; this section will cover a few practical use cases for spark_apply(): Import You can consider using R to import data from external data sources and formats. For example, when a file format is not natively supported in Spark or its extensions, you can consider using R code to implement a distributed custom parser using R packages. Model It is natural to use the rich modeling capabilities already available in R with Spark. In most cases, R models can’t be used across large data; however, we will present two particular use cases where R models can be useful at scale. For instance, when data fits into a single machine you can make use of grid search to optimize their parameters in parallel. In cases where the data can be partitioned to create several models over subsets of the data you can use partitioned modeling in R to compute models across partitions. Transform You can make use of R’s rich data transformation capabilities to complement Spark. We will present a use case of evaluating data by external systems and use R to interoperate with them by calling them through a web API. Compute When you need to perform large-scale computation in R, or big-compute as described in the Introduction chapter, Spark is ideal to distribute this computation. We will present simulations as a particular use case for large-scale computing in R. We will now explore each use case in detail and provide a working example to help you understand how you use spark_apply() effectively. 11.2.1 Custom Parsers While Spark and its various extensions provide support for many file formats (CSVs, JSON, Parquet, AVRO, etc) there are many more file formats that you might need to use at scale. You can parse these additional formats using spark_apply() and many of the existing R packages. In this section we will understand how to parse log files, but similar approaches can be followed to parse other file formats. It is common to use Spark to analyze log files; for instance, logs that track download data from Amazon S3. To parse logs, the webreadr package can simplify this process by providing support to load logs stored as: Amazon S3, Squid and the Common log format. You should install webreadr from CRAN before connecting to Spark. For example, an Amazon S3 log looks as follows. #Version: 1.0 #Fields: date time x-edge-location sc-bytes c-ip cs-method cs(Host) cs-uri-stem sc-status cs(Referer) cs(User-Agent) cs-uri-query cs(Cookie) x-edge-result-type x-edge-request-id x-host-header cs-protocol cs-bytes time-taken 2014-05-23 01:13:11 FRA2 182 192.0.2.10 GET d111111abcdef8.cloudfront.net /view/my/file.html 200 www.displaymyfiles.com Mozilla/4.0%20 (compatible;%20MSIE%205.0b1;%20Mac_PowerPC) - zip=98101 RefreshHit MRVMF7KydIvxMWfJIglgwHQwZsbG2IhRJ07sn9AkKUFSHS9EXAMPLE== d111111abcdef8.cloudfront.net http - 0.001 Which can be parsed easily with read_aws() as follows: aws_log &lt;- system.file(&quot;extdata/log.aws&quot;, package = &quot;webreadr&quot;) webreadr::read_aws(aws_log) # A tibble: 2 x 18 date edge_location bytes_sent ip_address http_method host path &lt;dttm&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 2014-05-23 01:13:11 FRA2 182 192.0.2.10 GET d111… /vie… 2 2014-05-23 01:13:12 LAX1 2390282 192.0.2.2… GET d111… /sou… # ... with 11 more variables: status_code &lt;int&gt;, referer &lt;chr&gt;, user_agent &lt;chr&gt;, # query &lt;chr&gt;, cookie &lt;chr&gt;, result_type &lt;chr&gt;, request_id &lt;chr&gt;, # host_header &lt;chr&gt;, protocol &lt;chr&gt;, bytes_received &lt;chr&gt;, time_elapsed &lt;dbl&gt; To scale this operation, we can make use of read_aws() using spark_apply(): spark_read_text(sc, &quot;logs&quot;, aws_log, overwrite = TRUE, whole = TRUE) %&gt;% spark_apply(~webreadr::read_aws(.x$contents)) # Source: spark&lt;?&gt; [?? x 18] date edge_location bytes_sent ip_address http_method host path * &lt;dttm&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 2014-05-23 01:13:11 FRA2 182 192.0.2.10 GET d111… /vie… 2 2014-05-23 01:13:12 LAX1 2390282 192.0.2.2… GET d111… /sou… # ... with 11 more variables: status_code &lt;int&gt;, referer &lt;chr&gt;, user_agent &lt;chr&gt;, # query &lt;chr&gt;, cookie &lt;chr&gt;, result_type &lt;chr&gt;, request_id &lt;chr&gt;, # host_header &lt;chr&gt;, protocol &lt;chr&gt;, bytes_received &lt;chr&gt;, time_elapsed &lt;dbl&gt; The code between plain R and spark_apply() is similar; however, when using spark_apply() logs are parsed in parallel across all the worker nodes available in your cluster. This concludes the custom parsers section, there are many other file formats you can parse at scale from R following a similar approach. We will now present partitioned modeling as another use case focused on modeling across several datasets in parallel. 11.2.2 Partitioned Modeling There are many modeling packages available in R that can also be run at scale by partitioning the data into manageable groups that do fit in the resources of a single machine. For instance, suppose that you have a 1TB dataset for sales data across multiple cities and you are tasked with creating sales predictions over each city. For this case, you can consider partitioning the original dataset per city, say into 10GB of data per city, which could be managed by a single compute instance. For this kind of partitionable dataset, you can also consider using spark_apply() by training each model over each city. As a simple example of partitioned modeling, we can run a linear regression using the iris dataset partitioned by Species: iris &lt;- copy_to(sc, datasets::iris) iris %&gt;% spark_apply(nrow, group_by = &quot;Species&quot;) # Source: spark&lt;?&gt; [?? x 2] Species result &lt;chr&gt; &lt;int&gt; 1 versicolor 50 2 virginica 50 3 setosa 50 Then you can run a linear regression over each species using spark_apply(): iris %&gt;% spark_apply( function(e) summary(lm(Petal_Length ~ Petal_Width, e))$r.squared, names = &quot;r.squared&quot;, group_by = &quot;Species&quot;) # Source: spark&lt;?&gt; [?? x 2] Species r.squared &lt;chr&gt; &lt;dbl&gt; 1 versicolor 0.619 2 virginica 0.104 3 setosa 0.110 As you can see from the r.squared results and intuitively in Figure 11.3, the linear model for versicolor better fits to the regression line. purrr::map(c(&quot;versicolor&quot;, &quot;virginica&quot;, &quot;setosa&quot;), ~dplyr::filter(datasets::iris, Species == !!.x) %&gt;% ggplot2::ggplot(ggplot2::aes(x = Petal.Length, y = Petal.Width)) + ggplot2::geom_point()) FIGURE 11.3: Modeling over Species This concludes our brief overview on how to perform modeling over several different, partitionable, datasets. A similar technique can be applied to perform modeling over the same dataset using different modeling parameters which we will cover next. 11.2.3 Grid Search Many R packages provide models that require defining multiple parameters to configure and optimize their particular models. When the value of these parameters is unknown, we can distribute this list of unknown parameters across a cluster of machines to find the optimal parameter combination. If the list contains more than one parameter to optimize, it is common to test against all the combinations between parameter A and parameter B, creating a grid of parameters. The process of searching for the best parameter over this parameter grid is commonly known as grid search. For example, we can define a grid of parameters to optimize decision tree models as follows: grid &lt;- list(minsplit = c(2, 5, 10), maxdepth = c(1, 3, 8)) %&gt;% purrr:::cross_df() %&gt;% copy_to(sc, ., repartition = 9) grid # Source: spark&lt;?&gt; [?? x 2] minsplit maxdepth &lt;dbl&gt; &lt;dbl&gt; 1 2 1 2 5 1 3 10 1 4 2 3 5 5 3 6 10 3 7 2 8 8 5 8 9 10 8 The grid dataset was copied with repartition = 9 to ensure that each partition is contained in one machine since the grid has also nine rows. Now, assuming that the original dataset fits in every machine, we can distribute this dataset to many machines and perform parameter search to find the model that best fits this data. spark_apply( grid, function(grid, cars) { model &lt;- rpart::rpart( am ~ hp + mpg, data = cars, control = rpart::rpart.control(minsplit = grid$minsplit, maxdepth = grid$maxdepth) ) dplyr::mutate( grid, accuracy = mean(round(predict(model, dplyr::select(cars, -am))) == cars$am) ) }, context = mtcars) # Source: spark&lt;?&gt; [?? x 3] minsplit maxdepth accuracy &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 2 1 0.812 2 5 1 0.812 3 10 1 0.812 4 2 3 0.938 5 5 3 0.938 6 10 3 0.812 7 2 8 1 8 5 8 0.938 9 10 8 0.812 For this particular model, minsplit = 2 and maxdepth = 8 produces the most accurate results. You can now use this specific parameter combination to properly train model. 11.2.4 Web APIs A Web API is a program that can do something useful through a web interface that other programs can reuse. For instance, services like Twitter provide Web APIs that allow you to automate reading tweets from a program written in R and other programming languages. You can make use of Web APIs using spark_apply() by sending programmatic requests to external services using R code. For example, Google provides a Web API to label images using deep learning techniques; you can make use of this API from R, but for larger datasets, you would need to access their APIs from Spark. You can use Spark to prepare data to be consumed by a webAPI, then use spark_apply() to perform this call and process all the incoming results back in Spark. The following example makes use of the googleAuthR package to authenticate to Google Cloud, the RoogleVision package to perform labeling over the Google Vision API, and spark_apply() to interoperate between Spark and Google’s deep learning service. If you want to run the following example you will need to disconnect first from Spark and download your cloudml.json from the Google developer portal. sc &lt;- spark_connect( master = &quot;local&quot;, config = list(sparklyr.shell.files = &quot;cloudml.json&quot;)) images &lt;- copy_to(sc, data.frame( image = &quot;http://pbs.twimg.com/media/DwzcM88XgAINkg-.jpg&quot; )) spark_apply(images, function(df) { googleAuthR::gar_auth_service( scope = &quot;https://www.googleapis.com/auth/cloud-platform&quot;, json_file = &quot;cloudml.json&quot;) RoogleVision::getGoogleVisionResponse( df$image, download = FALSE) }) # Source: spark&lt;?&gt; [?? x 4] mid description score topicality &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 /m/04rky Mammal 0.973 0.973 2 /m/0bt9lr Dog 0.958 0.958 3 /m/01z5f Canidae 0.956 0.956 4 /m/0kpmf Dog breed 0.909 0.909 5 /m/05mqq3 Snout 0.891 0.891 In order to successfully run a large distributed computation over a Web API, the Web API would have to be able to scale to support the load from all the Spark executors. One can trust that major service providers are likely to support all the requests incoming from your cluster. However, when calling internal Web APIs, make sure the API can handle the load. Also, when using third-party services, consider the cost of calling their API across all the executors in your cluster to avoid potentially expensive and unexpected charges. Next you will learn a use case for large-compute where R is used to perform distributed rendering. 11.2.5 Simulations R can be used in combination with Spark to perform large-scale computing. The use case we will explore in this section is rendering computationally-expensive images using the rayrender package, which uses ray tracing – a photorealistic technique commonly used in movie production. Let’s use this package to render a simple scene that includes a few spheres with using a lambertian material, a diffusely reflecting material or “matte”; but first, install using install.packages(\"rayrender\"), make sure to also disconnect and reconnect from Spark. library(rayrender) scene &lt;- generate_ground(material = lambertian()) %&gt;% add_object(sphere(material = metal(color=&quot;orange&quot;), z = -2)) %&gt;% add_object(sphere(material = metal(color=&quot;orange&quot;), z = +2)) %&gt;% add_object(sphere(material = metal(color=&quot;orange&quot;), x = -2)) render_scene(scene, lookfrom = c(10, 5, 0), parallel = TRUE) FIGURE 11.4: Ray tracing in Spark using R and rayrender In higher definitions, say 1920x1080, the previous example takes several minutes to render the single frame from Figure 11.4, rendering a few seconds at 30 frames-per-second would take several hours in a single machine. However, we can reduce this time using multiple machines by parallelizing computation across them. For instance, using ten machines with the same amount of CPUs would cut rendering time ten fold: system2(&quot;hadoop&quot;, args = c(&quot;fs&quot;, &quot;-mkdir&quot;, &quot;/rendering&quot;)) sdf_len(sc, 628, repartition = 628) %&gt;% spark_apply(function(idx, scene) { render &lt;- sprintf(&quot;%04d.png&quot;, idx$id) rayrender::render_scene(scene, width = 1920, height = 1080, lookfrom = c(12 * sin(idx$id/100), 5, 12 * cos(idx$id/100)), filename = render) system2(&quot;hadoop&quot;, args = c(&quot;fs&quot;, &quot;-put&quot;, render, &quot;/user/hadoop/rendering/&quot;)) }, context = scene, columns = list()) %&gt;% collect() After all the images are rendered, the last step is to collect them from HDFS and use tools like ffmpeg to convert individual images into an animation: hadoop fs -get rendering/ ffmpeg -s 1920x1080 -i rendering/%d.png -vcodec libx264 -crf 25 -pix_fmt yuv420p rendering.mp4 Note: This example assumes HDFS is used as the storage technology for Spark and being run under a hadoop user, you will need to adjust this for your particular storage or user. We’ve covered some of the common use cases for spark_apply(), but you are certainly welcome to find other use cases for your particular needs. The following sections will present technical concepts you will need to understand to create additional use cases and to use spark_apply() effectively. 11.3 Partitions Most Spark operations, say to analyze data with dplyr or model with MLlib, do not require understanding how Spark partitions data, it works automatically – this is not the case for distributed R computations. Instead, you will have to learn and understand how exactly Spark is partitioning your data and provide transformations that are compatible with them. This is required since spark_apply() receives each partition and allows you to perform any transformation, not the entire dataset. You can refresh concepts like partitioning and transformations using the diagrams and examples from the Tuning chapter. To help us understand how partitions are represented in spark_apply(), consider the following code. Should we expect the output to be the total number of rows? sdf_len(sc, 10) %&gt;% spark_apply(~nrow(.x)) # Source: spark&lt;?&gt; [?? x 1] result * &lt;int&gt; 1 5 2 5 As you can see from the results, the general the answer is no; Spark assumes data will be distributed across multiple machines so you will often find it already partitioned, even for small datasets. So we should not expect spark_apply() to operate over a single partition, let’s find out how many partitions sdf_len(sc, 10) contains: sdf_len(sc, 10) %&gt;% sdf_num_partitions() [1] 2 This explains why counting rows through nrow() under spark_apply() retrieves two rows since there are two partitions, not one. spark_apply() is retrieving the count of rows over each partition, each partition contains five rows; not ten rows total as you might have expected. For this particular example, we could further aggregate these partitions by repartitioning and then adding up – this would resemble a simple MapReduce operation using spark_apply(): sdf_len(sc, 10) %&gt;% spark_apply(~nrow(.x)) %&gt;% sdf_repartition(1) %&gt;% spark_apply(~sum(.x)) # Source: spark&lt;?&gt; [?? x 1] result * &lt;int&gt; 1 10 It was the intent of this section is to make you aware of partitions while using spark_apply(); the next section presents group_by as a way to control partitions. 11.4 Grouping When using spark_apply(), we can request explicit partitions from Spark. For instance, if we had to process numbers less than four in one partition and the remaining ones in a second partition, we could create these groups explicitly and then request spark_apply() to use them: sdf_len(sc, 10) %&gt;% transmute(groups = id &lt; 4) %&gt;% spark_apply(~nrow(.x), group_by = &quot;groups&quot;) # Source: spark&lt;?&gt; [?? x 2] groups result * &lt;lgl&gt; &lt;int&gt; 1 TRUE 3 2 FALSE 7 Notice that spark_apply() is still processing two partitions, but in this case, we expect these partitions since we explicitly requested them in spark_apply(); therefore, you can safely interpret the results as “there are three integers less than four”. Note: You can only group data by partitions that fit in a single machine, if one of the groups is too large, an exception will be thrown. To perform operations over groups that exceed the resources of a single node, you can consider partitioning to smaller units or use dplyr::do which is currently optimized for large partitions. The takeaway from this section is to always consider partitions when dealing with spark_apply(). Next, we will zoom inside spark_apply() to understand how columns are interpreted. 11.5 Columns By default, spark_apply(), will inspect the data frame being produced to find out column names and types automatically, for example: sdf_len(sc, 1) %&gt;% spark_apply(~ data.frame(numbers = 1, names = &quot;abc&quot;)) # Source: spark&lt;?&gt; [?? x 2] numbers names * &lt;dbl&gt; &lt;chr&gt; 1 1 abc However, this is inefficient since spark_apply() needs to run twice. First to find columns by computing spark_apply() against a subset of all the data, and then to compute the actual desired values. To improve performance, the columns can be specified explicitly through the columns parameters. The columns expects a named list of types expected in the resulting data frame. We can then rewrite the previous example to run only once by specifying the correct type for the numbers column: sdf_len(sc, 1) %&gt;% spark_apply( ~ data.frame(numbers = 1, names = &quot;abc&quot;), columns = list(numbers = &quot;double&quot;, names = &quot;character&quot;)) # Source: spark&lt;?&gt; [?? x 2] numbers names * &lt;dbl&gt; &lt;chr&gt; 1 1 abc In this section and the previous one, we presented how rows and columns interact with spark_apply(). The following section will allow us to make use of contextual information that is sometimes required when processing distributed datasets. 11.6 Context In order to process partitions using spark_apply(), you might need to include auxility data that is small-enough to fit in each node. This was the case in the Grid Search use case, where the dataset was passed to all partitions and remained unpartitioned itself. We can modify the initial f(x) = 10 * x example in this chapter to allow us to customize the multiplier – it was originally set to 10 but we can make it configurable by specifying it as the context parameter. sdf_len(sc, 4) %&gt;% spark_apply( function(data, context) context * data, context = 100 ) # Source: spark&lt;?&gt; [?? x 1] id &lt;dbl&gt; 1 100 2 200 3 300 4 400 Figure 11.5 illustrates this example conceptually. Notice that the data partitions are still variable; however, the contextual parameter is distributed to all the nodes. FIGURE 11.5: Map Operation when Multiplying with Context The grid search example used this parameter to pass a data frame to each worker node; however, since the context parameter is serialized as an R object, it can contain anything. For instance, if you need to pass multiple values – or even multiple datasets – you can pass a list with values. The following example defines a f(x) = m * x + b function and runs m = 10 and b = 2: sdf_len(sc, 4) %&gt;% spark_apply( ~.y$m * .x + .y$b, context = list(b = 2, m = 10) ) # Source: spark&lt;?&gt; [?? x 1] id &lt;dbl&gt; 1 12 2 22 3 32 4 42 Notice that we’ve renamed context to .y to shorten the variable name, this works since spark_apply() assumes context is the second parameter in functions and expressions. The context parameter will proof to be extremely useful; for instance, the next section will present how to properly construct functions, and context will be used in advanced use cases to construct functions dependent on other functions. 11.7 Functions Previous sections presented spark_apply() as an operation to perform custom transformations using a function or expression, in programming literature functions with a context are also referred as a closure. Expressions are useful to define short transformations, like ~ 10 * .x. For an expression, .x contains a partition and .y the context, when available. However, it can be hard to define an expression for complex code that spans multiple lines, for those cases, functions are more appropriate. Functions enable complex and multi-line transformations, they are defined as function(data, context) {} and allow you to provide arbitrary code within {}. We’ve used them in previous sections when using Google Cloud to transform images into image captions. The function passed to spark_apply() is serialized using serialize(), which is described as “a simple low-level interface for serializing to connections.”. One of the current limitations of serialize() is that it won’t serialize objects being referenced outside of its environment. For instance, the following function will error out since the closures references external_value: external_value &lt;- 1 spark_apply(iris, function(e) e + external_value) As workarounds to this limitation, you can add the functions your closure needs into the context followed by assigning the functions into the global environment: func_a &lt;- function() 40 func_b &lt;- function() func_a() + 1 func_c &lt;- function() func_b() + 1 sdf_len(sc, 1) %&gt;% spark_apply(function(df, context) { for (name in names(context)) assign(name, context[[name]], envir = .GlobalEnv) func_c() }, context = list( func_a = func_a, func_b = func_b, func_c = func_c )) # Source: spark&lt;?&gt; [?? x 1] result &lt;dbl&gt; 1 42 When this is not feasible, you can also create your own R package with the functionality you need and then use your package in spark_apply(). Up to this point, you’ve learned all the functionality available in spark_apply() using plain R code; however, we have not presented how to use packages when distributing computations – R packages are essential when creating useful transformations. 11.8 Packages With spark_apply() you can use any R package inside Spark. For instance, you can use the broom package to create a tidy data frame from linear regression output. spark_apply( iris, function(e) broom::tidy(lm(Petal_Length ~ Petal_Width, e)), names = c(&quot;term&quot;, &quot;estimate&quot;, &quot;std.error&quot;, &quot;statistic&quot;, &quot;p.value&quot;), group_by = &quot;Species&quot;) # Source: spark&lt;?&gt; [?? x 6] Species term estimate std.error statistic p.value &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 versicolor (Intercept) 1.78 0.284 6.28 9.48e- 8 2 versicolor Petal_Width 1.87 0.212 8.83 1.27e-11 3 virginica (Intercept) 4.24 0.561 7.56 1.04e- 9 4 virginica Petal_Width 0.647 0.275 2.36 2.25e- 2 5 setosa (Intercept) 1.33 0.0600 22.1 7.68e-27 6 setosa Petal_Width 0.546 0.224 2.44 1.86e- 2 The first time you call spark_apply() all of the contents in your local .libPaths(), which contains all R packages, will be copied into each Spark worker node. Packages will only be copied once and will persist as long as the connection remains open. It’s not uncommon for R libraries to be several gigabytes in size, so be prepared for a one-time tax while the R packages are copied over to your Spark cluster. You can disable package distribution by setting packages = FALSE. Note: Since packages are copied only once for the duration of the spark_connect() connection, installing additional packages is not supported while the connection is active. Therefore, if a new package needs to be installed, spark_disconnect() the connection, modify packages and reconnect. In addition, R packages are not copied in local mode because the packages already exist on the local system. While this was a short section, using packages with distributed R code opens up an entire new universe of interesting use cases. Somewhere covered in the use cases section, but you can think of many more by looking at the rich ecosystem of R packages available today. This section completes all the functionality you need to distribute R code with R packages, next we will cover some of the requirements your cluster needs to make use of spark_apply(). 11.9 Cluster Requirements All the functionality presented in previous chapters, does not require any special configuration of your Spark cluster – as long as you have a properly configured Spark cluster, you can use R with it. This is not the case for the functionality presented in this chapter, your cluster administrator, your cloud provider or yourself will have to configure your cluster by: Installing R in every node, to execute R code across your cluster. Optionally, installing Apache Arrow in every node when using Spark 2.3 or later, Arrow provides performance improvements that bring distributed R code closer to native Scala code. Let’s take a look at each requirement to make sure you properly consider the tradeoffs or benefits that they provide. 11.9.1 Installing R Starting with the first requirement, the R Runtime is expected to be pre-installed in every node in the cluster, this is a requirement specific to spark_apply(). Failure to install R in every node will trigger a Cannot run program, no such file or directory error while attempting to use spark_apply(). Contact your cluster administrator to consider making the R runtime available throughout the entire cluster. If R is already installed, you can specify the installation path to use using the spark.r.command configuration setting, as in: config &lt;- spark_config() config[&quot;spark.r.command&quot;] &lt;- &quot;&lt;path-to-r-version&gt;&quot; sc &lt;- spark_connect(master = &quot;local&quot;, config = config) sdf_len(sc, 10) %&gt;% spark_apply(function(e) e) A Homogeneous Cluster is required since the driver node distributes, and potentially compiles, packages to the workers. For instance, the driver and workers must have the same processor architecture, system libraries, etc. This is usually the case for most clusters, but might not be the case for yours. Different cluster managers, Spark distributions and cloud providers, support different solutions to install additional software, like R, across every node in the cluster; those instructions should be followed when installing R over each worker node. To mention a few, Spark Standalone Requires connecting to each machine and installing R; there are tools like pssh that allow you to run a single installation command against multiple machines. Cloudera Provides an R parcel, see “How to Distribute your R code with sparklyr and Cloudera Data Science Workbench” (???), which enables R over each worker node. Amazon EMR R is pre-installed when starting an EMR cluster as mentioned in the Amazon EMR section. Microsoft HDInsight R is pre-installed and no additional steps are needed. Livy Livy connections do not support distributing packages since the client machine where the libraries are precompiled might not have the same processor architecture, nor operating systems than the cluster machines. Strictly speaking, this completes the last requirement for your cluster. However, we strongly recommend you use Apache Arrow with spark_apply() to support large-scale computation with minimal overhead. 11.9.2 Apache Arrow Before we introduce Apache Arrow, we need to present how data is stored and transferred between Spark and R. R was designed from its inception to perform fast numeric computations, to accomplish this, figuring out the best way to store data is very important. Some computing systems store data internally by row; however, most interesting numerical operations usually require processing data by column. For example, calculating the mean of a column requires processing each column on its own, not the entire row. Spark stores data by default by row, since it’s easier to partition; in contrast, R stores data by column. Therefore, something needs to transform both representations when data is transferred between Spark and R, see Figure 11.6. FIGURE 11.6: Data Transformation between Spark and R This transformation from rows to columns needs to happen for each partition. In addition, data also needs to be transformed from Scala’s internal representation to R’s internal representation. These transformations wastes a lot of CPU cycles, Apache Arrow reduces these transformations. Apache Arrow is a cross-language development platform for in-memory data. In Spark, it speeds up transferring data between Scala and R by defining a common data format compatible with many programming languages – instead of having to transform between Scala’s internal representation and R’s, the same structure can be used for both languages. In addition, transforming data from row based storage to columnar storage, is performed in parallel in Spark, which can be further optimized by using the columnar storage formats presented in the Data chapter. The improved transformation are available in Figure 11.6. FIGURE 11.7: Data Transformation between Spark and R using Arrow Arrow is not required but it is strongly advised while working spark_apply(). It has been available since Spark 2.3.0; however, it requires system administrators to install the Apache Arrow runtime in every node, see arrow.apache.org/install. In addition, to use Apache Arrow with sparklyr you also need to install the arrow package: install.packages(&quot;arrow&quot;) Before we use arrow, we will take a measurement to validate system.time( sdf_len(sc, 10^4) %&gt;% spark_apply(nrow) %&gt;% collect() ) user system elapsed 0.240 0.020 7.957 In our particular system, processing 10K rows takes about 8 seconds. To enable Arrow, simply include the library and use spark_apply() as usual. Lets measure how long it takes spark_apply() to process 1M rows: library(arrow) system.time( sdf_len(sc, 10^6) %&gt;% spark_apply(nrow) %&gt;% collect() ) user system elapsed 0.317 0.021 3.922 In our system, Arrow can process 100X more data in half the time, just 4 seconds. Most functionality in arrow simply works on the background improving performance and data serialization; however, there is one setting you should be aware of. The spark.sql.execution.arrow.maxRecordsPerBatch configuration settings specifies the default size of each arrow data transfer. It’s shared with other Spark components and defaults to 10,000 rows. library(arrow) sdf_len(sc, 2 * 10^4) %&gt;% spark_apply(nrow) # Source: spark&lt;?&gt; [?? x 1] result &lt;int&gt; 1 10000 2 10000 You might need to adjust this number based on how much data your system can handle, making it smaller for large dataset or bigger for operations that require records to be processed together. We can change this setting to 5K rows and verify the partitions change appropriately: config &lt;- spark_config() config$spark.sql.execution.arrow.maxRecordsPerBatch &lt;- 5 * 10^3 sc &lt;- spark_connect(master = &quot;local&quot;, config = config) sdf_len(sc, 2 * 10^4) %&gt;% spark_apply(nrow) # Source: spark&lt;?&gt; [?? x 1] result &lt;int&gt; 1 5000 2 5000 3 5000 4 5000 So far we’ve presented use cases, main operations and cluster requirements. The next and last section will teach you troubleshooting techniques useful when distributing R code. 11.10 Troubleshooting A custom transformation can fail for many reasons, to learn how to troubleshoot errors, lets simulate a problem by triggering an errors ourselves: sdf_len(sc, 1) %&gt;% spark_apply(~stop(&quot;force an error&quot;)) Error in force(code) : sparklyr worker rscript failure, check worker logs for details Log: wm_bx4cn70s6h0r5vgsldm0000gn/T/Rtmpob83LD/file2aac1a6188_spark.log ---- Output Log ---- 19/03/11 14:12:24 INFO sparklyr: Worker (1) completed wait using lock for RScript Notice that the error message points out to inspect the logs. When running in local mode, you can simply run: spark_log(sc, filter = &quot;terminated unexpectedly&quot;) 19/03/11 14:12:24 ERROR sparklyr: RScript (1) terminated unexpectedly: force an error Which points out to the artificial stop(\"force an error\") error we introduced ourselves. However, if you are not working in local mode, you will have to retrieve the worker logs from your cluster manager. Since this can be cumbersome, one alternative is to rerun spark_apply() but return the error message yourself: sdf_len(sc, 1) %&gt;% spark_apply(~tryCatch( stop(&quot;force an error&quot;), error = function(e) e$message )) # Source: spark&lt;?&gt; [?? x 1] result &lt;chr&gt; 1 force an error There are a few other more advanced troubleshooting techniques applicable to spark_apply(), the following sections present these techniques in-order; meaning, you should try to troubleshoot using worker logs first, followed by identifying partitioning errors and finally, attempting to debug a worker node. 11.10.1 Worker Logs Whenever spark_apply() is executed, information regarding execution is written over each worker node. You can use this log to write custom messages to help you diagnose and fine-tune your code. For instance, suppose that you don’t know what the first column name of df is, we can write a custom log message executed from the worker nodes using worker_log() as follows: sdf_len(sc, 1) %&gt;% spark_apply(function(df) { worker_log(&quot;the first column in the data frame is named &quot;, names(df)[[1]]) df }) # Source: spark&lt;?&gt; [?? x 1] id * &lt;int&gt; 1 1 When running locally, we can filter the log entries for the worker as follows: spark_log(sc, filter = &quot;sparklyr: RScript&quot;) 18/12/18 11:33:47 INFO sparklyr: RScript (3513) the first column in the dataframe is named id 18/12/18 11:33:47 INFO sparklyr: RScript (3513) computed closure 18/12/18 11:33:47 INFO sparklyr: RScript (3513) updating 1 rows 18/12/18 11:33:47 INFO sparklyr: RScript (3513) updated 1 rows 18/12/18 11:33:47 INFO sparklyr: RScript (3513) finished apply 18/12/18 11:33:47 INFO sparklyr: RScript (3513) finished Notice that the logs print our custom log entry showing that id is the name of the first column in the given data frame. This functionality is useful when troubleshooting errors; for instance, if we force an error using the stop() function: sdf_len(sc, 1) %&gt;% spark_apply(function(df) { stop(&quot;force an error&quot;) }) You will get an error similar to, Error in force(code) : sparklyr worker rscript failure, check worker logs for details As suggested in the error, we can look in the worker logs for the specific errors as follows: spark_log(sc) This will show an entry containing the error and the call stack: 18/12/18 11:26:47 INFO sparklyr: RScript (1860) computing closure 18/12/18 11:26:47 ERROR sparklyr: RScript (1860) terminated unexpectedly: force an error 18/12/18 11:26:47 ERROR sparklyr: RScript (1860) collected callstack: 11: stop(&quot;force and error&quot;) 10: (function (df) { stop(&quot;force and error&quot;) })(structure(list(id = 1L), class = &quot;data.frame&quot;, row.names = c(NA, -1L))) Notice that, spark_log(sc) only retrieves the worker logs when using local clusters, when running in proper clusters with multiple machines, you will have to use the tools and user interface provided by the cluster manager to find these log entries. 11.10.2 Resolving Timeouts When running with several hundred executors, it becomes more likely that some tasks will hang indefinitely. You might be in this situation if most of the tasks in your job complete successfully, but a handful of them are still running and do not fail or succeed. Suppose that we need to calculate the size of many web pages, we could use spark_apply() with something similar to: sdf_len(sc, 3, repartition = 3) %&gt;% spark_apply(~ download.file(&quot;https://google.com&quot;, &quot;index.html&quot;) + file.size(&quot;index.html&quot;)) Some web pages might not exist or take too long to download. In which case, most tasks will succeed, but a few will hang. To prevent a few tasks from blocking all computations, you can use the spark.speculation Spark setting. When this setting is enabled, once 75% of all tasks succeed, Spark will look for tasks taking longer than the median task execution time and retry this tasks. You can use the spark.speculation.multiplier setting to configure the time multiplier used to consider a task slow. Therefore, for the previous example, you can consider configuring Spark to retry tasks that take two times longer than the median as follows: config &lt;- spark_config() config[&quot;spark.speculation&quot;] &lt;- TRUE config[&quot;spark.speculation.multiplier&quot;] &lt;- 4 11.10.3 Inspecting Partition If a particular partition fails, you can detect the broken partition by computing a digest, and then retrieving that particular partition. As usual, install digest from CRAN before connecting to Spark. sdf_len(sc, 3) %&gt;% spark_apply(function(x) { worker_log(&quot;processing &quot;, digest::digest(x), &quot; partition&quot;) # your code x }) This will add an entry similar to: 18/11/03 14:48:32 INFO sparklyr: RScript (2566) processing f35b1c321df0162e3f914adfb70b5416 partition When executing this in your cluster, you will have to look in the logs for the task that is not finishing, once you have that digest, you can cancel the job. Then you can use that digest to retrieve that specific data frame to R with something like: sdf_len(sc, 3) %&gt;% spark_apply(function(x) { if (identical(digest::digest(x), &quot;f35b1c321df0162e3f914adfb70b5416&quot;)) x else x[0,] }) %&gt;% collect() # A tibble: 1 x 1 result &lt;int&gt; 1 1 Which you can then run in R to troubleshoot further. 11.10.4 Debugging Workers You can use a debugger, which is a tool to let you execute your code line-by-line, to troubleshoot spark_apply() for local connections. You can start spark_apply() in debug mode using the debug parameter and then following the instructions. sdf_len(sc, 1) %&gt;% spark_apply(function() { stop(&quot;Error!&quot;) }, debug = TRUE) Debugging spark_apply(), connect to worker debugging session as follows: 1. Find the workers &lt;sessionid&gt; and &lt;port&gt; in the worker logs, from RStudio click &#39;Log&#39; under the connection, look for the last entry with contents: &#39;Session (&lt;sessionid&gt;) is waiting for sparklyr client to connect to port &lt;port&gt;&#39; 2. From a new R session run: debugonce(sparklyr:::spark_worker_main) sparklyr:::spark_worker_main(&lt;sessionid&gt;, &lt;port&gt;) As the instructions indicate, you will need to connect “as the worker node” from a different R session and then step through the code. This method is not as straightforward as previous ones, since you will also need to step through some lines of sparklyr code; so this is something we only recommend as a last resort. You can also use the online resources that were described in the Getting Started chapter. Lets now wrap up this chapter with a brief recap of all the functionality that was presented. 11.11 Recap This chapter presented spark_apply() as an advanced technique that you can use to fill gaps in functionality in Spark or its many extensions. We presented sensible use cases for spark_apply() to parse data, model in parallel many small datasets, perform grid search and call web APIs. You learned how partitions relate to spark_apply(), how to create custom groups, distribute contextual information across all nodes, troubleshoot problems and presented limitations, cluster configuration caveats. We also introduced Apache Arrow as a library we strongly recommend when using Spark with R and presented installation, use cases and considerations you should be aware. Up to this chapter, we’ve only worked with large datasets of static data. As in, we’ve assumed our datasets do not change over time and remain invariant while analysing, modeling and visualizing them. In the next chapter, Streaming, we will introduce techniques to process datasets which, in addition to being large, are also growing an resemble a stream of information. "],
["streaming.html", "Chapter 12 Streaming 12.1 Overview 12.2 Transformations 12.3 Kafka 12.4 Shiny 12.5 Recap", " Chapter 12 Streaming “Our stories aren’t over yet.” — Arya Stark We can look back at the previous eleven chapters and think, what else are we missing? We’ve done everything from analysing tabular datasets, performed unsupervised learning over raw text, analyzed graphs and geographic datasets and even transformed data with custom R code! So now what? We were not explicit about this, but we’ve always assumed your data is static, we assumed it doesn’t change over time. But suppose for a moment your job is to analyze traffic patterns to give recommendations to the department of transportation. A very reasonable approach would be to analyze historical data and then design predictive models that compute forecasts overnight. Overnight? That’s very useful but traffic patterns change to the hour and even by the minute. You could try to preprocess and predict faster and faster, but eventually this model breaks – you can’t load large-scale datasets, transform them, score them, unload them and repeat this process by the second. Instead, we need to introduce a different kind of dataset, one that is not static but rather dynamic; one that is like a table but is growing constantly, we will refer to such datasets as streams. 12.1 Overview We know how to work with large-scale static datasets, all the previous chapters dealt with them; but how should we reason about large-scale real-time datasets? We will define as streams – datasets with an infinite amount entries. For instance, if we wanted to do real-time scoring using a pre-trained topic model, the entries would be lines of text for static datasets; for real-time datasets, we would perform the same scoring over an infinite amount of lines of text. Now, in practice, you will never process an infinite amount of records, you will eventually stop the stream – or this universe might end, whatever comes first – regardless, thinking of them as infinite datasets makes it so much easier to reason about them. Streams are most relevant when processing real time data; for example, when analyzing a Twitter feed or stock prices. Both examples have well defined columns, like ‘tweet’ or ‘price’, but there are always new rows of data to be analyzed. Spark Structured Streams provide scalable and fault-tolerant data processing over streams of data. That means, one can use many machines to process multiple streaming sources, perform joins with other streams or static sources, and recover from failures with at-least-once guarantees (each message is certain to be delivered, but may do so multiple times). In Spark, you create streams by defining a source, a transformation and a sink; you can think of these steps as reading, transforming and writing a stream, which Figure 12.1 describes. Reading Streams read data using any of the stream_read_*() functions, the read operation defines the source of the stream; you can define one or multiple sources from which to read from. Transforming A stream can perform one or multiple transformation using dplyr, SQL, feature transformers, scoring pipelines or distributed R code. Transformations can join against streaming sources or static datasets. Writing The write operations are performed with the family of stream_write_*() functions, the read operation defined the sink of the stream. You can specify a single sink to write data to or multiple ones. FIGURE 12.1: Working with Spark Streams You can read and write to streams in several different file formats: CSV, JSON, Parquet, ORC and text; and form Kafka which we will introduce later on. Format Read Write CSV stream_read_csv stream_write_csv JSON stream_read_json stream_write_json Kafka stream_read_kafka stream_write_kafka ORC stream_read_orc stream_write_orc Parquet stream_read_parquet stream_write_parquet Text stream_read_text stream_write_text Memory stream_write_memory Since the transformation step is optional, the simplest stream we can define is one that continuously copies text files between source and destination. First, install the future package with install.packages(\"future\") and connect to Spark: Since a stream requires the source to exist, create a source folder: dir.create(&quot;source&quot;) We are now ready to define our first stream! stream &lt;- stream_read_text(sc, &quot;source/&quot;) %&gt;% stream_write_text(&quot;destination/&quot;) The streams starts running with stream_write_*(); once executed, the stream will monitor the source path and process data into the destination/ path as it arrives. We can use stream_generate_test() to produce a file every second containing lines of text that follow a given distribution, you can read more about this in the Appendix. In practice, you would connect to existing sources without having to generate data artificially. We can then use view_stream() to track the rows per second (rps) being processed in the source, destination and their latest values over time. The result is shown in Figure . future::future(stream_generate_test(interval = 0.5)) stream_view(stream) FIGURE 12.2: Monitoring a stream generating rows following a binomial distribution Notice that the rows-per-second in the destination stream are higher than the rows-per-second in the source stream; this is expected and desirable since Spark measures incoming rates from the source, but actual row processing times in the destination stream. For example, if 10 rows-per-second are written to the source/ path, the incoming rate is 10 RPS. However, if it takes Spark only 0.01 seconds to write all those 10 rows, the output rate is 100 RPS. Use stream_stop() to properly stop processing data from this stream. stream_stop(stream) This exercise introduced how we can easily start a Spark stream that reads and writes data based on a simulated stream, let’s do something more interesting than just copying data with proper transformations. 12.2 Transformations In a real life scenario, the incoming data from a stream would not be written as-is to the output. The Spark Stream job would make transformations to the data, and then write the transformed data. Streams can be transformed using dplyr, SQL queries, ML Pipelines or R code. We can use as many transformations as needed in the same way that Spark data frames can be transformed with sparklyr. The source of the transformation can be a stream or data frame, but the output is always a stream. If needed, one can always take a snapshot from the destination stream, and then save the output as a data frame. That is what sparklyr will do for you if a destination stream is not specified. Each sub-section will cover an option provided by sparklyr to perform transformations on a stream. 12.2.1 Analysis You can analyze streams with dplyr verbs and SQL using DBI, as a quick example, we will filter rows and add columns over a stream. We won’t explicitly call stream_generate_test(), but you can call it on your own through the later package if you feel the urge to verify that data is being processed continuously. library(dplyr) stream_read_csv(sc, &quot;source&quot;) %&gt;% filter(x &gt; 700) %&gt;% mutate(y = round(x / 100)) # Source: spark&lt;?&gt; [inf x 2] x y &lt;int&gt; &lt;dbl&gt; 1 701 7 2 702 7 3 703 7 4 704 7 5 705 7 6 706 7 7 707 7 8 708 7 9 709 7 10 710 7 # … with more rows It is also possible to perform aggregations over the entire history of the stream. The history could be filtered or not. stream_read_csv(sc, &quot;source&quot;) %&gt;% filter(x &gt; 700) %&gt;% mutate(y = round(x / 100)) %&gt;% count(y) # Source: spark&lt;?&gt; [inf x 2] y n &lt;dbl&gt; &lt;dbl&gt; 1 8 25902 2 9 25902 3 10 13210 4 7 12692 Grouped aggregations of the latest data in the stream require a timestamp. The timestamp will be of when reading function, in this case stream_read_csv() , first “saw” that specific record. In Spark stream terms, that timestamp is called a “watermark”. The spark_watermark() function is used to add the timestamp. For this exercise, the watermark will be the same for all records, since the five files were read by the stream after they were created. Please note that only Kafka and memory outputs support watermarks. stream_read_csv(sc, &quot;source&quot;) %&gt;% stream_watermark() # Source: spark&lt;?&gt; [inf x 2] x timestamp &lt;int&gt; &lt;dttm&gt; 1 276 2019-06-30 07:14:21 2 277 2019-06-30 07:14:21 3 278 2019-06-30 07:14:21 4 279 2019-06-30 07:14:21 5 280 2019-06-30 07:14:21 6 281 2019-06-30 07:14:21 7 282 2019-06-30 07:14:21 8 283 2019-06-30 07:14:21 9 284 2019-06-30 07:14:21 10 285 2019-06-30 07:14:21 # … with more rows After the watermark is created, it can be used in the group_by() verb. It can then be piped into a summarise() function to get some stats of the stream. stream_read_csv(sc, &quot;source&quot;) %&gt;% stream_watermark() %&gt;% group_by(timestamp) %&gt;% summarise( max_x = max(x, na.rm = TRUE), min_x = min(x, na.rm = TRUE), count = n() ) # Source: spark&lt;?&gt; [inf x 4] timestamp max_x min_x count &lt;dttm&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 2019-06-30 07:14:55 1000 1 259332 12.2.2 Modeling Spark streams currently do not support training on reael-time datasets, aside from the technical challenges; even if it were possible, it would be quite challenging to train models since the model itself would have to adapt over time, this is known as online learning and perhaps something that Spark will support in the future. That said, there are other modeling concepts we can use with streams, like feature transformers and scoring, lets try out a feature transformer with streams and leave scoring for the next section since we will need to train a model. The next example makes use of the ft_bucketizer() feature transformer to modify the stream followed by regular dplyr functions which you can use just as you would with static datasets. stream_read_csv(sc, &quot;source&quot;) %&gt;% mutate(x = as.numeric(x)) %&gt;% ft_bucketizer(&quot;x&quot;, &quot;buckets&quot;, splits = 0:10 * 100) %&gt;% count(buckets) %&gt;% arrange(buckets) # Source: spark&lt;?&gt; [inf x 2] # Ordered by: buckets buckets n &lt;dbl&gt; &lt;dbl&gt; 1 0 25747 2 1 26008 3 2 25992 4 3 25908 5 4 25905 6 5 25903 7 6 25904 8 7 25901 9 8 25902 10 9 26162 12.2.3 Pipelines Spark pipelines can be used for scoring streams, but not to train over streaming data. The former is fully supported while the latter is a feature under active development by the Spark community. In order to score a stream, it is necessary to first create a our model. So lets build, fit and save a simple pipeline. cars &lt;- copy_to(sc, mtcars) model &lt;- ml_pipeline(sc) %&gt;% ft_binarizer(&quot;mpg&quot;, &quot;over_30&quot;, 30) %&gt;% ft_r_formula(over_30 ~ wt) %&gt;% ml_logistic_regression() %&gt;% ml_fit(cars) Tip: If you choose to, you can make use of other concepts presented in the Pipelines chapter, like saving and reloading pipelines through ml_save() and ml_load() before scoring streams. We can then generate a stream based on mtcars using stream_generate_test() and score the model using ml_transform(): future::future(stream_generate_test(mtcars, &quot;cars-stream&quot;, iterations = 5)) ml_transform(model, stream_read_csv(sc, &quot;cars-stream&quot;)) # Source: spark&lt;?&gt; [inf x 17] mpg cyl disp hp drat wt qsec vs am gear carb over_30 &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 15.5 8 318 150 2.76 3.52 16.9 0 0 3 2 0 2 15.2 8 304 150 3.15 3.44 17.3 0 0 3 2 0 3 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 0 4 19.2 8 400 175 3.08 3.84 17.0 0 0 3 2 0 5 27.3 4 79 66 4.08 1.94 18.9 1 1 4 1 0 6 26 4 120. 91 4.43 2.14 16.7 0 1 5 2 0 7 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 1 8 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4 0 9 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 0 10 15 8 301 335 3.54 3.57 14.6 0 1 5 8 0 # … with more rows, and 5 more variables: features &lt;list&gt;, label &lt;dbl&gt;, # rawPrediction &lt;list&gt;, probability &lt;list&gt;, prediction &lt;dbl&gt; Even though the example this example was put together with a few lines of code, it is actually quite impressive what we just accomplished: You copied data into Spark, performed feature engineering, traineed a model and scored the model over a real-time dataset, with seven lines of code! – Let’s try now to use custom transformations, in real-time. 12.2.4 Distributed R {streaming-r-code} Arbitrary R code can also be used to transform a stream with the use of spark_apply(). This approach follows the same principles discussed in the Distributed R chapter, as in, spark_apply() runs R code over each executor in the cluster where data is available, this enables processing high-throughput streams and fulfill low-latency requirements. stream_read_csv(sc, &quot;cars-stream&quot;) %&gt;% select(mpg) %&gt;% spark_apply(~ round(.x), mpg = &quot;integer&quot;) %&gt;% stream_write_csv(&quot;cars-round&quot;) Which as you would expect, processes data from cars-stream into cars-round by running the custom round() R function, let’s pick into the output sink: spark_read_csv(sc, &quot;cars-round&quot;) # Source: spark&lt;carsround&gt; [?? x 1] mpg &lt;dbl&gt; 1 16 2 15 3 13 4 19 5 27 6 26 7 30 8 16 9 20 10 15 # … with more rows Again, make sure you apply the concepts you already know about spark_apply() when using streams; for instance, you should consider using arrow to significantly improve performance. This was our last transformation for streams, you will now learn how to use Spark streams with Shiny, a package that makes it easy to build interactive web applications from R. spark_disconnect(sc) 12.3 Kafka Apache Kafka is an open-source stream-processing software platform developed by LinkedIn and donated to the Apache Software Foundation, written in Scala and Java. As an analogy. Kafka is to real-time storage as what Hadoop is to static storage. Kafka stores the stream as records which consist of a key, a value and a timestamp. Kafka can handle multiple streams that contain different information by categorizing them into topic. Kafka is commonly used to connect multiple real-time applications, a producer is an application that streams data into Kafka, while a consumer is the one that reads from Kafka; in Kafka terminology, a consumer application subscribes to topics. Therefore, the most basic workflow we can accomplish with Kafka is one with a single producer and a single consumer, illustrated in Figure 12.3. FIGURE 12.3: Basic workflow If you are new to Kafka, we don’t recommend you try to run the code from this section; but if you are really motivated to follow along , first you will need to install Kafka as explained in the Appendix or deploy Kafka in your cluster. Using Kafka also requires the Kafka package when connecting to Spark, make sure is specified in your connection config: library(sparklyr) library(dplyr) sc &lt;- spark_connect(master = &quot;local&quot;, config = list( sparklyr.shell.packages = &quot;org.apache.spark:spark-sql-kafka-0-10_2.11:2.4.0&quot; )) Once connected, it’s straightforward to read data from a stream: stream_read_kafka( sc, options = list( kafka.bootstrap.server = &quot;host1:9092, host2:9092&quot;, subscribe = &quot;&lt;topic-name&gt;&quot; ) ) However, notice that you need to properly configure the options list; kafka.bootstrap.server expects a list of Kafka hosts, topic and subscribe define which topic should be used when writing or reading from Kafka respectively. While we started by presenting first a simple single-producer and single-consumer use case; Kafka also allows much more complex interactions. Next we will read from one topic, process its data and then write the results to a different topic – systems that are producers and consumers from the same topic are referred as, stream processors. In Figure 12.4, the stream processor reads topic A, and then writes results to topic B. This allows for a given consumer application to read results instead of “raw” feed data. FIGURE 12.4: Kafka workflow There are three modes available when processing Kafka streams in Spark: complete, update and append. The complete mode will provide the totals for every group every time there is a new batch, update provides totals for only the groups that have updates in the latest batch, append adds raw records to the target topic. This append mode is not meant for aggregates, but works well for passing a filtered subset to the target topic. In our next example, the producer will stream random letters into Kafka under a letters topic. Then Spark will act as the stream processor reading the letters topic and computing unique letter which are then written back to Kafka under the totals topic. We will use the update mode when writing back into Kafka, only the totals that changed will be sent to Kafka. This change is determined after each batch from the letters topic. hosts &lt;- &quot;localhost:9092&quot; read_options &lt;- list(kafka.bootstrap.servers = hosts, subscribe = &quot;letters&quot;) write_options &lt;- list(kafka.bootstrap.servers = hosts, topic = &quot;totals&quot;) stream_read_kafka(sc, options = read_options) %&gt;% mutate(value = as.character(value)) %&gt;% # coerce into a character count(value) %&gt;% # group and count letters mutate(value = paste0(value, &quot;=&quot;, n)) %&gt;% # kafka expects a value field stream_write_kafka(mode = &quot;update&quot;, options = write_options) You can take a quick look at totals by reading from Kafka, stream_read_kafka(sc, options = totals_options) Using a new terminal session, use Kafka’s command line tool to manually write single letter into the letters topic. kafka-console-producer.sh --broker-list localhost:9092 --topic letters &gt;A &gt;B &gt;C The letters that you input are pushed to Kaka, read by Spark, aggregated within Spark and pushed back into Kafka and then, finally, consumed by Spark again to give you a glimpse into totals topic. This was quite a setup, but also a realistic configuration which is common to find in real-time processing projects. Next, we will use the Shiny framework to visualize streams, in real-time! 12.4 Shiny Shiny’s reactive framework is well suited to support streaming information which you can use to display real-time data from Spark using the reactiveSpark(), reactive. There is much to learn about Shiny which we can possibly present; however, if you are already familiar with Shiny, this example should be quite easy to understand. We have a modified version of the k-means Shiny example which, instead of getting the data from the static iris dataset, gets generated with stream_generate_test(), consumed by Spark, retrieved to Shiny through reactiveSpark() and displayed as captured in Figure 12.5. To run this example, store the following Shiny app under shiny/shiny-stream.R. library(sparklyr) library(shiny) unlink(&quot;shiny-stream&quot;, recursive = TRUE) dir.create(&quot;shiny-stream&quot;, showWarnings = FALSE) sc &lt;- spark_connect( master = &quot;local&quot;, version = &quot;2.3&quot;, config = list(sparklyr.sanitize.column.names = FALSE)) ui &lt;- pageWithSidebar( headerPanel(&#39;Iris k-means clustering from Spark stream&#39;), sidebarPanel( selectInput(&#39;xcol&#39;, &#39;X Variable&#39;, names(iris)), selectInput(&#39;ycol&#39;, &#39;Y Variable&#39;, names(iris), selected=names(iris)[[2]]), numericInput(&#39;clusters&#39;, &#39;Cluster count&#39;, 3, min = 1, max = 9) ), mainPanel(plotOutput(&#39;plot1&#39;)) ) server &lt;- function(input, output, session) { iris &lt;- stream_read_csv(sc, &quot;shiny-stream&quot;, columns = sapply(datasets::iris, class)) %&gt;% reactiveSpark() selectedData &lt;- reactive(iris()[, c(input$xcol, input$ycol)]) clusters &lt;- reactive(kmeans(selectedData(), input$clusters)) output$plot1 &lt;- renderPlot({ par(mar = c(5.1, 4.1, 0, 1)) plot(selectedData(), col = clusters()$cluster, pch = 20, cex = 3) points(clusters()$centers, pch = 4, cex = 4, lwd = 4) }) } shinyApp(ui, server) This Shiny application can then be launched with runApp(), shiny::runApp(&quot;shiny/shiny-stream.R&quot;) While the shiny app runs, launch a new R session from the same directory and create a test stream with stream_generate_test(); this will generate a stream of continuous data that Spark can process and Shiny visualize. sparklyr::stream_generate_test(datasets::iris, &quot;shiny/shiny-stream&quot;, rep(5, 10^3)) FIGURE 12.5: Progression of Spark reactive loading data into Shiny app This section showed how easy it is to create a Shiny app that can be used for several purposes, such as monitoring, and dashboarding. In a more complex implementation, the source would more likely be a Kafka stream. The next section will cover how to integrate Kafka, Spark Stream and sparklyr. Before we transition, disconnect from Spark and clear the folders that we used: spark_disconnect(sc) unlink(c(&quot;source&quot;, &quot;destination&quot;, &quot;cars-stream&quot;, &quot;car-round&quot;, &quot;shiny/shiny-stream&quot;), recursive = TRUE) 12.5 Recap From static datasets to real-time datasets, you’ve truly mastered many of the large-scale computing techniques. Specifically, in this chapter, we learned how static data can be generalized to real-time if we think of it as an infinite table. We were then able to create a simple stream without any data transformations, meaning, a simple stream that copies data from point a to point b. A humble start that became quite useful when we learned about the several different transformations you can apply to stream; from data analysis transformations using the dplyr and DBI packages, to feature transformers introduced while modeling, to fully-fledged pipelines capable of scoring in real-time and, last but not least, transforming datasets with custom R code; a lot to digest for sure. We then presented Apache Kafka as a reliable and scalable solution for real-time data, you had a chance to see how a real-time system would be structured by introducing you to consumers, producers and topics; which when properly combined, create powerful abstractions to process real-time data. Then we closed this chapter with “a cherry on top of the cake” by presenting how to use Spark streams in Shiny, which to our surprise, was quite easy to accomplish since a stream can be transformed into a reactive, which is the lingua franca in the world of reactivity. It is time now to move to our very last and quite short chapter, Contributing; where we will try to recruit you – brainwash you – into using your newly acquired knowledge for the benefit of Spark and R community at large. "],
["contributing.html", "Chapter 13 Contributing 13.1 Overview 13.2 Spark API 13.3 Spark Extensions 13.4 Scala Code 13.5 Recap", " Chapter 13 Contributing “Hold the door, hold the door.” — Hodor The previous chapter, Streaming, equipped you with tools to tackle large-scale and real-time data processing in Spark using R. In a way, the previous chapter was the last learning chapter, while this last chapter is less focused on learning and more on giving back to the Spark and R communities or colleagues in your professional career – It really takes an entire community to keep this going, so we are counting on you! There are many ways to contribute, from helping community members, opening GitHub issues, to providing new functionality for yourself, colleagues or the R and Spark community; however, this chapter will focus on writing and sharing code that extends Spark to help others use new functionality that you can provide as an author of Spark extensions using R. Specifically, in this chapter you will learn what an extension is, when to build one, what tools are available, the different types of extensions you can consider building and how to build one from scratch. You will also learn how to make use of hundreds of extensions available in Spark and millions of components available in Java that you can use in R with ease. You will also learn how to create code natevely in Scala that makes use of Spark; as you might know, R is a great language to interface with other languages, like C++, SQL, Python and many other languages. It then to no surprise that working with Scala from R will follow similar practices that make R ideal to provide easy-to-use interfaces that make data-processing productive and that are loved by many of us. 13.1 Overview When thinking of contributing back, the most important question you can ask about the code above – but really, about any piece of code you write is: Would this code be useful to someone else? We can start by considering one of the first and simplest lines of code presented in this book, this code was used to load a simple CSV file: spark_read_csv(sc, &quot;cars.csv&quot;) For the code above, the answer is probably no, the code is not useful to someone else; however, a more useful example would be to tailor that same example to something someone will actually care about, perhaps: spark_read_csv(sc, &quot;/path/that/is/hard/to/remember/data.csv&quot;) The code above is quite similar to the original one; however, assuming that you work with others that care about this dataset, the answer to: Would this code be useful to someone else? Is now completely different: Yes, most likely! This is surprising since this means that not all useful code needs to be advanced nor complicated; however, for it to be useful to others, it does need to be packaged, presented and shared in a format that is easy to consume. One first attempt would be to save this into a teamdata.R file and write a function wrapping it: load_team_data &lt;- function() { spark_read_text(sc, &quot;/path/that/is/hard/to/remember/data.csv&quot;) } This is an improvement; however, it would require users to manually share this file over and over. Fortunately, this is a problem well solved in R through R Packages. An R package contains R code packaged in a format installable using the install.packages() function. sparklyr is an R package, but there are many other packages available in R and you can also create your own packages. For those of you new to creating R packages, we would encourage reading Hadley Wickam’s book on packages: R Packages: Organize, Test, Document, and Share Your Code. Creating an R package allows you to easily share your functions with others by sharing the package file in your organization. Once a package is created, there are many ways to share this with colleagues or the world. For instance, for packages meant to be private, you can consider using Drat or products like RStudio Package Manager. R packages meant for public consumption are made available to the R community in CRAN, which stands for the Comprehensive R Archive Network. These repositories of R packages make packages allow users to install packages through install.packages(\"teamdata\") without having to worry where to download the package from and allows other packages to reuse your package as well. In addition to using R packages like sparklyr, dplyr, broom, etc. to create new R packages that extend Spark; you can also make use of all the functionality available in the Spark API, Spark Extensions or write custom Scala code. For instance, suppose that there is a new file format similar to a CSV but not quite the same, we might want to write a function named spark_read_file() that would take a path to this new file type and read it in Spark. One approach would be to use dplyr to process each line of text or any other R library using spark_apply(). Another approach would be to use the Spark API to access methods provided by Spark. A third approach would be to find if someone in the Spark community has already provided an Spark Extension that supports this new file format. Last but not least, you can write our own custom Scala Code that makes use any Java library, including Spark and its extensions. This is illustrated in Figure 13.1. FIGURE 13.1: Extending Spark using the Spark API, Spark extensions or Scala code We will focus first on extending Spark using the Spark API since the techniques required to call the Spark API are also applicable while calling Spark extensions or custom Scala code. 13.2 Spark API Before we introduce the Spark API, let’s consider a simple and well known problem. Suppose we want to count the number of lines in a distributed and potentially large text file, say, cars.csv that we initialize as follows: library(sparklyr) library(dplyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.3&quot;) cars &lt;- copy_to(sc, mtcars) spark_write_csv(cars, &quot;cars.csv&quot;, mode = &quot;overwrite&quot;) Now, in order to count how many lines are available in this file we can run: spark_read_text(sc, &quot;cars.csv&quot;) %&gt;% count() # Source: spark&lt;?&gt; [?? x 1] n &lt;dbl&gt; 1 33 Easy enough, we used spark_read_text() to read the entire text file, followed by counting lines using dplyr’s count(). Now, suppose that spark_read_text(), dplyr nor any other Spark functionality is available to you; how would you ask Spark to count the number of rows in cars.csv? If you were to do this in Scala, you will be able to find in the Spark documentation that using the Spark API you can count lines in a file as follows: val textFile = spark.read.textFile(&quot;cars.csv&quot;) textFile.count() So, in order to use functionality available in the Spark API from R, like spark.read.textFile; you can use invoke(), invoke_static() or invoke_new(). As their names suggest, one invokes a method from an object, the second one invokes a method from a static object and the third creates a new object. We can then use these functions to call Spark’s API and execute similar code as the one provided in Scala: spark_context(sc) %&gt;% invoke(&quot;textFile&quot;, &quot;cars.csv&quot;, 1L) %&gt;% invoke(&quot;count&quot;) [1] 33 While the invoke() function was originally designed to call Spark code, it can call any code available in Java. For instance, we can create a Java BigInteger with the following code: invoke_new(sc, &quot;java.math.BigInteger&quot;, &quot;1000000000&quot;) &lt;jobj[225]&gt; java.math.BigInteger 1000000000 As you can see, the object that gets created is not an R object but rather – a proper Java object. In R, this Java object is represented by the spark_jobj. These objects are only meant to be used with the invoke() functions or spark_dataframe() and spark_connection(). spark_dataframe() transforms a spark_jobj into a Spark DataFrame, when possible; while spark_connect() retrieves the original Spark connection object, which can be useful to avoid passing the sc object across functions. While calling the Spark API can be useful in some cases, most of the functionality available in Spark is already supported in sparklyr; therefore, a more interesting way to extend Spark is by using one of its many existing extensions. 13.3 Spark Extensions Before we get started with this section, consider navigating to spark-packages.org – a site that tracks Spark extensions provided by the Spark community. Using the same techniques presented in the previous section, you can make use of these extensions from R. For instance, Apache Solr is a “blazing-fast, open source enterprise search platform built on Apache Lucene”. (“Apache Solr” 2019) Solr is a system designed to perform full text search over large datasets which Apache Spark currently does not support natevely. Also, as of this writing, there is no extension for R to support Solr. So let’s try to solve this using a Spark extension. First, you would want to search “spark-packages.org” to find out that there is a Solr extension, you should be able to find spark-solr. (“Spark-Solr Spark Package” 2019) The extension “How to” mentioned that the com.lucidworks.spark:spark-solr:2.0.1 should be loaded. We can accomplish this in R using the sparklyr.shell.packages configuration option: config &lt;- spark_config() config[&quot;sparklyr.shell.packages&quot;] &lt;- &quot;com.lucidworks.spark:spark-solr:3.6.3&quot; config[&quot;sparklyr.shell.repositories&quot;] &lt;- &quot;http://repo.spring.io/plugins-release/,http://central.maven.org/maven2/&quot; sc &lt;- spark_connect(master = &quot;local&quot;, config = config, version = &quot;2.3&quot;) While specifying the sparklyr.shell.packages parameter is usually enough, for this particular extension, dependencies failed to download from the Spark Packages repository. For the failed dependencies, you would have to manually find them in the Maven repo (mvnrepository.com) and add additional repositories under the sparklyr.shell.repositories parameter. Note: When using an extension, Spark connects to the Maven package repository to retrieve the extension, this can take significant time depending on the extension and your download speed. Therefore, you should consider increasing the sparklyr.connect.timeout configuration parameter to allow Spark to download the required files. From the spark-solr documentation, you would find that this extension can be used with the following Scala code: val options = Map( &quot;collection&quot; -&gt; &quot;{solr_collection_name}&quot;, &quot;zkhost&quot; -&gt; &quot;{zk_connect_string}&quot; ) val df = spark.read.format(&quot;solr&quot;) .options(options) .load() Which we can translate to R code: spark_session(sc) %&gt;% invoke(&quot;read&quot;) %&gt;% invoke(&quot;format&quot;, &quot;solr&quot;) %&gt;% invoke(&quot;option&quot;, &quot;collection&quot;, &quot;&lt;collection&gt;&quot;) %&gt;% invoke(&quot;option&quot;, &quot;zkhost&quot;, &quot;&lt;host&gt;&quot;) %&gt;% invoke(&quot;load&quot;) The code above will fail since it would require a valid Solr instance and configuring Solr goes beyond the scope of this book; however, this example provides insights as to how you can create Spark extensions. It’s also worth mentioning that spark_read_source() can be used to read from generic sources to avoid writing custom invoke() code. As pointed out in the Overview section, you should consider sharing code with others using R package. While you could require users of your package to specify sparklyr.shell.packages, you can avoid this by registering dependencies in your package. Dependencies are declared under a spark_dependencies() function, for the example in this section: spark_dependencies &lt;- function(spark_version, scala_version, ...) { spark_dependency( packages = &quot;com.lucidworks.spark:spark-solr:3.6.3&quot;, repositories = c( &quot;http://repo.spring.io/plugins-release/&quot;, &quot;http://central.maven.org/maven2/&quot;) ) } .onLoad &lt;- function(libname, pkgname) { sparklyr::register_extension(pkgname) } The onLoad function will be automatically called by R when you library loads, it should call register_extension() which will then call back spark_dependencies() to allow your extension to provide additional dependencies. The example above supports Spark 2.4 but you should also support a map of Spark and Scala versions to the correct Spark extension version. There are about 450 Spark extensions you can use; in addition, you can also use any Java library from a Maven repository where Maven Central has over 3M artifacts. (“Maven Repository: Repositories” 2019) While not all the Maven Central libraries might be relevant to Spark, the combination of Spark extensions and Maven repositories certainly opens many interesting possibilities for you to consider! However, for those cases where no Spark extension is available, the next section will teach you how to use custom Scala code from your own R package. 13.4 Scala Code Scala code enables you to use any method in the Spark API, Spark extensions or Java library; in addition, writing Scala code when running in Spark can provide performance improvements over R code using spark_apply(). In general, the structure of your R package will contains R code and Scala code; however, the Scala code will need to be compiled as JARs (Java ARchive files) and included in your package. Conceptually, your R package will look as shown in Figure 13.2. FIGURE 13.2: R package structure when using Scala code As usual, the R code should be placed under a top-level R folder, Scala code under a java folder while the compiled JARs are distributed under an inst/java folder. While you are certainly welcomed to manually compiled the Scala code, you can use helper functions to download the required compiler and compile Scala code. In order to compile Scala code, you will need the Java Development Kit 8 installed (JDK8 for short); the JDK can be downloaded from oracle.com/technetwork/java/javase/downloads/ and will require you to restart your R session. You also need a Scala compiler for Scala 2.11 and 2.12 from https://www.scala-lang.org/; the Scala compilers can be automatically downloaded and installed using download_scalac: download_scalac() Next you will need to compile your Scala sources using compile_package_jars(). By default, it uses spark_compilation_spec() which compiles your sources for the following Spark versions: [1] &quot;1.5.2&quot; &quot;1.6.0&quot; &quot;2.0.0&quot; &quot;2.3.0&quot; &quot;2.4.0&quot; You can also customize this specification by creating custom entries with spark_compilation_spec(). While you can create the project structure for Scala code by hand, you can also simply call spark_extension(path) to create an extension in the given path; this extension will be mostly empty but will contain the appropriate project structure to call Scala code. Since spark_extension() is registered as a custom project extension in RStudio; you can also create an R package that extends Spark using Scala code from the File menu, New Project... and selecting R Package using Spark as shown in Figure 13.3. FIGURE 13.3: Creating a Scala extension package from RStudio Once you are ready to compile your package JARs, you can simply run: compile_package_jars() Since the JARs are compiled by default into the inst/ package path, when building the R package all the JARs will also get included within the package, this means that you can share or publish your R package and it will be fully functional by R users. For advanced Spark users with most of their expertise in Scala, it should be quite compelling to consider writing libraries for R users and the R community in Scala and then easily packaging into R packages that are easy to consume, use and share among them. If you are interested in developing a Spark extension with R and you happen to get stuck along the way, consider joining the sparklyr Gitter (“Spark with R in Gitter” 2019) channel, where many of us hang out to help wonderful community to grow – we hope to hear from you soon! 13.5 Recap This last chapter introduced you to an entire new set of tools you can use to expand Spark functionality beyond what R and R packages currently support, this vast new space of libraries includes over 450 spark extensions and millions of Java artifacts you can use in Spark from R. Beyond these resources, you also learned how to build your own Java artifacts using Scala code that can be easily embedded and compiled from R. This brings us back to the purpose of this book presented early on, while we know that in this chapter and previous ones you’ve learned how to perform large-scale computing using Spark in R; we are also confident that you have acquired the knowledge required to help other community members through Spark extensions – we can’t wait to see your new creations, which will surely help grow the Spark and R communities at large. To close and recap on the entire book, we hope the first chapters gave you an easy intro to Spark and R, followed by presenting analysis and modeling as foundations for using Spark with the familiarity of R package you already know and love. You moved then to learning how to perform large-scale computing in proper Spark clusters. The last third of this book focused on advanced through extensions, distributing R code, processing real-time data and finally, contributing back Spark extensions using R and Scala code. We tried presenting the best possible content; however, if there is room to improve this book please open a GitHub issue under github.com/r-spark/the-r-in-spark which we can address in upcoming revisions. We hope you enjoyed reading this book, that you’ve learned as much as we’ve learned while writing it, and we hope it was worthy of your time – it has been an honor having you as our reader. References "],
["appendix.html", "Chapter 14 Appendix 14.1 Preface 14.2 Introduction 14.3 Getting Started 14.4 Analysis 14.5 Modeling 14.6 Clusters 14.7 Streaming", " Chapter 14 Appendix 14.1 Preface 14.1.1 Formatting The following ggplot2 theme was use to format plots in this book: plot_style &lt;- function() { font &lt;- &quot;Helvetica&quot; ggplot2::theme_classic() + ggplot2::theme( plot.title = ggplot2::element_text( family = font, size=14, color = &quot;#222222&quot;), plot.subtitle = ggplot2::element_text( family=font, size=12, color = &quot;#666666&quot;), legend.position = &quot;right&quot;, legend.background = ggplot2::element_blank(), legend.title = ggplot2::element_blank(), legend.key = ggplot2::element_blank(), legend.text = ggplot2::element_text( family=font, size=14, color=&quot;#222222&quot;), axis.title.y = ggplot2::element_text( margin = ggplot2::margin(t = 0, r = 8, b = 0, l = 0), size = 14, color=&quot;#666666&quot;), axis.title.x = ggplot2::element_text( margin = ggplot2::margin(t = -2, r = 0, b = 0, l = 0), size = 14, color = &quot;#666666&quot;), axis.text = ggplot2::element_text( family=font, size=14, color=&quot;#222222&quot;), axis.text.x = ggplot2::element_text( margin = ggplot2::margin(5, b = 10)), axis.ticks = ggplot2::element_blank(), axis.line = ggplot2::element_blank(), panel.grid.minor = ggplot2::element_blank(), panel.grid.major.y = ggplot2::element_line(color = &quot;#eeeeee&quot;), panel.grid.major.x = ggplot2::element_line(color = &quot;#ebebeb&quot;), panel.background = ggplot2::element_blank(), strip.background = ggplot2::element_rect(fill = &quot;white&quot;), strip.text = ggplot2::element_text(size = 20, hjust = 0) ) } Which you can then active with: ggplot2::theme_set(plot_style()) 14.2 Introduction 14.2.1 Worlds Store Capacity The following script was used to generate the worlds store capacity diagram: library(ggplot2) library(dplyr) library(tidyr) read.csv(&quot;data/01-worlds-capacity-to-store-information.csv&quot;, skip = 8) %&gt;% gather(key = storage, value = capacity, analog, digital) %&gt;% mutate(year = X, terabytes = capacity / 1e+12) %&gt;% ggplot(aes(x = year, y = terabytes, group = storage)) + geom_line(aes(linetype = storage)) + geom_point(aes(shape = storage)) + scale_y_log10( breaks = scales::trans_breaks(&quot;log10&quot;, function(x) 10^x), labels = scales::trans_format(&quot;log10&quot;, scales::math_format(10^x)) ) + theme_light() + theme(legend.position = &quot;bottom&quot;) 14.2.2 Daily downloads of CRAN packages The CRAN downloads chart was generated through: downloads_csv &lt;- &quot;data/01-intro-r-cran-downloads.csv&quot; if (!file.exists(downloads_csv)) { downloads &lt;- cranlogs::cran_downloads(from = &quot;2014-01-01&quot;, to = &quot;2019-01-01&quot;) readr::write_csv(downloads, downloads_csv) } cran_downloads &lt;- readr::read_csv(downloads_csv) ggplot(cran_downloads, aes(date, count)) + labs(title = &quot;CRAN Packages&quot;, subtitle = &quot;Total daily downloads over time&quot;) + geom_point(colour=&quot;black&quot;, pch = 21, size = 1) + scale_x_date() + xlab(&quot;year&quot;) + ylab(&quot;downloads&quot;) + scale_x_date(date_breaks = &quot;1 year&quot;, labels = function(x) substring(x, 1, 4)) + scale_y_continuous( limits = c(0, 3.5 * 10^6), breaks = c(0.5 * 10^6, 10^6, 1.5 * 10^6, 2 * 10^6, 2.5 * 10^6, 3 * 10^6, 3.5 * 10^6), labels = c(&quot;&quot;, &quot;1M&quot;, &quot;&quot;, &quot;2M&quot;, &quot;&quot;, &quot;3M&quot;, &quot;&quot;) ) 14.3 Getting Started 14.3.1 Prerequisites 14.3.1.1 Installing R From r-project.org, download and launch the R installer for your platform, Windows, Macs or Linux available. FIGURE 14.1: The R Project for Statistical Computing 14.3.1.2 Installing Java From java.com/download, download and launch the installer for your platform, Windows, Macs or Linux are also available. FIGURE 14.2: Java Download Page Starting with Spark 2.1, Java 8 is required; however, previous versions of Spark support Java 7. Regardless, we recommend installing Java Runtime Engine 8, or JRE 8 for short. Note: For advanced readers that are already using the Java Development Kit, JDK for short. Please notice that JDK 9+ is currently unsupported so you will need to downgrade to JDK 8 by uninstalling JDK 9+ or by setting JAVA_HOME appropiately. 14.3.1.3 Installing RStudio While installing RStudio is not strictly required to work with Spark with R, it will make you much more productive and therefore, I would recommend you take the time to install RStudio from rstudio.com/download, then download and launch the installer for your platform: Windows, Macs or Linux. FIGURE 14.3: RStudio Downloads Page After launching RStudio, you can use RStudio’s console panel to execute the code provided in this chapter. 14.3.1.4 Using RStudio If you are not familiar with RStudio, you should make note of the following panes: Console: A standalone R console you can use to execute all the code presented in this book. Packages: This pane allows you to install sparklyr with ease, check its version, navigate to the help contents, etc. Connections: This pane allows you to connecto to Spark, manage your active connection and view the available datasets. FIGURE 14.4: RStudio Overview 14.4 Analysis 14.4.1 Hive Functions Name Description size(Map&lt;K.V&gt;) Returns the number of elements in the map type. size(Array) Returns the number of elements in the array type. map_keys(Map&lt;K.V&gt;) Returns an unordered array containing the keys of the input map. map_values(Map&lt;K.V&gt;) Returns an unordered array containing the values of the input map. array_contains(Array, value) Returns TRUE if the array contains value. sort_array(Array) Sorts the input array in ascending order according to the natural ordering of the array elements and returns it binary(string or binary) Casts the parameter into a binary. cast(expr as ‘type’) Converts the results of the expression expr to the given type. from_unixtime(bigint unixtime[, string format]) Converts the number of seconds from unix epoch (1970-01-01 00:00:00 UTC) to a string. unix_timestamp() Gets current Unix timestamp in seconds. unix_timestamp(string date) Converts time string in format yyyy-MM-dd HH:mm:ss to Unix timestamp (in seconds). to_date(string timestamp) Returns the date part of a timestamp string. year(string date) Returns the year part of a date. quarter(date/timestamp/string) Returns the quarter of the year for a date. month(string date) Returns the month part of a date or a timestamp string. day(string date) dayofmonth(date) Returns the day part of a date or a timestamp string. hour(string date) Returns the hour of the timestamp. minute(string date) Returns the minute of the timestamp. second(string date) Returns the second of the timestamp. weekofyear(string date) Returns the week number of a timestamp string. extract(field FROM source) Retrieve fields such as days or hours from source. Source must be a date, timestamp, interval or a string that can be converted into either a date or timestamp. datediff(string enddate, string startdate) Returns the number of days from startdate to enddate. date_add(date/timestamp/string startdate, tinyint/smallint/int days) Adds a number of days to startdate. date_sub(date/timestamp/string startdate, tinyint/smallint/int days) Subtracts a number of days to startdate. from_utc_timestamp({any primitive type} ts, string timezone) Converts a timestamp in UTC to a given timezone. to_utc_timestamp({any primitive type} ts, string timezone) Converts a timestamp in a given timezone to UTC. current_date Returns the current date. current_timestamp Returns the current timestamp. add_months(string start_date, int num_months, output_date_format) Returns the date that is num_months after start_date. last_day(string date) Returns the last day of the month which the date belongs to. next_day(string start_date, string day_of_week) Returns the first date which is later than start_date and named as day_of_week. trunc(string date, string format) Returns date truncated to the unit specified by the format. months_between(date1, date2) Returns number of months between dates date1 and date2. date_format(date/timestamp/string ts, string fmt) Converts a date/timestamp/string to a value of string in the format specified by the date format fmt. if(boolean testCondition, T valueTrue, T valueFalseOrNull) Returns valueTrue when testCondition is true, returns valueFalseOrNull otherwise. isnull( a ) Returns true if a is NULL and false otherwise. isnotnull ( a ) Returns true if a is not NULL and false otherwise. nvl(T value, T default_value) Returns default value if value is null else returns value. COALESCE(T v1, T v2, …) Returns the first v that is not NULL, or NULL if all v’s are NULL. CASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END When a = b, returns c; when a = d, returns e; else returns f. nullif( a, b ) Returns NULL if a=b; otherwise returns a. assert_true(boolean condition) Throw an exception if ‘condition’ is not true, otherwise return null. ascii(string str) Returns the numeric value of the first character of str. base64(binary bin) Converts the argument from binary to a base 64 string. character_length(string str) Returns the number of UTF-8 characters contained in str. chr(bigint double A) concat(string binary A, string context_ngrams(array&lt;array&gt;, array, int K, int pf) Returns the top-k contextual N-grams from a set of tokenized sentences. concat_ws(string SEP, string A, string B…) Like concat() above, but with custom separator SEP. decode(binary bin, string charset) Decodes the first argument into a String using the provided character set (one of ‘US-ASCII’, ‘ISO-8859-1’, ‘UTF-8’, ‘UTF-16BE’, ‘UTF-16LE’, ‘UTF-16’). If either argument is null, the result will also be null. elt(N int,str1 string,str2 string,str3 string,…) Return string at index number, elt(2,‘hello’,‘world’) returns ‘world’. encode(string src, string charset) Encodes the first argument into a BINARY using the provided character set (one of ‘US-ASCII’, ‘ISO-8859-1’, ‘UTF-8’, ‘UTF-16BE’, ‘UTF-16LE’, ‘UTF-16’). field(val T,val1 T,val2 T,val3 T,…) Returns the index of val in the val1,val2,val3,… list or 0 if not found. find_in_set(string str, string strList) Returns the first occurance of str in strList where strList is a comma-delimited string. format_number(number x, int d) Formats the number X to a format like '#,###,###.##', rounded to D decimal places, and returns the result as a string. If D is 0, the result has no decimal point or fractional part. get_json_object(string json_string, string path) Extracts json object from a json string based on json path specified, and returns json string of the extracted json object. in_file(string str, string filename) Returns true if the string str appears as an entire line in filename. instr(string str, string substr) Returns the position of the first occurrence of substr in str. length(string A) Returns the length of the string. locate(string substr, string str[, int pos]) Returns the position of the first occurrence of substr in str after position pos. lower(string A) lcase(string A) Returns the string resulting from converting all characters of B to lower case. lpad(string str, int len, string pad) Returns str, left-padded with pad to a length of len. If str is longer than len, the return value is shortened to len characters. ltrim(string A) Returns the string resulting from trimming spaces from the beginning(left hand side) of A. ngrams(array&lt;array&gt;, int N, int K, int pf) Returns the top-k N-grams from a set of tokenized sentences, such as those returned by the sentences() UDAF. octet_length(string str) Returns the number of octets required to hold the string str in UTF-8 encoding. parse_url(string urlString, string partToExtract [, string keyToExtract]) Returns the specified part from the URL. Valid values for partToExtract include HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO. printf(String format, Obj… args) Returns the input formatted according do printf-style format strings. regexp_extract(string subject, string pattern, int index) Returns the string extracted using the pattern. regexp_replace(string INITIAL_STRING, string PATTERN, string REPLACEMENT) Returns the string resulting from replacing all substrings in INITIAL_STRING that match the java regular expression syntax defined in PATTERN with instances of REPLACEMENT. repeat(string str, int n) Repeats str n times. replace(string A, string OLD, string NEW) Returns the string A with all non-overlapping occurrences of OLD replaced with NEW. reverse(string A) Returns the reversed string. rpad(string str, int len, string pad) Returns str, right-padded with pad to a length of len. rtrim(string A) Returns the string resulting from trimming spaces from the end(right hand side) of A. sentences(string str, string lang, string locale) Tokenizes a string of natural language text into words and sentences, where each sentence is broken at the appropriate sentence boundary and returned as an array of words. space(int n) Returns a string of n spaces. split(string str, string pat) Splits str around pat (pat is a regular expression). str_to_map(text[, delimiter1, delimiter2]) Splits text into key-value pairs using two delimiters. Delimiter1 separates text into K-V pairs, and Delimiter2 splits each K-V pair. Default delimiters are ‘,’ for delimiter1 and ‘:’ for delimiter2. substr(string binary A, int start) substring_index(string A, string delim, int count) Returns the substring from string A before count occurrences of the delimiter delim. translate(string char trim(string A) Returns the string resulting from trimming spaces from both ends of A. unbase64(string str) Converts the argument from a base 64 string to BINARY. upper(string A) ucase(string A) Returns the string resulting from converting all characters of A to upper case. For example, upper(‘fOoBaR’) results in ‘FOOBAR’. initcap(string A) Returns string, with the first letter of each word in uppercase, all other letters in lowercase. Words are delimited by whitespace. levenshtein(string A, string B) Returns the Levenshtein distance between two strings. soundex(string A) Returns soundex code of the string. mask(string str[, string upper[, string lower[, string number]]]) Returns a masked version of str. mask_first_n(string str[, int n]) Returns a masked version of str with the first n values masked. mask_first_n(“1234-5678-8765-4321”, 4) results in nnnn-5678-8765-4321. mask_last_n(string str[, int n]) Returns a masked version of str with the last n values masked. mask_show_first_n(string str[, int n]) Returns a masked version of str, showing the first n characters unmasked. mask_show_last_n(string str[, int n]) Returns a masked version of str, showing the last n characters unmasked. mask_hash(string char java_method(class, method[, arg1[, arg2..]]) Synonym for reflect. reflect(class, method[, arg1[, arg2..]]) Calls a Java method by matching the argument signature, using reflection. hash(a1[, a2…]) Returns a hash value of the arguments. current_user() Returns current user name from the configured authenticator manager. logged_in_user() Returns current user name from the session state. current_database() Returns current database name. md5(string/binary) Calculates an MD5 128-bit checksum for the string or binary. sha1(string/binary)sha(string/binary) Calculates the SHA-1 digest for string or binary and returns the value as a hex string. crc32(string/binary) Computes a cyclic redundancy check value for string or binary argument and returns bigint value. sha2(string/binary, int) Calculates the SHA-2 family of hash functions (SHA-224, SHA-256, SHA-384, and SHA-512). aes_encrypt(input string/binary, key string/binary) Encrypt input using AES. aes_decrypt(input binary, key string/binary) Decrypt input using AES. version() Returns the Hive version. count(expr) Returns the total number of retrieved rows. sum(col), sum(DISTINCT col) Returns the sum of the elements in the group or the sum of the distinct values of the column in the group. avg(col), avg(DISTINCT col) Returns the average of the elements in the group or the average of the distinct values of the column in the group. min(col) Returns the minimum of the column in the group. max(col) Returns the maximum value of the column in the group. variance(col), var_pop(col) Returns the variance of a numeric column in the group. var_samp(col) Returns the unbiased sample variance of a numeric column in the group. stddev_pop(col) Returns the standard deviation of a numeric column in the group. stddev_samp(col) Returns the unbiased sample standard deviation of a numeric column in the group. covar_pop(col1, col2) Returns the population covariance of a pair of numeric columns in the group. covar_samp(col1, col2) Returns the sample covariance of a pair of a numeric columns in the group. corr(col1, col2) Returns the Pearson coefficient of correlation of a pair of a numeric columns in the group. percentile(BIGINT col, p) Returns the exact pth percentile of a column in the group (does not work with floating point types). p must be between 0 and 1. percentile(BIGINT col, array(p1 [, p2]…)) Returns the exact percentiles p1, p2, … of a column in the group. pi must be between 0 and 1. percentile_approx(DOUBLE col, p [, B]) Returns an approximate pth percentile of a numeric column (including floating point types) in the group. The B parameter controls approximation accuracy at the cost of memory. Higher values yield better approximations, and the default is 10,000. When the number of distinct values in col is smaller than B, this gives an exact percentile value. percentile_approx(DOUBLE col, array(p1 [, p2]…) [, B]) Same as above, but accepts and returns an array of percentile values instead of a single one. regr_avgx(independent, dependent) Equivalent to avg(dependent). regr_avgy(independent, dependent) Equivalent to avg(independent). regr_count(independent, dependent) Returns the number of non-null pairs used to fit the linear regression line. regr_intercept(independent, dependent) Returns the y-intercept of the linear regression line, i.e. the value of b in the equation dependent = a * independent + b. regr_r2(independent, dependent) Returns the coefficient of determination for the regression. regr_slope(independent, dependent) Returns the slope of the linear regression line, i.e. the value of a in the equation dependent = a * independent + b. regr_sxx(independent, dependent) Equivalent to regr_count(independent, dependent) * var_pop(dependent). regr_sxy(independent, dependent) Equivalent to regr_count(independent, dependent) * covar_pop(independent, dependent). regr_syy(independent, dependent) Equivalent to regr_count(independent, dependent) * var_pop(independent). histogram_numeric(col, b) Computes a histogram of a numeric column in the group using b non-uniformly spaced bins. The output is an array of size b of double-valued (x,y) coordinates that represent the bin centers and heights collect_set(col) Returns a set of objects with duplicate elements eliminated. collect_list(col) Returns a list of objects with duplicates. ntile(INTEGER x) Divides an ordered partition into x groups called buckets and assigns a bucket number to each row in the partition. This allows easy calculation of tertiles, quartiles, deciles, percentiles and other common summary statistics. explode(ARRAY a) Explodes an array to multiple rows. Returns a row-set with a single column (col), one row for each element from the array. explode(MAP&lt;Tkey,Tvalue&gt; m) Explodes a map to multiple rows. Returns a row-set with a two columns (key,value) , one row for each key-value pair from the input map. posexplode(ARRAY a) Explodes an array to multiple rows with additional positional column of int type (position of items in the original array, starting with 0). Returns a row-set with two columns (pos,val), one row for each element from the array. inline(ARRAY&lt;STRUCT&lt;f1:T1,…,fn:Tn&gt;&gt; a) Explodes an array of structs to multiple rows. Returns a row-set with N columns (N = number of top level elements in the struct), one row per struct from the array. stack(int r,T1 V1,…,Tn/r Vn) Breaks up n values V1,…,Vn into r rows. Each row will have n/r columns. r must be constant. json_tuple(string jsonStr,string k1,…,string kn) Takes JSON string and a set of n keys, and returns a tuple of n values. parse_url_tuple(string urlStr,string p1,…,string pn) Takes URL string and a set of n URL parts, and returns a tuple of n values. 14.5 Modeling 14.5.1 MLlib Functions The following table exhibits the ML algorithms supported in sparklyr: 14.5.1.1 Classification Algorithm Function Decision Trees ml_decision_tree_classifier() Gradient-Boosted Trees ml_gbt_classifier() Linear Support Vector Machines ml_linear_svc() Logistic Regression ml_logistic_regression() Multilayer Perceptron ml_multilayer_perceptron_classifier() Naive-Bayes ml_naive_bayes() One vs Rest ml_one_vs_rest() Random Forests ml_random_forest_classifier() 14.5.1.2 Regression Algorithm Function Accelerated Failure Time Survival Regression ml_aft_survival_regression() Decision Trees ml_decision_tree_regressor() Generalized Linear Regression ml_generalized_linear_regression() Gradient-Boosted Trees ml_gbt_regressor() Isotonic Regression ml_isotonic_regression() Linear Regression ml_linear_regression() 14.5.1.3 Clustering Algorithm Function Bisecting K-Means Clustering ml_bisecting_kmeans() Gaussian Mixture Clustering ml_gaussian_mixture() K-Means Clustering ml_kmeans() Latent Dirichlet Allocation ml_lda() 14.5.1.4 Recommendation Algorithm Function Alternating Least Squares Factorization ml_als() 14.5.1.5 Frequent Pattern Mining Algorithm Function FPGrowth ml_fpgrowth() 14.5.1.6 Feature Transformers Transformer Function Binarizer ft_binarizer() Bucketizer ft_bucketizer() Chi-Squared Feature Selector ft_chisq_selector() Vocabulary from Document Collections ft_count_vectorizer() Discrete Cosine Transform ft_discrete_cosine_transform() Transformation using dplyr ft_dplyr_transformer() Hadamard Product ft_elementwise_product() Feature Hasher ft_feature_hasher() Term Frequencies using Hashing export(ft_hashing_tf) Inverse Document Frequency ft_idf() Imputation for Missing Values export(ft_imputer) Index to String ft_index_to_string() Feature Interaction Transform ft_interaction() Rescale to [-1, 1] Range ft_max_abs_scaler() Rescale to [min, max] Range ft_min_max_scaler() Locality Sensitive Hashing ft_minhash_lsh() Converts to n-grams ft_ngram() Normalize using the given P-Norm ft_normalizer() One-Hot Encoding ft_one_hot_encoder() Feature Expansion in Polynomial Space ft_polynomial_expansion() Maps to Binned Categorical Features ft_quantile_discretizer() SQL Transformation ft_sql_transformer() Standardizes Features using Corrected STD ft_standard_scaler() Filters out Stop Words ft_stop_words_remover() Map to Label Indices ft_string_indexer() Splits by White Spaces ft_tokenizer() Combine Vectors to Row Vector ft_vector_assembler() Indexing Categorical Feature ft_vector_indexer() Subarray of the Original Feature ft_vector_slicer() Transform Word into Code ft_word2vec() 14.6 Clusters 14.6.1 Google trends for mainframes, cloud computing and kubernetes Data downloaded from https://bit.ly/2YnHkNI. library(dplyr) read.csv(&quot;data/clusters-trends.csv&quot;, skip = 2) %&gt;% mutate(year = as.Date(paste(Month, &quot;-01&quot;, sep = &quot;&quot;))) %&gt;% mutate(`On-Premise` = `mainframe...Worldwide.`, Cloud = `cloud.computing...Worldwide.`, Kubernetes = `kubernetes...Worldwide.`) %&gt;% tidyr::gather(`On-Premise`, Cloud, Kubernetes, key = &quot;trend&quot;, value = &quot;popularity&quot;) %&gt;% ggplot(aes(x=year, y=popularity, group=trend)) + geom_line(aes(linetype = trend, color = trend)) + scale_x_date(date_breaks = &quot;2 year&quot;, date_labels = &quot;%Y&quot;) + labs(title = &quot;Cluster Computing Trends&quot;, subtitle = paste(&quot;Search popularity for on-premise (mainframe)&quot;, &quot;cloud computing and kubernetes &quot;)) + scale_color_grey(start = 0.6, end = 0.2) + geom_hline(yintercept = 0, size = 1, colour = &quot;#333333&quot;) + theme(axis.title.x = element_blank()) 14.7 Streaming 14.7.1 Stream Generator The stream_generate_test() function creates a local test stream. This function works independently from a Spark connection. The following example will create five files in sub-folder called “source”. The files will be created one second apart from the previous file’s creation. library(sparklyr) stream_generate_test(iterations = 5, path = &quot;source&quot;, interval = 1) After the function completes, all of the files should show up in the “source” folder. Notice that the file size vary. This is so that it simulates what a true stream would do. file.info(file.path(&quot;source&quot;, list.files(&quot;source&quot;)))[1] ## size ## source/stream_1.csv 44 ## source/stream_2.csv 121 ## source/stream_3.csv 540 ## source/stream_4.csv 2370 ## source/stream_5.csv 7236 The stream_generate_test() by default will create a single numeric variable data frame. readr::read_csv(&quot;source/stream_5.csv&quot;) ## # A tibble: 1,489 x 1 ## x ## &lt;dbl&gt; ## 1 630 ## 2 631 ## 3 632 ## 4 633 ## 5 634 ## 6 635 ## 7 636 ## 8 637 ## 9 638 ## 10 639 ## # ... with 1,479 more rows 14.7.2 Installing Kafka This instructions were put together using information from the official Kafka site. Specifically from the Quickstart page, and at the time of writing this book. Newer versions of Kafka undoubtely will be available when reading this book. The idea is to “timestamp” the versions used in the example in the Streaming chapter. Download Kafka wget http://apache.claz.org/kafka/2.2.0/kafka_2.12-2.2.0.tgz Expand the tar file and enter the new folder tar -xzf kafka_2.12-2.2.0.tgz cd kafka_2.12-2.2.0 Start the Zookeeper service that comes with Kafka bin/zookeeper-server-start.sh config/zookeeper.properties Start the Kafka service bin/kafka-server-start.sh config/server.properties Make sure to always start Zookeper first, and then Kafka. "],
["references.html", "Chapter 15 References", " Chapter 15 References "]
]
