```{r include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
source("r/render.R")
source("r/plots.R")
library(ggplot2)
```

# Streaming {#streaming}

> "Our stories aren't over yet."
>
> --- Arya Star

We can look back at the previous eleven chapters and think, what else are we missing? We've done everything from analysing tabular datasets, performed unsupervised learning over raw text, analyzed graphs and geographic datasets and even transformd data with custom R code! So now what?

We were not explicit about this, but we've always assumed your data is static, we assumed it doesn't change over time. But suppose for a moment your job is to analize traffic patterns to give recomendations to the department of transportation. A very reasonable approach would be to analyze historical data and then design predictive models that compute forecasts overnight. Overnight? That's very useful but traffic patterns change to the hour and even by the minute. You could try to preprocess and predict faster and faster, but eventually this model breaks -- you can't load large-scale datasets, transform them, score them, unload them and repeat this process by the second.

Instead, we need to introduce a different kind of dataset, one that is not static but rather dynamic; one that is like a table but is growing constantly, we will refer to such datasets as stream.

## Overview

We know how to work with large-scale static datasets, all the previous chapters dealt with them; but how should we reason about large-scale real-time datasets? We will define as *streams* -- datasets with an infinite amount entries, as illustrated in Figure 1.1.

For instance, if we wanted to do real-time scoring using a pre-trained topic model, the enries would be lines of text for static datasets; for real-time datasets, we would perform the same scoring over an infinite amount of lines of text. Now, in practice, you will never process an infinite amount of records, you will eventually stop the stream -- or this universe might end, whatever comes first -- regardless, thinking of them as infinite datasets makes it so much easier to reason about them.

Streams are most relevant when processing real time data; for example, when analyzing a Twitter feed or stock prices. Both examples have well defined columns, like 'tweet' or 'price', but there are always new rows of data to be analyzed.

Spark *Structured Streams* provide scalable and fault-torerant data processing over streams of data. That means, one can use many machines to process multiple streaming sources, perform joins with other streams or static sources, and recover from failures with at-least-once guarantees (each message is certain to be delivered, but may do so multiple times).

In Spark, you create streams by defining a *source*, a *transformation* and a *sink*; you can think of these steps as reading, transforming and writting a stream, which Figure \@ref(fig:streaming-working) describes.

Reading
: Streams read data using any of the `stream_read_*()` functions, the read operation defines the *source* of the stream; you can define one or multiple sources from which to read from.

Transforming
: A stream can perform one or multiple **transformation** using `dplyr`, `SQL`, feature transformers, scoring pipelines or distributed R code. Transformations can join against streaming sources or static datsets.

Writing
: The write operations are performed with the family of `stream_write_*()` functions, the read operation defined the *sink* of the stream. You can specify a single sink to write data to or multiple ones.

```{r streaming-working, echo=FALSE, fig.cap='Working with Spark Streams', fig.align = 'center', eval = TRUE}
render_nomnoml("
#direction: right
[Real-Time|[<note>File Source
               Kafka Source
]]->[Transform|[<note>dplyr
                SQL
                Feature Transformers
                Pipelines
                Distributed R
]]
[Static|[<note>File Systems
               Storage Systems]
]->[Transform]
[Transform]->[Sink|[<note>File Sink
                          Kafka Sink]]
", "images/streaming-working.png")
```

You can read and write to streams in several different file formats: CSV, JSON, Parquet, ORC and text; and form Kafka which we will introduce later on.

| Format  | Read                | Write                |
|---------|---------------------|----------------------|
| CSV     | stream_read_csv     | stream_write_csv     |
| JSON    | stream_read_json    | stream_write_json    |
| Kafka   | stream_read_kafka   | stream_write_kafka   |
| ORC     | stream_read_orc     | stream_write_orc     |
| Parquet | stream_read_parquet | stream_write_parquet |
| Text    | stream_read_text    | stream_write_text    |
| Memory  |                     | stream_write_memory  |

Since the transformation step is optional, the simplest stream we can define is one that continuously copies text files between source and destination.

First, install the `future` package with `install.packages("future")` and connect to Spark:

```{r streaming-overview-prepare, echo=FALSE}
library(sparklyr)
sc <- spark_connect(master = "local", version = "2.3")
```

Since a stream requires the source to exist, create a `source` folder:

```{r}
dir.create("source")
```

We are now ready to define our first stream!

```{r}
stream <- stream_read_text(sc, "source/") %>%
  stream_write_text("destination/")
```

The streams starts running with `stream_write_*()`; once executed, the stream will monitor the `source` path and process data into the `destination/` path as it arrives.

We can use `stream_generate_test()` to produce a file every second containing lines of text that follow overlapping binomial distributions, you can read more about this in the Appendix. In practice, you would connect to existing sources without having to generate data artificially. We can then use `view_stream()` to track the **rows per second (rps)** being processed in the source, destination and their latest values over time. The result is shown in Figure .

```{r streaming-overview-test, eval=FALSE}
future::future(stream_generate_test(interval = 0.5))
stream_view(stream)
```

```{r streaming-view-stream, eval=TRUE, fig.align='center', echo=FALSE, fig.cap='Monitoring a stream generating rows following a binomial distribution'}
render_image("images/streaming-stream-view.png")
```

Notice that the rows-per-second in the destination stream are higher than the rows-per-second in the source stream; this is expected and desireable since Spark measures incoming rates from the source, but actual row processing times in the destination stream. For example, if 10 rows-per-second are written to the `source/` path, the incoming rate is 10 RPS. However, if it takes Spark only 0.01 seconds to write all those 10 rows, the output rate is 100 RPS.

Use `stream_stop()` to properly stop processing data from this stream.

```{r streaming-overview-stop, eval=FALSE}
stream_stop(stream)
```

This exercise introduced how we can easily start a Spark stream that reads and writes data based on a simulated stream, let's do something more interesting than just copying data with proper transformations.

## Transformations 

In a real life scenario, the incoming data from a stream would not be written as-is to the output.  The Spark Stream job would make transformations to the data, and then write the transformed data.

Streams can be transformed using `dplyr`, SQL queries, ML Pipelines or R code. We can use as many transformations as needed in the same way that Spark data frames can be transformed with `sparklyr`. 

The source of the transformation can be a stream or data frames, but the output is always a stream. If needed, one can always take a snapshot from the destination stream, and then save the output as a data frame. That is what `sparklyr` will do for you if a destination stream is not specified. 

Each sub-section will cover an option provided by `sparklyr` to perform transformations on a stream. 

### Analysis

You can an analyze streams with `dplyr` verbs and SQL using `DBI`, as a quick example, we will filter rows and add columns over a stream. We won't explicitly call `stream_generate_test()`, but you can call it on your own through the `later` package if you feel the urge to verify that data is being processed continuosly.

```{r}
library(dplyr)

stream_read_csv(sc, "source") %>%
  filter(x > 700) %>%
  mutate(y = round(x / 100))
```
```
# Source: spark<?> [inf x 2]
       x     y
   <int> <dbl>
 1   701     7
 2   702     7
 3   703     7
 4   704     7
 5   705     7
 6   706     7
 7   707     7
 8   708     7
 9   709     7
10   710     7
# … with more rows
```

It also is possible to perform aggregations over the entire history of the stream.  The history could be filtered or not.

```{r}
stream_read_csv(sc, "source") %>%
  filter(x > 700) %>%
  mutate(y = round(x / 100)) %>%
  count(y) 
```
```
# Source: spark<?> [inf x 2]
      y     n
  <dbl> <dbl>
1     8 25902
2     9 25902
3    10 13210
4     7 12692
```

Grouped aggregations of the latest data in the stream require a time stamp.  The time stamp will be of when reading function, in this case `stream_read_csv()` , first "saw" that specific record. In Spark stream terms, that time stamp is called a "watermark".  The `spark_watermark()` function is used to add the time stamp.  For this exercise, the watermark will be the same for all records, since the five files were read by the stream after they were created.  Please note that only Kafka and memory *outputs* support watermarks.  

```{r}
stream_read_csv(sc, "source") %>%
  stream_watermark()
```
```
# Source: spark<?> [inf x 2]
       x timestamp          
   <int> <dttm>             
 1   276 2019-06-30 07:14:21
 2   277 2019-06-30 07:14:21
 3   278 2019-06-30 07:14:21
 4   279 2019-06-30 07:14:21
 5   280 2019-06-30 07:14:21
 6   281 2019-06-30 07:14:21
 7   282 2019-06-30 07:14:21
 8   283 2019-06-30 07:14:21
 9   284 2019-06-30 07:14:21
10   285 2019-06-30 07:14:21
# … with more rows
```

After the watermark is created, it can be used in the `group_by()` verb.  It can then be piped into a `summarise()` function to get some stats of the stream.

```{r}
stream_read_csv(sc, "source") %>%
  stream_watermark() %>%
  group_by(timestamp) %>%
  summarise(
    max_x = max(x, na.rm = TRUE),
    min_x = min(x, na.rm = TRUE),
    count = n()
  ) 
```
```
# Source: spark<?> [inf x 4]
  timestamp           max_x min_x  count
  <dttm>              <int> <int>  <dbl>
1 2019-06-30 07:14:55  1000     1 259332
```

### Modeling

Spark streams currently do not support training on reael-time datasets, aside from the technical challenges; even if it were possible, it would be quite challenging to train models since the model itself would have to adapt over time, this is known as *online learning* and perhaps something that Spark will support in the future.

That said, there are other modeling concepts we can use with streams, like feature transformers and scoring, lets try out a feature transformer with streams and leave scoring for the next section since we will need to train a model.

The next example makes use of the `ft_bucketizer()` feature transformer to modify the stream followed by regular `dplyr` functions which you can use just as you would with static datasets.

```{r}
stream_read_csv(sc, "source") %>%
  mutate(x = as.numeric(x)) %>%
  ft_bucketizer("x", "buckets", splits = 0:10 * 100) %>%
  count(buckets)  %>%
  arrange(buckets)
```
```
# Source:     spark<?> [inf x 2]
# Ordered by: buckets
   buckets     n
     <dbl> <dbl>
 1       0 25747
 2       1 26008
 3       2 25992
 4       3 25908
 5       4 25905
 6       5 25903
 7       6 25904
 8       7 25901
 9       8 25902
10       9 26162
```

### Pipelines

Spark pipelines can be used for scoring streams, but not to train over streaming data. The former is fully supported while the latter is a feature under active development by the Spark community.

In order to score a stream, it is necessary to first create a our model. So lets build, fit and save a simple pipeline.

```{r}
cars <- copy_to(sc, mtcars)

model <- ml_pipeline(sc) %>%
  ft_binarizer("mpg", "over_30", 30) %>%
  ft_r_formula(over_30 ~ wt) %>%
  ml_logistic_regression() %>%
  ml_fit(cars)
```

**Tip:** If you choose to, you can make use of other concepts presented in the Pipelines chapter, like saving and reloading pipelines through `ml_save()` and `ml_load()` before scoring streams.

We can then generate a stream based on `mtcars` using `stream_generate_test()` and score the model using `ml_transform()`:

```{r}
future::future(stream_generate_test(mtcars, "cars-stream", iterations = 5))

ml_transform(model, stream_read_csv(sc, "cars-stream"))
```
```
# Source: spark<?> [inf x 17]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb over_30
   <dbl> <int> <dbl> <int> <dbl> <dbl> <dbl> <int> <int> <int> <int>   <dbl>
 1  15.5     8 318     150  2.76  3.52  16.9     0     0     3     2       0
 2  15.2     8 304     150  3.15  3.44  17.3     0     0     3     2       0
 3  13.3     8 350     245  3.73  3.84  15.4     0     0     3     4       0
 4  19.2     8 400     175  3.08  3.84  17.0     0     0     3     2       0
 5  27.3     4  79      66  4.08  1.94  18.9     1     1     4     1       0
 6  26       4 120.     91  4.43  2.14  16.7     0     1     5     2       0
 7  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2       1
 8  15.8     8 351     264  4.22  3.17  14.5     0     1     5     4       0
 9  19.7     6 145     175  3.62  2.77  15.5     0     1     5     6       0
10  15       8 301     335  3.54  3.57  14.6     0     1     5     8       0
# … with more rows, and 5 more variables: features <list>, label <dbl>,
#   rawPrediction <list>, probability <list>, prediction <dbl>
```

Eventhough the example this example was put together with a few lines of code, it is actually quite impressive what we just accomplished: You copied data into Spark, performed feature engineering, traineed a model and scored the model over a real-time dataset, with seven lines of code! -- Let's try now to use custom transformations, in real-time.

### Distributed R {streaming-r-code}

Arbitrary R code can also be used to transform a stream with the use of `spark_apply()`. This approach follows the same principles discussed in the Distributed R chapter, as in, `spark_apply()` runs R code over each executor in the cluster where data is available, this enables processing high-throughput streams and fulfill low-latency requirements.

```{r}
stream_read_csv(sc, "cars-stream") %>%
  select(mpg) %>%
  spark_apply(~ round(.x), mpg = "integer") %>%
  stream_write_csv("cars-round")
```

Which as you would expect, processes data from `cars-stream` into `cars-round` by running the custom `round()` R function, lets pick into the output sink:

```{r}
spark_read_csv(sc, "cars-round")
```
```
# Source: spark<carsround> [?? x 1]
     mpg
   <dbl>
 1    16
 2    15
 3    13
 4    19
 5    27
 6    26
 7    30
 8    16
 9    20
10    15
# … with more rows
```

Again, make sure you apply the concepts you already know about `spark_apply()` when using streams; for instance, you should consider using `arrow` to significantly improve performance. 

This was our last transformation for streams, you will now learn how to use Spark streams with Shiny, a package that makes it easy to build interactive web applications from R. 

## Kafka

Apache Kafka is to streaming as what Hadoop is to data storage/retrieval. Hadoop provides a a distributed, resilient and reliable architecture for large-scale data storage. Kafka does the same, but for large-scale streaming applications.

The most basic Kafka workflow is illustrated on Figure \@ref(fig:streaming-kafka-apis). An application that streams data into Kafka is called a *Producer*.  Kafka stores the stream as records. Each record has a key, a value and a timestamp. Kafka can handle multiple streams that contain different information, to properly categorize each stream, Kafka uses a mechanism called topic. A topic is a alpha-numeric identifier of the stream.  A *Consumer* is an app that is external to Kafka that reads what is stored in Kafka for a given topic. The Consumer app is constantly monitoring the topic, that is called a subscription. 

```{r streaming-kafka-apis, echo=FALSE, fig.cap='Basic workflow', fig.align = 'center', eval = TRUE}
render_nomnoml("
#direction: right
#padding: 10
#fontSize: 14
#leading: 2
[Producer | Stream topic A] -> [Kafka | Store topic A]
[Kafka] -> [Consumer | Subscribe to topic A]
", "images/streaming-kafka-apis.png")
```

Kafka also allows for an application to read from one topic, process its data, and then write the results to a different topic. That is called a *Stream Processor*. In Figure \@ref(fig:streaming-kafka-two-outputs), the Stream Processor reads topic A, and then writes results to topic B. This allows for a given *Consumer* application to read results instead of “raw” feed data.

```{r streaming-kafka-two-outputs, echo=FALSE, fig.cap='Kafka workflow', fig.align = 'center', eval = TRUE}
render_nomnoml("
#direction: right
#padding: 10
#fontSize: 14
#leading: 2

[Producer | Stream topic A] -> [Kafka | Store topics A & B]
[Kafka] <-> [Stream Processor | Subscribes to topic A
Results to topic B]
[Kafka] -> [Consumer | Subscribe to topic B]

", "images/streaming-kafka-two-outputs.png")
```

Spark Streaming enables the integration of Spark with Kafka.  Spark is able to both, read from and write into Kafka topics.  This means that Spark could be a Consumer, Stream Processor or Producer application of a Kafka implementation.  
Unless there is a very specific need, using Spark as a Producer does not make much sense.  That is because Spark Streaming reacts to a stream, it doesn't generate it.  
Use Spark to read (Consumer) from one, or several, topics and then reactively write (Producer) to a different topic with the results of the analysis, all within the same Kafka cluster. This effectively makes Spark a Stream Processor.

There are nuances on how the Spark-to-Kafka write-back modes works, so it is important for us to offer some clarification.  There are three modes available: *complete*, *update* and *append*.  The *complete* mode will provide the totals for every group every time there is a new batch.  The *update* mode will provide totals for only the groups that have updates in the latest batch.  The *append* mode is able to add raw records to the target topic. This mode is not meant for aggregates, but works well for passing a filtered subset to the target topic.

The additional parameters are passed via the `options` argument.  The contents of the `options` argument are passed down to Kafka as-is. This means that the same Kafka options used in your other applications can be reused here. There are three basic Kafka options to keep in mind: `kafka.bootstrap.server`, `topic` and `subscribe`.  The former expects a list of the of one or more hosts from the Kafka cluster.  The other two set the topic that the function is either reading from or writing to.  One is used at the exclusion of the other.  For reading the `subscribe` option is used, and for writing, `topic` is used. 
    
```{r}
stream_read_kafka(
  sc, 
  options = list(
    kafka.bootstrap.server = "host1:9092, host2:9092", 
    subscribe = "topic"
    )
  ) 
```

In this example, we will setup a Producer, and a Kafka engine outside of R. Inside R, we will start a Spark Stream Processor and a Consumer. 

The *Producer* will stream random, single letters of the alphabet into Kafka. The topic will be called "letters". 

A *Stream Processor* will be built in Spark by having it read the "letters" topic, and then produce the count by unique letter passed through the stream.  The count will be passed back to Kafka in separate topic called "totals". 

To see the results, the same Spark connection will be used to setup a *Consumer* that reads the "totals" topic. Figure \@ref(fig:streaming-kafka-example) is a diagram of how this example will work. 

```{r streaming-kafka-example, echo=FALSE, fig.cap='Kafka example', fig.align = 'center', eval = TRUE}
render_nomnoml("
#direction: right
#padding: 10
#fontSize: 14
#leading: 2

[Producer | Streams 'letters'] -> [Kafka | Stores 'letters' & 'totals']
[Kafka] <-> [Stream Processor 
(Spark)| Subscribes to 'letters'
Writes results to 'totals']
[Kafka] -> [Consumer
(Spark) | Subscribes to 'totals']

", "images/streaming-kafka-example.png")
```

The example will use the `update` mode for writing back into Kafka.  This means that only the totals of the letters that changed will be sent to the "totals" topic.  The change in totals is determined after each batch from the "letters" topic is received. Figure \@ref(fig:streaming-kafka-processor) offers an deeper look of what the **Stream Processor (Spark)** process is supposed to do. 

```{r streaming-kafka-processor, echo=FALSE, fig.cap='Stream Processor - Update mode', fig.align = 'center', eval = TRUE}
render_nomnoml("
#direction: right
#padding: 10
#fontSize: 14
#leading: 2

['totals' topic |
[timestamp 1 | A B A A B C ]
[timestamp 2 | B B C C B C ]
] -> [Stream Processor | Spark Streaming]
[Stream Processor] -> ['totals' topic | 
[timestamp 1 | A=3 B=2 C=1 ] 
[timestamp 2 | B=5 C=4 ]
]
", "images/streaming-kafka-processor.png")
```

The *infrastructure* used for this example was a local, single node Kafka cluster.  The external Producer uses the Kafka command line interface (CLI) to send the stream of letters. The installation instructions that were used can be found in the Appendix under the Kafka section. 

```{r}
library(sparklyr)
library(dplyr)

config <- spark_config()
config$sparklyr.shell.packages <- "org.apache.spark:spark-sql-kafka-0-10_2.11:2.4.0"
sc <- spark_connect(master = "local", config = config)

# The local Kafka cluster is served on port 9092, by default.
hosts  <- "localhost:9092"

read_options <- list(kafka.bootstrap.servers = hosts, subscribe = "letters")
write_options <- list(kafka.bootstrap.servers = hosts, topic = "totals")

stream_read_kafka(sc, options = read_options) %>%
  mutate(value = as.character(value)) %>%     # coerce into a character
  count(value) %>%                            # group and count letters
  mutate(value = paste0(value, "=", n)) %>%   # value field expected in Kafka
  stream_write_kafka(mode = "update", options = write_options)
```

The last step starts a Spark job which will remain active until stopped or until you disconnect form Spark. At this point, there is no visible output, even if there was an active Producer sending letters over.  

A simple Shiny application can be used as a *Consumer* app. It will read the "totals" topic, select the latest count for a given letter, and then display the results on a table. 

```{r}
library(shiny)
ui <- function() tableOutput("table")
server <- function(input, output, session){
  totals_options  <- list(kafka.bootstrap.servers = hosts, subscribe = "totals")
  ps <- stream_read_kafka(sc, options = totals_options) %>%
    mutate(value = as.character(value),
           letter = substr(value, 1,1),
           total = as.numeric(substr(value, 3, 100))
           ) %>%
    group_by(letter) %>%
    summarise(total = max(total, na.rm = TRUE)) %>%
    arrange(letter) %>%
    reactiveSpark()  
  output$table <- renderTable(ps())
}
runGadget(ui, server)
```

A new terminal session is started. Kafka's CLI provides a simple Producer program that runs in the console.  Using that program, we can manually write a single letter, and then press enter.  

```
user@laptop:~/kafka_2.12-2.2.0$ bin/kafka-console-producer.sh --broker-list localhost:9092 --topic letters
>A
>B
>C
>A
>A
>C
>D
```

The Shiny reactive function will poll and refresh the results as the letters are being entered.  This is shown in figure 11.8.

```{r streaming-shiny-kafka, eval = TRUE,  fig.align = 'center', fig.cap = 'Shiny with Kafka', echo = FALSE}
render_image("images/streaming-shiny-kafka.png")
```

## Shiny

Shiny's reactive framework is well suited to support streaming information which you can use to display real-time data from Spark using the `reactiveSpark()`, reactive. There is much to learn about Shiny which we can possibly present; however, if you are already familiar with Shiny, this example should be quite easy to undeerstand.

We have a modified verson of the k-means Shiny example which, instead of getting the data from the static `iris` dataset, gets generated with `stream_generate_test()`, consumed by Spark and retrieved to Shiny through `reactiveSpark()` and displayed as captured in Figure \@ref(fig:streaming-shiny-app), enjoy!

```{r}
options(sparklyr.sanitize.column.names = FALSE)
library(sparklyr)
library(shiny)

# Connect to Spark, only required to create a proper Shiny app
sc <- spark_connect(master = "local", version = "2.3")

ui <- pageWithSidebar(
  headerPanel('Iris k-means clustering from Spark stream'),
  sidebarPanel(
    selectInput('xcol', 'X Variable', names(iris)),
    selectInput('ycol', 'Y Variable', names(iris),
                selected=names(iris)[[2]]),
    numericInput('clusters', 'Cluster count', 3,
                 min = 1, max = 9)
  ),
  mainPanel(plotOutput('plot1'))
)

server <- function(input, output, session) {
  iris <- stream_read_csv(sc, "shiny-stream") %>%
    reactiveSpark()
  
  selectedData <- reactive({
    iris()[, c(input$xcol, input$ycol)]
  })

  clusters <- reactive({
    kmeans(selectedData(), input$clusters)
  })

  output$plot1 <- renderPlot({
    par(mar = c(5.1, 4.1, 0, 1))
    plot(selectedData(),
         col = clusters()$cluster,
         pch = 20, cex = 3)
    points(clusters()$centers, pch = 4, cex = 4, lwd = 4)
  })
}

app <- shinyApp(ui, server)
```

The Shiny app can be activated with `runApp()` and the test stream with `stream_generate_test()` using a constant distribution this time.

```{r}
unlink("shiny-stream", recursive = TRUE)
future::future(stream_generate_test(iris, "shiny-stream", rep(5, 10^3)))

runApp(app)
```

```{r streaming-shiny-app, eval = TRUE,  fig.align = 'center', fig.cap = 'Progreession of Spark reactive loading data into Shiny app', echo = FALSE}
render_image("images/streaming-shiny-app.png")
```

This section showed how easy it is to create a Shiny app that can be used for several purposes, such as monitoring, and dashboarding.  

In a more complex implementation, the source would more likely be a Kafka stream.  The next section will cover how to integrate Kafka, Spark Stream and `sparklyr`. 

Before we transition, disconnect from Spark and clear the folders that we used:

```{r}
spark_disconnect(sc)

unlink(c("source", "destination", "cars-stream",
         "car-round", "shiny-stream"), recursive = TRUE)
```

## Recap


